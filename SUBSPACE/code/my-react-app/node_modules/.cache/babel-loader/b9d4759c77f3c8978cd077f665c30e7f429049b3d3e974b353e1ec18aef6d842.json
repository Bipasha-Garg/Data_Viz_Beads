{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// Here points are on boundary\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     // Dynamically extract subspace keys\n//     const subspaceKeys = Object.keys(jsonData);\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate center and square spacing\n//     const centerX = width / 2;\n//     const centerY = height / 2;\n//     const squareSpacing = 200; // Distance between consecutive squares\n\n//     const nodes = [];\n//     const links = [];\n\n//     // Function to calculate node positions on the square's perimeter\n//     const calculateSquarePerimeterPositions = (numPoints, squareIndex) => {\n//       const size = squareSpacing * (squareIndex + 1); // Square size grows with the index\n//       const positions = [];\n//       const pointsPerSide = Math.ceil(numPoints / 4);\n//       const sideLength = size;\n\n//       for (let i = 0; i < numPoints; i++) {\n//         const side = Math.floor(i / pointsPerSide); // Determine which side of the square\n//         const offset = i % pointsPerSide;\n//         let x, y;\n\n//         if (side === 0) {\n//           // Top side\n//           x = centerX - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//           y = centerY - sideLength / 2;\n//         } else if (side === 1) {\n//           // Right side\n//           x = centerX + sideLength / 2;\n//           y = centerY - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//         } else if (side === 2) {\n//           // Bottom side\n//           x = centerX + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//           y = centerY + sideLength / 2;\n//         } else {\n//           // Left side\n//           x = centerX - sideLength / 2;\n//           y = centerY + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//         }\n\n//         positions.push({ x, y });\n//       }\n//       return positions;\n//     };\n\n//     // Build hierarchical nodes and links\n//     subspaceKeys.forEach((subspace, index) => {\n//       const points = jsonData[subspace];\n//       const positions = calculateSquarePerimeterPositions(points.length, index);\n\n//       points.forEach((point, i) => {\n//         const id = `${subspace}-${i}`;\n//         const node = {\n//           id,\n//           ...point,\n//           x: positions[i].x,\n//           y: positions[i].y,\n//         };\n//         nodes.push(node);\n\n//         // Add links to the previous square\n//         if (index > 0) {\n//           links.push({\n//             source: nodes[nodes.length - points.length - i - 1].id,\n//             target: id,\n//           });\n//         }\n//       });\n//     });\n\n//     // Draw squares\n//     subspaceKeys.forEach((_, index) => {\n//       const size = squareSpacing * (index + 1);\n//       svg\n//         .append(\"rect\")\n//         .attr(\"x\", centerX - size / 2)\n//         .attr(\"y\", centerY - size / 2)\n//         .attr(\"width\", size)\n//         .attr(\"height\", size)\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 2);\n//     });\n\n//     // Draw links\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"x1\", (d) => nodes.find((node) => node.id === d.source)?.x)\n//       .attr(\"y1\", (d) => nodes.find((node) => node.id === d.source)?.y)\n//       .attr(\"x2\", (d) => nodes.find((node) => node.id === d.target)?.x)\n//       .attr(\"y2\", (d) => nodes.find((node) => node.id === d.target)?.y)\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 1);\n\n//     // Draw nodes\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"cx\", (d) => d.x)\n//       .attr(\"cy\", (d) => d.y)\n//       .attr(\"fill\", (d, i) =>\n//         i < jsonData[subspaceKeys[0]].length\n//           ? \"red\"\n//           : i < jsonData[subspaceKeys[1]].length\n//           ? \"blue\"\n//           : \"green\"\n//       )\n//       .on(\"mouseover\", (event, d) => {\n//         setHoveredCoordinates({\n//           ...d,\n//           id: d.id,\n//         });\n//       });\n\n//     // Add tooltips\n//     svg\n//       .selectAll(\"circle\")\n//       .append(\"title\")\n//       .text((d) => `ID: ${d.id}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  setHoveredCoordinates\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(key => key !== \"Cluster\" && key !== \"Bead\");\n    const numDimensions = coordinateKeys.length;\n\n    // Assign bit vectors based on coordinate keys (subspace)\n    const assignBitVector = point => {\n      return coordinateKeys.map(key => point[key] >= 0 ? \"1\" : \"0\").join(\"\");\n    };\n\n    // Parse and process data\n    const nodes = jsonData.map((point, index) => ({\n      id: `point-${index}`,\n      ...point,\n      bitVector: assignBitVector(point)\n    }));\n\n    // Set up container dimensions\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n    const margin = {\n      top: 20,\n      right: 20,\n      bottom: 20,\n      left: 20\n    };\n    const svg = d3.select(graphRef.current).attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n    const size = Math.min(width, height);\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Define square dimensions\n    const squarePadding = 20;\n    const squareSizes = Array.from({\n      length: numDimensions\n    }, (_, i) => size / 2 - i * (squarePadding + size / (2 * numDimensions)));\n\n    // Draw concentric squares\n    const squares = svg.append(\"g\").attr(\"class\", \"squares\").selectAll(\"rect\").data(squareSizes).enter().append(\"rect\").attr(\"x\", d => centerX - d / 2).attr(\"y\", d => centerY - d / 2).attr(\"width\", d => d).attr(\"height\", d => d).attr(\"fill\", \"none\").attr(\"stroke\", \"#ddd\").attr(\"stroke-width\", 1);\n\n    // Function to randomly place points inside a square\n    const getRandomPointInSquare = squareSize => {\n      const halfSize = squareSize / 2;\n      return [centerX - halfSize + Math.random() * squareSize, centerY - halfSize + Math.random() * squareSize];\n    };\n\n    // Plot points inside their respective squares\n    const points = svg.append(\"g\").attr(\"class\", \"points\").selectAll(\"circle\").data(nodes).enter().append(\"circle\").attr(\"r\", 5).attr(\"cx\", d => {\n      const dimensionIndex = d.bitVector.replace(/0/g, \"\").length - 1;\n      const [x] = getRandomPointInSquare(squareSizes[dimensionIndex]);\n      return x;\n    }).attr(\"cy\", d => {\n      const dimensionIndex = d.bitVector.replace(/0/g, \"\").length - 1;\n      const [, y] = getRandomPointInSquare(squareSizes[dimensionIndex]);\n      return y;\n    }).attr(\"fill\", \"blue\").on(\"mouseover\", (event, d) => {\n      const coordinates = {};\n      coordinateKeys.forEach(key => {\n        coordinates[key] = d[key];\n      });\n      setHoveredCoordinates({\n        ...coordinates,\n        id: d.id,\n        bitVector: d.bitVector\n      });\n    });\n\n    // Add tooltips\n    points.append(\"title\").text(d => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n  }, [jsonData, setHoveredCoordinates]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: graphRef,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 286,\n    columnNumber: 10\n  }, this);\n};\n_s(HierarchicalGraph, \"XNG/roOlNWxTF7ymftfdirhS32A=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","setHoveredCoordinates","_s","graphRef","length","coordinateKeys","Object","keys","filter","key","numDimensions","assignBitVector","point","map","join","nodes","index","id","bitVector","container","select","current","parentNode","width","node","getBoundingClientRect","height","margin","top","right","bottom","left","svg","attr","selectAll","remove","size","Math","min","centerX","centerY","squarePadding","squareSizes","Array","from","_","i","squares","append","data","enter","d","getRandomPointInSquare","squareSize","halfSize","random","points","dimensionIndex","replace","x","y","on","event","coordinates","forEach","text","ref","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["// Here points are on boundary\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     // Dynamically extract subspace keys\n//     const subspaceKeys = Object.keys(jsonData);\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate center and square spacing\n//     const centerX = width / 2;\n//     const centerY = height / 2;\n//     const squareSpacing = 200; // Distance between consecutive squares\n\n//     const nodes = [];\n//     const links = [];\n\n//     // Function to calculate node positions on the square's perimeter\n//     const calculateSquarePerimeterPositions = (numPoints, squareIndex) => {\n//       const size = squareSpacing * (squareIndex + 1); // Square size grows with the index\n//       const positions = [];\n//       const pointsPerSide = Math.ceil(numPoints / 4);\n//       const sideLength = size;\n\n//       for (let i = 0; i < numPoints; i++) {\n//         const side = Math.floor(i / pointsPerSide); // Determine which side of the square\n//         const offset = i % pointsPerSide;\n//         let x, y;\n\n//         if (side === 0) {\n//           // Top side\n//           x = centerX - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//           y = centerY - sideLength / 2;\n//         } else if (side === 1) {\n//           // Right side\n//           x = centerX + sideLength / 2;\n//           y = centerY - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//         } else if (side === 2) {\n//           // Bottom side\n//           x = centerX + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//           y = centerY + sideLength / 2;\n//         } else {\n//           // Left side\n//           x = centerX - sideLength / 2;\n//           y = centerY + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//         }\n\n//         positions.push({ x, y });\n//       }\n//       return positions;\n//     };\n\n//     // Build hierarchical nodes and links\n//     subspaceKeys.forEach((subspace, index) => {\n//       const points = jsonData[subspace];\n//       const positions = calculateSquarePerimeterPositions(points.length, index);\n\n//       points.forEach((point, i) => {\n//         const id = `${subspace}-${i}`;\n//         const node = {\n//           id,\n//           ...point,\n//           x: positions[i].x,\n//           y: positions[i].y,\n//         };\n//         nodes.push(node);\n\n//         // Add links to the previous square\n//         if (index > 0) {\n//           links.push({\n//             source: nodes[nodes.length - points.length - i - 1].id,\n//             target: id,\n//           });\n//         }\n//       });\n//     });\n\n//     // Draw squares\n//     subspaceKeys.forEach((_, index) => {\n//       const size = squareSpacing * (index + 1);\n//       svg\n//         .append(\"rect\")\n//         .attr(\"x\", centerX - size / 2)\n//         .attr(\"y\", centerY - size / 2)\n//         .attr(\"width\", size)\n//         .attr(\"height\", size)\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 2);\n//     });\n\n//     // Draw links\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"x1\", (d) => nodes.find((node) => node.id === d.source)?.x)\n//       .attr(\"y1\", (d) => nodes.find((node) => node.id === d.source)?.y)\n//       .attr(\"x2\", (d) => nodes.find((node) => node.id === d.target)?.x)\n//       .attr(\"y2\", (d) => nodes.find((node) => node.id === d.target)?.y)\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 1);\n\n//     // Draw nodes\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"cx\", (d) => d.x)\n//       .attr(\"cy\", (d) => d.y)\n//       .attr(\"fill\", (d, i) =>\n//         i < jsonData[subspaceKeys[0]].length\n//           ? \"red\"\n//           : i < jsonData[subspaceKeys[1]].length\n//           ? \"blue\"\n//           : \"green\"\n//       )\n//       .on(\"mouseover\", (event, d) => {\n//         setHoveredCoordinates({\n//           ...d,\n//           id: d.id,\n//         });\n//       });\n\n//     // Add tooltips\n//     svg\n//       .selectAll(\"circle\")\n//       .append(\"title\")\n//       .text((d) => `ID: ${d.id}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n  const graphRef = useRef(null);\n\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(\n      (key) => key !== \"Cluster\" && key !== \"Bead\"\n    );\n\n    const numDimensions = coordinateKeys.length;\n\n    // Assign bit vectors based on coordinate keys (subspace)\n    const assignBitVector = (point) => {\n      return coordinateKeys\n        .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n        .join(\"\");\n    };\n\n    // Parse and process data\n    const nodes = jsonData.map((point, index) => ({\n      id: `point-${index}`,\n      ...point,\n      bitVector: assignBitVector(point),\n    }));\n\n    // Set up container dimensions\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n    const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n    const svg = d3\n      .select(graphRef.current)\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", `0 0 ${width} ${height}`)\n      .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n\n    const size = Math.min(width, height);\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Define square dimensions\n    const squarePadding = 20;\n    const squareSizes = Array.from(\n      { length: numDimensions },\n      (_, i) => size / 2 - i * (squarePadding + size / (2 * numDimensions))\n    );\n\n    // Draw concentric squares\n    const squares = svg\n      .append(\"g\")\n      .attr(\"class\", \"squares\")\n      .selectAll(\"rect\")\n      .data(squareSizes)\n      .enter()\n      .append(\"rect\")\n      .attr(\"x\", (d) => centerX - d / 2)\n      .attr(\"y\", (d) => centerY - d / 2)\n      .attr(\"width\", (d) => d)\n      .attr(\"height\", (d) => d)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"#ddd\")\n      .attr(\"stroke-width\", 1);\n\n    // Function to randomly place points inside a square\n    const getRandomPointInSquare = (squareSize) => {\n      const halfSize = squareSize / 2;\n      return [\n        centerX - halfSize + Math.random() * squareSize,\n        centerY - halfSize + Math.random() * squareSize,\n      ];\n    };\n\n    // Plot points inside their respective squares\n    const points = svg\n      .append(\"g\")\n      .attr(\"class\", \"points\")\n      .selectAll(\"circle\")\n      .data(nodes)\n      .enter()\n      .append(\"circle\")\n      .attr(\"r\", 5)\n      .attr(\"cx\", (d) => {\n        const dimensionIndex = d.bitVector.replace(/0/g, \"\").length - 1;\n        const [x] = getRandomPointInSquare(squareSizes[dimensionIndex]);\n        return x;\n      })\n      .attr(\"cy\", (d) => {\n        const dimensionIndex = d.bitVector.replace(/0/g, \"\").length - 1;\n        const [, y] = getRandomPointInSquare(squareSizes[dimensionIndex]);\n        return y;\n      })\n      .attr(\"fill\", \"blue\")\n      .on(\"mouseover\", (event, d) => {\n        const coordinates = {};\n        coordinateKeys.forEach((key) => {\n          coordinates[key] = d[key];\n        });\n\n        setHoveredCoordinates({\n          ...coordinates,\n          id: d.id,\n          bitVector: d.bitVector,\n        });\n      });\n\n    // Add tooltips\n    points\n      .append(\"title\")\n      .text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n  }, [jsonData, setHoveredCoordinates]);\n\n  return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n};\n\nexport default HierarchicalGraph;\n"],"mappings":";;AAAA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAO,KAAKC,EAAE,MAAM,IAAI;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEzB,MAAMC,iBAAiB,GAAGA,CAAC;EAAEC,QAAQ;EAAEC;AAAsB,CAAC,KAAK;EAAAC,EAAA;EACjE,MAAMC,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAAC;EAE7BD,SAAS,CAAC,MAAM;IACd,IAAI,CAACM,QAAQ,IAAIA,QAAQ,CAACI,MAAM,KAAK,CAAC,EAAE;;IAExC;IACA,MAAMC,cAAc,GAAGC,MAAM,CAACC,IAAI,CAACP,QAAQ,CAAC,CAAC,CAAC,CAAC,CAACQ,MAAM,CACnDC,GAAG,IAAKA,GAAG,KAAK,SAAS,IAAIA,GAAG,KAAK,MACxC,CAAC;IAED,MAAMC,aAAa,GAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}