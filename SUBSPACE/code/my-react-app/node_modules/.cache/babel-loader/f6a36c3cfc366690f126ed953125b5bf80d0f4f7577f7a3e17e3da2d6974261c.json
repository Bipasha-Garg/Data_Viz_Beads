{"ast":null,"code":"// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // // //     const subspaces = Object.keys(jsonData);\n// // // //     console.log(subspaces.length);\n\n// // // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // // //     const pointsData = subspaces.map((key) => ({\n// // // //       key,\n// // // //       points: jsonData[key],\n// // // //       dimensions: key.length, \n// // // //       subspaceId: key, \n// // // //     }));\n\n// // // //     const svg = d3.select(graphRef.current);\n// // // //     const width = 1200;\n// // // //     const height = 1200;\n// // // //     const margin = 20;\n\n// // // //     svg.selectAll(\"*\").remove(); \n// // // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // // //     const g = svg\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .append(\"g\")\n// // // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // // //     pointsData.forEach((subspace, index) => {\n// // // //       const radius = maxRadius * ((index + 1) / subspaces.length);\n// // // //       const sectors = 2 ** (index +1); \n// // // //       console.log(sectors);\n\n// // // //       const colorScale = d3\n// // // //         .scaleOrdinal()\n// // // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); \n\n// // // //       const subspaceColor = colorScale(\n// // // //         subspace.dimensions % colorScale.range().length\n// // // //       );\n\n// // // //       g.append(\"circle\")\n// // // //         .attr(\"r\", radius)\n// // // //         .attr(\"stroke\", \"black\") \n// // // //         .attr(\"fill\", subspaceColor)\n// // // //         .attr(\"fill-opacity\", 0.2) \n// // // //         .attr(\"stroke-width\", 2); \n\n// // // //       if (subspace.dimensions > 0) {\n\n// // // //         for (let i = 0; i < sectors; i++) {\n// // // //           const angle = (2 * Math.PI * i) / sectors;\n// // // //           const x1 = radius * Math.cos(angle);\n// // // //           const y1 = radius * Math.sin(angle);\n// // // //           g.append(\"line\")\n// // // //             .attr(\"x1\", 0)\n// // // //             .attr(\"y1\", 0)\n// // // //             .attr(\"x2\", x1)\n// // // //             .attr(\"y2\", y1)\n// // // //             .attr(\"stroke\", \"black\")\n// // // //             .attr(\"stroke-width\", 1);\n\n// // // //           const labelX = (radius + 10) * Math.cos(angle); \n// // // //           const labelY = (radius + 10) * Math.sin(angle);\n\n// // // //           g.append(\"text\")\n// // // //             .attr(\"x\", labelX)\n// // // //             .attr(\"y\", labelY + 5) \n// // // //             .attr(\"text-anchor\", \"middle\")\n// // // //             .attr(\"dominant-baseline\", \"middle\")\n// // // //             .style(\"font-size\", \"10px\")\n// // // //             .style(\"fill\", \"black\");\n// // // //         }\n// // // //       }\n\n// // // //       const sectorRadius = radius;\n\n// // // //       subspace.points.forEach((point) => {\n// // // //         const bitPattern = point.Point_ID.toString(2).padStart(\n// // // //           subspace.dimensions,\n// // // //           \"0\"\n// // // //         );\n// // // //         const sectorIndex = parseInt(bitPattern, 2);\n// // // //         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n// // // //         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n// // // //         const minRadius = sectorRadius * 0.2;\n// // // //         const randomRadius =\n// // // //           minRadius + Math.random() * (sectorRadius - minRadius);\n// // // //         const randomAngle =\n// // // //           sectorAngleStart +\n// // // //           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n// // // //         const x = randomRadius * Math.cos(randomAngle);\n// // // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // // //         if (Math.sqrt(x * x + y * y) <= radius) {\n// // // //           const circle = g\n// // // //             .append(\"circle\")\n// // // //             .attr(\"cx\", x)\n// // // //             .attr(\"cy\", y)\n// // // //             .attr(\"r\", 4)\n// // // //             .attr(\"fill\", \"black\")\n// // // //             .attr(\"stroke\", \"white\")\n// // // //             .attr(\"stroke-width\", 0.5)\n// // // //             .append(\"title\")\n// // // //             .text(\n// // // //               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n// // // //             );\n\n// // // //           circle\n// // // //             .on(\"mouseover\", function () {\n// // // //               d3.select(this).attr(\"fill\", \"red\");\n// // // //             })\n// // // //             .on(\"mouseout\", function () {\n// // // //               d3.select(this).attr(\"fill\", \"black\");\n// // // //             });\n// // // //         } else {\n// // // //           console.warn(\n// // // //             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n// // // //           ); \n// // // //         }\n// // // //       });\n// // // //     });\n// // // //   }, [jsonData]);\n\n// // // //   return <svg ref={graphRef} style={{ width: \"1200px\", height: \"1200px\" }}></svg>;\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // // //     const subspaces = Object.keys(jsonData);\n// // // //     console.log(\"Number of subspaces:\", subspaces.length);\n\n// // // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // // //     const pointsData = subspaces.map((key) => ({\n// // // //       key,\n// // // //       points: jsonData[key],\n// // // //       dimensions: key.length,\n// // // //       subspaceId: key,\n// // // //     }));\n\n// // // //     const svg = d3.select(graphRef.current);\n// // // //     const width = 600;\n// // // //     const height = 600;\n// // // //     const margin = 20;\n\n// // // //     svg.selectAll(\"*\").remove();\n// // // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // // //     const g = svg\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .append(\"g\")\n// // // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // // //     pointsData.forEach((subspace, index) => {\n// // // //       const radius = maxRadius * ((index + 1) / subspaces.length);\n// // // //       const sectors = 2 ** (index + 1);\n\n// // // //       const colorScale = d3\n// // // //         .scaleOrdinal()\n// // // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n\n// // // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // // //       g.append(\"circle\")\n// // // //         .attr(\"r\", radius)\n// // // //         .attr(\"stroke\", \"black\")\n// // // //         .attr(\"fill\", subspaceColor)\n// // // //         .attr(\"fill-opacity\", 0.2)\n// // // //         .attr(\"stroke-width\", 2);\n\n// // // //       if (index + 1 > 0) {\n// // // //         for (let i = 0; i < sectors; i++) {\n// // // //           const angle = (2 * Math.PI * i) / sectors;\n// // // //           const x1 = radius * Math.cos(angle);\n// // // //           const y1 = radius * Math.sin(angle);\n// // // //           g.append(\"line\")\n// // // //             .attr(\"x1\", 0)\n// // // //             .attr(\"y1\", 0)\n// // // //             .attr(\"x2\", x1)\n// // // //             .attr(\"y2\", y1)\n// // // //             .attr(\"stroke\", \"black\")\n// // // //             .attr(\"stroke-width\", 1);\n\n// // // //           const labelX = (radius + 10) * Math.cos(angle);\n// // // //           const labelY = (radius + 10) * Math.sin(angle);\n\n// // // //           g.append(\"text\")\n// // // //             .attr(\"x\", labelX)\n// // // //             .attr(\"y\", labelY + 5)\n// // // //             .attr(\"text-anchor\", \"middle\")\n// // // //             .attr(\"dominant-baseline\", \"middle\")\n// // // //             .style(\"font-size\", \"10px\")\n// // // //             .style(\"fill\", \"black\");\n// // // //         }\n// // // //       }\n\n// // // //       const sectorRadius = radius;\n\n// // // //       subspace.points.forEach((point) => {\n// // // //         const bitPattern = point.Point_ID.toString(2).padStart(index + 1, \"0\");\n// // // //         const sectorIndex = parseInt(bitPattern, 2);\n// // // //         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n// // // //         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n// // // //         const minRadius = sectorRadius * 0.2;\n// // // //         const randomRadius =\n// // // //           minRadius + Math.random() * (sectorRadius - minRadius);\n// // // //         const randomAngle =\n// // // //           sectorAngleStart +\n// // // //           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n// // // //         const x = randomRadius * Math.cos(randomAngle);\n// // // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // // //         if (Math.sqrt(x * x + y * y) <= radius) {\n// // // //           const circle = g\n// // // //             .append(\"circle\")\n// // // //             .attr(\"cx\", x)\n// // // //             .attr(\"cy\", y)\n// // // //             .attr(\"r\", 4)\n// // // //             .attr(\"fill\", \"black\")\n// // // //             .attr(\"stroke\", \"white\")\n// // // //             .attr(\"stroke-width\", 0.5);\n\n// // // //           circle\n// // // //             .append(\"title\")\n// // // //             .text(\n// // // //               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n// // // //             );\n\n// // // //           circle\n// // // //             .on(\"mouseover\", function (event) {\n// // // //               d3.select(this).attr(\"fill\", \"red\");\n// // // //               g.append(\"text\")\n// // // //                 .attr(\"id\", \"tooltip\")\n// // // //                 .attr(\"x\", x + 10)\n// // // //                 .attr(\"y\", y - 10)\n// // // //                 .attr(\"text-anchor\", \"middle\")\n// // // //                 .attr(\"dominant-baseline\", \"middle\")\n// // // //                 .style(\"font-size\", \"12px\")\n// // // //                 .style(\"fill\", \"black\")\n// // // //                 .text(bitPattern);\n// // // //             })\n// // // //             .on(\"mouseout\", function () {\n// // // //               d3.select(this).attr(\"fill\", \"black\");\n// // // //               g.select(\"#tooltip\").remove();\n// // // //             });\n// // // //         } else {\n// // // //           console.warn(\n// // // //             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n// // // //           );\n// // // //         }\n// // // //       });\n// // // //     });\n// // // //   }, [jsonData]);\n\n// // // //   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // //     const subspaces = Object.keys(jsonData);\n// // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // //     const pointsData = subspaces.map((key) => ({\n// // //       key,\n// // //       points: jsonData[key],\n// // //       dimensions: key.length,\n// // //       subspaceId: key,\n// // //     }));\n\n// // //     const svg = d3.select(graphRef.current);\n// // //     const width = 600;\n// // //     const height = 600;\n// // //     const margin = 20;\n\n// // //     svg.selectAll(\"*\").remove();\n// // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // //     const g = svg\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .append(\"g\")\n// // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // //     pointsData.forEach((subspace, index) => {\n// // //       const innerRadius = (index / subspaces.length) * maxRadius;\n// // //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// // //       const sectors = 2 ** (index + 1);\n// // //       const colorScale = d3\n// // //         .scaleOrdinal()\n// // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // //       g.append(\"circle\")\n// // //         .attr(\"r\", outerRadius)\n// // //         .attr(\"stroke\", \"black\")\n// // //         .attr(\"fill\", subspaceColor)\n// // //         .attr(\"fill-opacity\", 0.2)\n// // //         .attr(\"stroke-width\", 2);\n\n// // //       for (let i = 0; i < sectors; i++) {\n// // //         const angle = (2 * Math.PI * i) / sectors;\n// // //         const x1 = outerRadius * Math.cos(angle);\n// // //         const y1 = outerRadius * Math.sin(angle);\n// // //         g.append(\"line\")\n// // //           .attr(\"x1\", 0)\n// // //           .attr(\"y1\", 0)\n// // //           .attr(\"x2\", x1)\n// // //           .attr(\"y2\", y1)\n// // //           .attr(\"stroke\", \"black\")\n// // //           .attr(\"stroke-width\", 1);\n// // //       }\n\n// // //       subspace.points.forEach((point) => {\n// // //         const minRadius = innerRadius;\n// // //         const maxRadius = outerRadius;\n// // //         const randomRadius =\n// // //           minRadius + Math.random() * (maxRadius - minRadius);\n// // //         const randomAngle = Math.random() * 2 * Math.PI;\n// // //         const x = randomRadius * Math.cos(randomAngle);\n// // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // //         g.append(\"circle\")\n// // //           .attr(\"cx\", x)\n// // //           .attr(\"cy\", y)\n// // //           .attr(\"r\", 4)\n// // //           .attr(\"fill\", \"black\")\n// // //           .attr(\"stroke\", \"white\")\n// // //           .attr(\"stroke-width\", 0.5);\n// // //       });\n// // //     });\n// // //   }, [jsonData]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// //     const subspaces = Object.keys(jsonData);\n// //     subspaces.sort((a, b) => a.length - b.length);\n\n// //     const pointsData = subspaces.map((key) => ({\n// //       key,\n// //       points: jsonData[key],\n// //       dimensions: key.length,\n// //       subspaceId: key,\n// //     }));\n\n// //     const svg = d3.select(graphRef.current);\n// //     const width = 600;\n// //     const height = 600;\n// //     const margin = 20;\n\n// //     svg.selectAll(\"*\").remove();\n// //     const maxRadius = Math.min(width, height) / 2 - margin;\n// //     const g = svg\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .append(\"g\")\n// //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// //     pointsData.forEach((subspace, index) => {\n// //       const innerRadius = (index / subspaces.length) * maxRadius;\n// //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// //       const sectors = 2 ** (index + 1);\n// //       const colorScale = d3\n// //         .scaleOrdinal()\n// //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// //       // Draw the outer circle representing the subspace\n// //       g.append(\"circle\")\n// //         .attr(\"r\", outerRadius)\n// //         .attr(\"stroke\", \"black\")\n// //         .attr(\"fill\", subspaceColor)\n// //         .attr(\"fill-opacity\", 0.2)\n// //         .attr(\"stroke-width\", 2);\n\n// //       // Draw the radial lines dividing the sector\n// //       for (let i = 0; i < sectors; i++) {\n// //         const angle = (2 * Math.PI * i) / sectors;\n// //         const x1 = outerRadius * Math.cos(angle);\n// //         const y1 = outerRadius * Math.sin(angle);\n// //         g.append(\"line\")\n// //           .attr(\"x1\", 0)\n// //           .attr(\"y1\", 0)\n// //           .attr(\"x2\", x1)\n// //           .attr(\"y2\", y1)\n// //           .attr(\"stroke\", \"black\")\n// //           .attr(\"stroke-width\", 1);\n// //       }\n\n// //       // Place points inside the subspace\n// //       subspace.points.forEach((point) => {\n// //         // Randomly place points within the subspace's radial range\n// //         const minRadius = innerRadius;\n// //         const maxRadius = outerRadius;\n// //         const randomRadius =\n// //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// //         // Randomly choose an angle within the subspace's sector\n// //         const sectorAngleStart = (2 * Math.PI * index) / subspaces.length;\n// //         const sectorAngleEnd = (2 * Math.PI * (index + 1)) / subspaces.length;\n// //         const randomAngle =\n// //           sectorAngleStart +\n// //           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n// //         const x = randomRadius * Math.cos(randomAngle);\n// //         const y = randomRadius * Math.sin(randomAngle);\n\n// //         // Draw the point inside the subspace\n// //         g.append(\"circle\")\n// //           .attr(\"cx\", x)\n// //           .attr(\"cy\", y)\n// //           .attr(\"r\", 4)\n// //           .attr(\"fill\", \"black\")\n// //           .attr(\"stroke\", \"white\")\n// //           .attr(\"stroke-width\", 0.5);\n// //       });\n// //     });\n// //   }, [jsonData]);\n\n// //   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     // Tooltip container\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     pointsData.forEach((subspace, index) => {\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1); // Number of sectors based on subspace index\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n//       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n//       // Draw the outer circle representing the subspace\n//       g.append(\"circle\")\n//         .attr(\"r\", outerRadius)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2)\n//         .attr(\"stroke-width\", 2)\n//         .style(\"pointer-events\", \"none\"); // Ensure circles do not block hover\n\n//       // Draw the radial lines dividing the sector\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 1)\n//           .style(\"pointer-events\", \"none\"); // Ensure radial lines do not block hover\n//       }\n\n//       // Place points inside the subspace with bit vectors\n//       subspace.points.forEach((point) => {\n//         // Exclude Point_ID from bit vector calculation if present\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n\n//         // Generate bit vector for all coordinates excluding Point_ID\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0)) // 1 if positive, 0 if negative\n//           .join(\"\"); // Combine into a bit vector string\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         // Randomly choose an angle within the subspace's sector\n//         const sectorAngleStart = (2 * Math.PI * index) / subspaces.length;\n//         const sectorAngleEnd = (2 * Math.PI * (index + 1)) / subspaces.length;\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         // Position based on bit vector\n//         let x = randomRadius * Math.cos(randomAngle);\n//         let y = randomRadius * Math.sin(randomAngle);\n\n//         // Adjust x, y coordinates based on bit vector (quadrants)\n//         pointData.forEach(([key, coord], dimIndex) => {\n//           if (bitVector[dimIndex] === \"0\") {\n//             if (dimIndex % 2 === 0)\n//               x = -Math.abs(x); // For even indices (x-axis)\n//             else y = -Math.abs(y); // For odd indices (y-axis)\n//           }\n//         });\n\n//         // Create a circle for each point and make sure they are on top\n//         const pointElement = g\n//           .append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 4)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\") // Make points interactive\n//           .on(\"mouseover\", (event) => {\n//             tooltip.style(\"visibility\", \"visible\").html(`\n//                 <strong>Bit Vector:</strong> ${bitVector}<br>\n//                 <strong>Coordinates:</strong> (${pointData\n//                   .map(([key, coord]) => `${key}: ${coord}`)\n//                   .join(\", \")})\n//               `);\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//           });\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return (\n//     <>\n//       <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>\n//     </>\n//   );\n// };\n\n// export default HierarchicalGraph;","map":{"version":3,"names":[],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // // //     const subspaces = Object.keys(jsonData);\n// // // //     console.log(subspaces.length);\n    \n// // // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // // //     const pointsData = subspaces.map((key) => ({\n// // // //       key,\n// // // //       points: jsonData[key],\n// // // //       dimensions: key.length, \n// // // //       subspaceId: key, \n// // // //     }));\n\n// // // //     const svg = d3.select(graphRef.current);\n// // // //     const width = 1200;\n// // // //     const height = 1200;\n// // // //     const margin = 20;\n\n// // // //     svg.selectAll(\"*\").remove(); \n// // // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // // //     const g = svg\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .append(\"g\")\n// // // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n    \n// // // //     pointsData.forEach((subspace, index) => {\n// // // //       const radius = maxRadius * ((index + 1) / subspaces.length);\n// // // //       const sectors = 2 ** (index +1); \n// // // //       console.log(sectors);\n      \n// // // //       const colorScale = d3\n// // // //         .scaleOrdinal()\n// // // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); \n      \n// // // //       const subspaceColor = colorScale(\n// // // //         subspace.dimensions % colorScale.range().length\n// // // //       );\n      \n// // // //       g.append(\"circle\")\n// // // //         .attr(\"r\", radius)\n// // // //         .attr(\"stroke\", \"black\") \n// // // //         .attr(\"fill\", subspaceColor)\n// // // //         .attr(\"fill-opacity\", 0.2) \n// // // //         .attr(\"stroke-width\", 2); \n      \n// // // //       if (subspace.dimensions > 0) {\n        \n// // // //         for (let i = 0; i < sectors; i++) {\n// // // //           const angle = (2 * Math.PI * i) / sectors;\n// // // //           const x1 = radius * Math.cos(angle);\n// // // //           const y1 = radius * Math.sin(angle);\n// // // //           g.append(\"line\")\n// // // //             .attr(\"x1\", 0)\n// // // //             .attr(\"y1\", 0)\n// // // //             .attr(\"x2\", x1)\n// // // //             .attr(\"y2\", y1)\n// // // //             .attr(\"stroke\", \"black\")\n// // // //             .attr(\"stroke-width\", 1);\n          \n// // // //           const labelX = (radius + 10) * Math.cos(angle); \n// // // //           const labelY = (radius + 10) * Math.sin(angle);\n\n// // // //           g.append(\"text\")\n// // // //             .attr(\"x\", labelX)\n// // // //             .attr(\"y\", labelY + 5) \n// // // //             .attr(\"text-anchor\", \"middle\")\n// // // //             .attr(\"dominant-baseline\", \"middle\")\n// // // //             .style(\"font-size\", \"10px\")\n// // // //             .style(\"fill\", \"black\");\n// // // //         }\n// // // //       }\n\n// // // //       const sectorRadius = radius;\n\n// // // //       subspace.points.forEach((point) => {\n// // // //         const bitPattern = point.Point_ID.toString(2).padStart(\n// // // //           subspace.dimensions,\n// // // //           \"0\"\n// // // //         );\n// // // //         const sectorIndex = parseInt(bitPattern, 2);\n// // // //         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n// // // //         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n// // // //         const minRadius = sectorRadius * 0.2;\n// // // //         const randomRadius =\n// // // //           minRadius + Math.random() * (sectorRadius - minRadius);\n// // // //         const randomAngle =\n// // // //           sectorAngleStart +\n// // // //           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n// // // //         const x = randomRadius * Math.cos(randomAngle);\n// // // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // // //         if (Math.sqrt(x * x + y * y) <= radius) {\n// // // //           const circle = g\n// // // //             .append(\"circle\")\n// // // //             .attr(\"cx\", x)\n// // // //             .attr(\"cy\", y)\n// // // //             .attr(\"r\", 4)\n// // // //             .attr(\"fill\", \"black\")\n// // // //             .attr(\"stroke\", \"white\")\n// // // //             .attr(\"stroke-width\", 0.5)\n// // // //             .append(\"title\")\n// // // //             .text(\n// // // //               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n// // // //             );\n\n          \n// // // //           circle\n// // // //             .on(\"mouseover\", function () {\n// // // //               d3.select(this).attr(\"fill\", \"red\");\n// // // //             })\n// // // //             .on(\"mouseout\", function () {\n// // // //               d3.select(this).attr(\"fill\", \"black\");\n// // // //             });\n// // // //         } else {\n// // // //           console.warn(\n// // // //             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n// // // //           ); \n// // // //         }\n// // // //       });\n// // // //     });\n// // // //   }, [jsonData]);\n\n// // // //   return <svg ref={graphRef} style={{ width: \"1200px\", height: \"1200px\" }}></svg>;\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // // //     const subspaces = Object.keys(jsonData);\n// // // //     console.log(\"Number of subspaces:\", subspaces.length);\n\n// // // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // // //     const pointsData = subspaces.map((key) => ({\n// // // //       key,\n// // // //       points: jsonData[key],\n// // // //       dimensions: key.length,\n// // // //       subspaceId: key,\n// // // //     }));\n\n// // // //     const svg = d3.select(graphRef.current);\n// // // //     const width = 600;\n// // // //     const height = 600;\n// // // //     const margin = 20;\n\n// // // //     svg.selectAll(\"*\").remove();\n// // // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // // //     const g = svg\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .append(\"g\")\n// // // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // // //     pointsData.forEach((subspace, index) => {\n// // // //       const radius = maxRadius * ((index + 1) / subspaces.length);\n// // // //       const sectors = 2 ** (index + 1);\n\n// // // //       const colorScale = d3\n// // // //         .scaleOrdinal()\n// // // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n\n// // // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // // //       g.append(\"circle\")\n// // // //         .attr(\"r\", radius)\n// // // //         .attr(\"stroke\", \"black\")\n// // // //         .attr(\"fill\", subspaceColor)\n// // // //         .attr(\"fill-opacity\", 0.2)\n// // // //         .attr(\"stroke-width\", 2);\n\n// // // //       if (index + 1 > 0) {\n// // // //         for (let i = 0; i < sectors; i++) {\n// // // //           const angle = (2 * Math.PI * i) / sectors;\n// // // //           const x1 = radius * Math.cos(angle);\n// // // //           const y1 = radius * Math.sin(angle);\n// // // //           g.append(\"line\")\n// // // //             .attr(\"x1\", 0)\n// // // //             .attr(\"y1\", 0)\n// // // //             .attr(\"x2\", x1)\n// // // //             .attr(\"y2\", y1)\n// // // //             .attr(\"stroke\", \"black\")\n// // // //             .attr(\"stroke-width\", 1);\n\n// // // //           const labelX = (radius + 10) * Math.cos(angle);\n// // // //           const labelY = (radius + 10) * Math.sin(angle);\n\n// // // //           g.append(\"text\")\n// // // //             .attr(\"x\", labelX)\n// // // //             .attr(\"y\", labelY + 5)\n// // // //             .attr(\"text-anchor\", \"middle\")\n// // // //             .attr(\"dominant-baseline\", \"middle\")\n// // // //             .style(\"font-size\", \"10px\")\n// // // //             .style(\"fill\", \"black\");\n// // // //         }\n// // // //       }\n\n// // // //       const sectorRadius = radius;\n\n// // // //       subspace.points.forEach((point) => {\n// // // //         const bitPattern = point.Point_ID.toString(2).padStart(index + 1, \"0\");\n// // // //         const sectorIndex = parseInt(bitPattern, 2);\n// // // //         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n// // // //         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n// // // //         const minRadius = sectorRadius * 0.2;\n// // // //         const randomRadius =\n// // // //           minRadius + Math.random() * (sectorRadius - minRadius);\n// // // //         const randomAngle =\n// // // //           sectorAngleStart +\n// // // //           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n// // // //         const x = randomRadius * Math.cos(randomAngle);\n// // // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // // //         if (Math.sqrt(x * x + y * y) <= radius) {\n// // // //           const circle = g\n// // // //             .append(\"circle\")\n// // // //             .attr(\"cx\", x)\n// // // //             .attr(\"cy\", y)\n// // // //             .attr(\"r\", 4)\n// // // //             .attr(\"fill\", \"black\")\n// // // //             .attr(\"stroke\", \"white\")\n// // // //             .attr(\"stroke-width\", 0.5);\n\n// // // //           circle\n// // // //             .append(\"title\")\n// // // //             .text(\n// // // //               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n// // // //             );\n\n// // // //           circle\n// // // //             .on(\"mouseover\", function (event) {\n// // // //               d3.select(this).attr(\"fill\", \"red\");\n// // // //               g.append(\"text\")\n// // // //                 .attr(\"id\", \"tooltip\")\n// // // //                 .attr(\"x\", x + 10)\n// // // //                 .attr(\"y\", y - 10)\n// // // //                 .attr(\"text-anchor\", \"middle\")\n// // // //                 .attr(\"dominant-baseline\", \"middle\")\n// // // //                 .style(\"font-size\", \"12px\")\n// // // //                 .style(\"fill\", \"black\")\n// // // //                 .text(bitPattern);\n// // // //             })\n// // // //             .on(\"mouseout\", function () {\n// // // //               d3.select(this).attr(\"fill\", \"black\");\n// // // //               g.select(\"#tooltip\").remove();\n// // // //             });\n// // // //         } else {\n// // // //           console.warn(\n// // // //             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n// // // //           );\n// // // //         }\n// // // //       });\n// // // //     });\n// // // //   }, [jsonData]);\n\n// // // //   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // //     const subspaces = Object.keys(jsonData);\n// // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // //     const pointsData = subspaces.map((key) => ({\n// // //       key,\n// // //       points: jsonData[key],\n// // //       dimensions: key.length,\n// // //       subspaceId: key,\n// // //     }));\n\n// // //     const svg = d3.select(graphRef.current);\n// // //     const width = 600;\n// // //     const height = 600;\n// // //     const margin = 20;\n\n// // //     svg.selectAll(\"*\").remove();\n// // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // //     const g = svg\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .append(\"g\")\n// // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // //     pointsData.forEach((subspace, index) => {\n// // //       const innerRadius = (index / subspaces.length) * maxRadius;\n// // //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// // //       const sectors = 2 ** (index + 1);\n// // //       const colorScale = d3\n// // //         .scaleOrdinal()\n// // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // //       g.append(\"circle\")\n// // //         .attr(\"r\", outerRadius)\n// // //         .attr(\"stroke\", \"black\")\n// // //         .attr(\"fill\", subspaceColor)\n// // //         .attr(\"fill-opacity\", 0.2)\n// // //         .attr(\"stroke-width\", 2);\n\n// // //       for (let i = 0; i < sectors; i++) {\n// // //         const angle = (2 * Math.PI * i) / sectors;\n// // //         const x1 = outerRadius * Math.cos(angle);\n// // //         const y1 = outerRadius * Math.sin(angle);\n// // //         g.append(\"line\")\n// // //           .attr(\"x1\", 0)\n// // //           .attr(\"y1\", 0)\n// // //           .attr(\"x2\", x1)\n// // //           .attr(\"y2\", y1)\n// // //           .attr(\"stroke\", \"black\")\n// // //           .attr(\"stroke-width\", 1);\n// // //       }\n \n        \n// // //       subspace.points.forEach((point) => {\n// // //         const minRadius = innerRadius;\n// // //         const maxRadius = outerRadius;\n// // //         const randomRadius =\n// // //           minRadius + Math.random() * (maxRadius - minRadius);\n// // //         const randomAngle = Math.random() * 2 * Math.PI;\n// // //         const x = randomRadius * Math.cos(randomAngle);\n// // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // //         g.append(\"circle\")\n// // //           .attr(\"cx\", x)\n// // //           .attr(\"cy\", y)\n// // //           .attr(\"r\", 4)\n// // //           .attr(\"fill\", \"black\")\n// // //           .attr(\"stroke\", \"white\")\n// // //           .attr(\"stroke-width\", 0.5);\n// // //       });\n// // //     });\n// // //   }, [jsonData]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// //     const subspaces = Object.keys(jsonData);\n// //     subspaces.sort((a, b) => a.length - b.length);\n\n// //     const pointsData = subspaces.map((key) => ({\n// //       key,\n// //       points: jsonData[key],\n// //       dimensions: key.length,\n// //       subspaceId: key,\n// //     }));\n\n// //     const svg = d3.select(graphRef.current);\n// //     const width = 600;\n// //     const height = 600;\n// //     const margin = 20;\n\n// //     svg.selectAll(\"*\").remove();\n// //     const maxRadius = Math.min(width, height) / 2 - margin;\n// //     const g = svg\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .append(\"g\")\n// //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// //     pointsData.forEach((subspace, index) => {\n// //       const innerRadius = (index / subspaces.length) * maxRadius;\n// //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// //       const sectors = 2 ** (index + 1);\n// //       const colorScale = d3\n// //         .scaleOrdinal()\n// //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// //       // Draw the outer circle representing the subspace\n// //       g.append(\"circle\")\n// //         .attr(\"r\", outerRadius)\n// //         .attr(\"stroke\", \"black\")\n// //         .attr(\"fill\", subspaceColor)\n// //         .attr(\"fill-opacity\", 0.2)\n// //         .attr(\"stroke-width\", 2);\n\n// //       // Draw the radial lines dividing the sector\n// //       for (let i = 0; i < sectors; i++) {\n// //         const angle = (2 * Math.PI * i) / sectors;\n// //         const x1 = outerRadius * Math.cos(angle);\n// //         const y1 = outerRadius * Math.sin(angle);\n// //         g.append(\"line\")\n// //           .attr(\"x1\", 0)\n// //           .attr(\"y1\", 0)\n// //           .attr(\"x2\", x1)\n// //           .attr(\"y2\", y1)\n// //           .attr(\"stroke\", \"black\")\n// //           .attr(\"stroke-width\", 1);\n// //       }\n\n// //       // Place points inside the subspace\n// //       subspace.points.forEach((point) => {\n// //         // Randomly place points within the subspace's radial range\n// //         const minRadius = innerRadius;\n// //         const maxRadius = outerRadius;\n// //         const randomRadius =\n// //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// //         // Randomly choose an angle within the subspace's sector\n// //         const sectorAngleStart = (2 * Math.PI * index) / subspaces.length;\n// //         const sectorAngleEnd = (2 * Math.PI * (index + 1)) / subspaces.length;\n// //         const randomAngle =\n// //           sectorAngleStart +\n// //           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n// //         const x = randomRadius * Math.cos(randomAngle);\n// //         const y = randomRadius * Math.sin(randomAngle);\n\n// //         // Draw the point inside the subspace\n// //         g.append(\"circle\")\n// //           .attr(\"cx\", x)\n// //           .attr(\"cy\", y)\n// //           .attr(\"r\", 4)\n// //           .attr(\"fill\", \"black\")\n// //           .attr(\"stroke\", \"white\")\n// //           .attr(\"stroke-width\", 0.5);\n// //       });\n// //     });\n// //   }, [jsonData]);\n\n// //   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     // Tooltip container\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     pointsData.forEach((subspace, index) => {\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1); // Number of sectors based on subspace index\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n//       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n//       // Draw the outer circle representing the subspace\n//       g.append(\"circle\")\n//         .attr(\"r\", outerRadius)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2)\n//         .attr(\"stroke-width\", 2)\n//         .style(\"pointer-events\", \"none\"); // Ensure circles do not block hover\n\n//       // Draw the radial lines dividing the sector\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 1)\n//           .style(\"pointer-events\", \"none\"); // Ensure radial lines do not block hover\n//       }\n\n//       // Place points inside the subspace with bit vectors\n//       subspace.points.forEach((point) => {\n//         // Exclude Point_ID from bit vector calculation if present\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n\n//         // Generate bit vector for all coordinates excluding Point_ID\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0)) // 1 if positive, 0 if negative\n//           .join(\"\"); // Combine into a bit vector string\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         // Randomly choose an angle within the subspace's sector\n//         const sectorAngleStart = (2 * Math.PI * index) / subspaces.length;\n//         const sectorAngleEnd = (2 * Math.PI * (index + 1)) / subspaces.length;\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         // Position based on bit vector\n//         let x = randomRadius * Math.cos(randomAngle);\n//         let y = randomRadius * Math.sin(randomAngle);\n\n//         // Adjust x, y coordinates based on bit vector (quadrants)\n//         pointData.forEach(([key, coord], dimIndex) => {\n//           if (bitVector[dimIndex] === \"0\") {\n//             if (dimIndex % 2 === 0)\n//               x = -Math.abs(x); // For even indices (x-axis)\n//             else y = -Math.abs(y); // For odd indices (y-axis)\n//           }\n//         });\n\n//         // Create a circle for each point and make sure they are on top\n//         const pointElement = g\n//           .append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 4)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\") // Make points interactive\n//           .on(\"mouseover\", (event) => {\n//             tooltip.style(\"visibility\", \"visible\").html(`\n//                 <strong>Bit Vector:</strong> ${bitVector}<br>\n//                 <strong>Coordinates:</strong> (${pointData\n//                   .map(([key, coord]) => `${key}: ${coord}`)\n//                   .join(\", \")})\n//               `);\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//           });\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return (\n//     <>\n//       <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>\n//     </>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\n"],"mappings":"AAAA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}