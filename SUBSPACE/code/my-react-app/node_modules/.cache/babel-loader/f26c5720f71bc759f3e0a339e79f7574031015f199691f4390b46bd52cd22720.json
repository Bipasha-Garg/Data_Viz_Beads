{"ast":null,"code":"\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n\n//     // Sort subspaces by dimension in *descending* order\n//     subspaces.sort((a, b) => b.length - a.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, // Length of the key determines the dimensions\n//       subspaceId: key, // Store the subspace identifier\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove(); // Clear previous content\n\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     // Start with the *smallest* square and increase size for each subsequent subspace\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize = maxSquareSize * ((index + 1) / subspaces.length);\n//       const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n//       // Define a color scale (you can customize these colors)\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); // Gold, Pink, Light Blue\n\n//       // Determine color based on subspace dimension\n//       const subspaceColor = colorScale(\n//         subspace.dimensions % colorScale.range().length\n//       );\n\n//       // Draw square for the subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"black\") // Make the square outline clearer\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2) // Reduce opacity to see sector lines better\n//         .attr(\"stroke-width\", 2); // Thicker stroke for better visibility\n\n//       // Draw sector lines (dividing the square into equal parts)\n//       if (subspace.dimensions > 0) {\n//         // Only draw lines if there are sectors to divide\n//         for (let i = 0; i < sectors; i++) {\n//           const angle = (2 * Math.PI * i) / sectors;\n//           const x1 = (squareSize / 2) * Math.cos(angle);\n//           const y1 = (squareSize / 2) * Math.sin(angle);\n\n//           // Add sector labels\n//           const labelX = (squareSize / 2 + 10) * Math.cos(angle); // Place label outside the square\n//           const labelY = (squareSize / 2 + 10) * Math.sin(angle);\n\n//           g.append(\"text\")\n//             .attr(\"x\", labelX)\n//             .attr(\"y\", labelY + 5) // Adjust for vertical alignment\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"dominant-baseline\", \"middle\")\n//             .style(\"font-size\", \"10px\")\n//             .style(\"fill\", \"black\");\n//             // .text(\n//             //   subspace.subspaceId +\n//             //     i.toString(2).padStart(subspace.dimensions, \"0\")\n//             // );\n//         }\n//       }\n\n//       // Scale for plotting points, now relative to sector\n//       const sectorRadius = squareSize / 2;\n\n//       // Plot points within their respective square and sector\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(\n//           subspace.dimensions,\n//           \"0\"\n//         );\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n//         // Place points randomly inside the sector, further from the center\n//         const minRadius = sectorRadius * 0.2;\n//         const randomRadius =\n//           minRadius + Math.random() * (sectorRadius - minRadius);\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         // Check if the point lies within this subspace's square.  This is critical\n//         // to prevent points from bleeding into other squares.\n//         if (Math.abs(x) <= squareSize / 2 && Math.abs(y) <= squareSize / 2) {\n//           g.append(\"circle\")\n//             .attr(\"cx\", x)\n//             .attr(\"cy\", y)\n//             .attr(\"r\", 4)\n//             .attr(\"fill\", \"black\")\n//             .attr(\"stroke\", \"white\")\n//             .attr(\"stroke-width\", 0.5)\n//             .append(\"title\");\n//             // .text(\n//             //   `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n//             // );\n//         } else {\n//           console.warn(\n//             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n//           ); // Debugging\n//         }\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return (\n//     <svg\n//       ref={graphRef}\n//       style={{ width: \"600px\", height: \"600px\",  }}\n//     ></svg>\n//   );\n// };\n\n// export default HierarchicalGraph;","map":{"version":3,"names":[],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n\n//     // Sort subspaces by dimension in *descending* order\n//     subspaces.sort((a, b) => b.length - a.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, // Length of the key determines the dimensions\n//       subspaceId: key, // Store the subspace identifier\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove(); // Clear previous content\n\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     // Start with the *smallest* square and increase size for each subsequent subspace\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize = maxSquareSize * ((index + 1) / subspaces.length);\n//       const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n//       // Define a color scale (you can customize these colors)\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); // Gold, Pink, Light Blue\n\n//       // Determine color based on subspace dimension\n//       const subspaceColor = colorScale(\n//         subspace.dimensions % colorScale.range().length\n//       );\n\n//       // Draw square for the subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"black\") // Make the square outline clearer\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2) // Reduce opacity to see sector lines better\n//         .attr(\"stroke-width\", 2); // Thicker stroke for better visibility\n\n//       // Draw sector lines (dividing the square into equal parts)\n//       if (subspace.dimensions > 0) {\n//         // Only draw lines if there are sectors to divide\n//         for (let i = 0; i < sectors; i++) {\n//           const angle = (2 * Math.PI * i) / sectors;\n//           const x1 = (squareSize / 2) * Math.cos(angle);\n//           const y1 = (squareSize / 2) * Math.sin(angle);\n\n\n//           // Add sector labels\n//           const labelX = (squareSize / 2 + 10) * Math.cos(angle); // Place label outside the square\n//           const labelY = (squareSize / 2 + 10) * Math.sin(angle);\n\n//           g.append(\"text\")\n//             .attr(\"x\", labelX)\n//             .attr(\"y\", labelY + 5) // Adjust for vertical alignment\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"dominant-baseline\", \"middle\")\n//             .style(\"font-size\", \"10px\")\n//             .style(\"fill\", \"black\");\n//             // .text(\n//             //   subspace.subspaceId +\n//             //     i.toString(2).padStart(subspace.dimensions, \"0\")\n//             // );\n//         }\n//       }\n\n//       // Scale for plotting points, now relative to sector\n//       const sectorRadius = squareSize / 2;\n\n//       // Plot points within their respective square and sector\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(\n//           subspace.dimensions,\n//           \"0\"\n//         );\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n//         // Place points randomly inside the sector, further from the center\n//         const minRadius = sectorRadius * 0.2;\n//         const randomRadius =\n//           minRadius + Math.random() * (sectorRadius - minRadius);\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         // Check if the point lies within this subspace's square.  This is critical\n//         // to prevent points from bleeding into other squares.\n//         if (Math.abs(x) <= squareSize / 2 && Math.abs(y) <= squareSize / 2) {\n//           g.append(\"circle\")\n//             .attr(\"cx\", x)\n//             .attr(\"cy\", y)\n//             .attr(\"r\", 4)\n//             .attr(\"fill\", \"black\")\n//             .attr(\"stroke\", \"white\")\n//             .attr(\"stroke-width\", 0.5)\n//             .append(\"title\");\n//             // .text(\n//             //   `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n//             // );\n//         } else {\n//           console.warn(\n//             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n//           ); // Debugging\n//         }\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return (\n//     <svg\n//       ref={graphRef}\n//       style={{ width: \"600px\", height: \"600px\",  }}\n//     ></svg>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\n"],"mappings":";AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}