{"ast":null,"code":"import * as d3 from \"d3\";\nconst calculateProportionalAngles = pointsData => {\n  if (pointsData.length === 0) return [];\n  const lastRing = pointsData[pointsData.length - 1];\n  const lastRingPoints = lastRing.points || [];\n  const sectorsCount = Math.max(1, 2 ** lastRing.dimensions);\n  if (lastRingPoints.length === 0 || !Number.isFinite(sectorsCount)) {\n    return pointsData.map((_, i) => Array(Math.max(1, 2 ** (i + 1))).fill(2 * Math.PI / Math.max(1, 2 ** (i + 1))));\n  }\n  const pointCounts = new Array(sectorsCount).fill(0);\n  lastRingPoints.forEach(point => {\n    const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n    const bitVector = pointData.map(([_, coord]) => coord >= 0 ? 1 : 0).join(\"\");\n    const sectorIndex = parseInt(bitVector, 2);\n    if (sectorIndex >= 0 && sectorIndex < sectorsCount) pointCounts[sectorIndex]++;\n  });\n  const minAngle = Math.PI / 180;\n  const totalAngle = 2 * Math.PI;\n  const totalNonEmptyPoints = Math.max(1, pointCounts.reduce((sum, count) => sum + count, 0));\n  const remainingAngle = totalAngle - sectorsCount * minAngle;\n  const sectorAngles = pointCounts.map(count => count > 0 ? minAngle + count / totalNonEmptyPoints * remainingAngle : minAngle);\n  const ringAngles = [sectorAngles];\n  for (let i = pointsData.length - 2; i >= 0; i--) {\n    const prevAngles = ringAngles[0];\n    const sectorCount = Math.max(1, 2 ** (i + 1));\n    const currAngles = new Array(sectorCount).fill(0).map((_, j) => (prevAngles[j * 2] || 0) + (prevAngles[j * 2 + 1] || 0));\n    ringAngles.unshift(currAngles);\n  }\n  return ringAngles;\n};\nexport const renderProportionalView = ({\n  g,\n  subspaces,\n  ringVisibility,\n  maxRadius,\n  ringLabels,\n  pointsData,\n  getSectorColor,\n  renderPoints\n}) => {\n  const ringAngles = calculateProportionalAngles(pointsData);\n  if (!ringAngles || ringAngles.length !== pointsData.length) {\n    console.error(\"Invalid ring angles:\", ringAngles);\n    return;\n  }\n  subspaces.forEach((key, index) => {\n    if (!ringVisibility[key]) return;\n    const innerRadius = index / subspaces.length * maxRadius;\n    const outerRadius = (index + 1) / subspaces.length * maxRadius;\n    let currentAngle = Math.PI / 2;\n    const numSectors = pointsData;\n    ringAngles[index].forEach((angle, i) => {\n      const startAngle = currentAngle;\n      const endAngle = currentAngle + angle;\n      g.append(\"path\").attr(\"d\", d3.arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(startAngle).endAngle(endAngle)).attr(\"fill\", getSectorColor(index, i)).attr(\"fill-opacity\", 0.3).attr(\"stroke\", \"black\").attr(\"stroke-width\", 0.5).style(\"cursor\", \"pointer\");\n      currentAngle = endAngle;\n    });\n    g.append(\"text\").attr(\"x\", 0).attr(\"y\", -outerRadius - 5).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"16px\").attr(\"fill\", \"red\").attr(\"font-weight\", \"bold\").text(ringLabels[index]);\n    renderPoints(index, innerRadius, outerRadius, ringAngles[index]);\n  });\n};","map":{"version":3,"names":["d3","calculateProportionalAngles","pointsData","length","lastRing","lastRingPoints","points","sectorsCount","Math","max","dimensions","Number","isFinite","map","_","i","Array","fill","PI","pointCounts","forEach","point","pointData","Object","entries","filter","key","bitVector","coord","join","sectorIndex","parseInt","minAngle","totalAngle","totalNonEmptyPoints","reduce","sum","count","remainingAngle","sectorAngles","ringAngles","prevAngles","sectorCount","currAngles","j","unshift","renderProportionalView","g","subspaces","ringVisibility","maxRadius","ringLabels","getSectorColor","renderPoints","console","error","index","innerRadius","outerRadius","currentAngle","numSectors","angle","startAngle","endAngle","append","attr","arc","style","text"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/ProportionalView.js"],"sourcesContent":["import * as d3 from \"d3\";\n\nconst calculateProportionalAngles = (pointsData) => {\n    if (pointsData.length === 0) return [];\n\n    const lastRing = pointsData[pointsData.length - 1];\n    const lastRingPoints = lastRing.points || [];\n    const sectorsCount = Math.max(1, 2 ** lastRing.dimensions);\n\n    if (lastRingPoints.length === 0 || !Number.isFinite(sectorsCount)) {\n        return pointsData.map((_, i) =>\n            Array(Math.max(1, 2 ** (i + 1))).fill(2 * Math.PI / Math.max(1, 2 ** (i + 1)))\n        );\n    }\n\n    const pointCounts = new Array(sectorsCount).fill(0);\n    lastRingPoints.forEach((point) => {\n        const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n        const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n        const sectorIndex = parseInt(bitVector, 2);\n        if (sectorIndex >= 0 && sectorIndex < sectorsCount) pointCounts[sectorIndex]++;\n    });\n\n    const minAngle = Math.PI / 180;\n    const totalAngle = 2 * Math.PI;\n    const totalNonEmptyPoints = Math.max(1, pointCounts.reduce((sum, count) => sum + count, 0));\n    const remainingAngle = totalAngle - sectorsCount * minAngle;\n\n    const sectorAngles = pointCounts.map((count) =>\n        count > 0 ? minAngle + (count / totalNonEmptyPoints) * remainingAngle : minAngle\n    );\n\n    const ringAngles = [sectorAngles];\n    for (let i = pointsData.length - 2; i >= 0; i--) {\n        const prevAngles = ringAngles[0];\n        const sectorCount = Math.max(1, 2 ** (i + 1));\n        const currAngles = new Array(sectorCount).fill(0).map((_, j) => (prevAngles[j * 2] || 0) + (prevAngles[j * 2 + 1] || 0));\n        ringAngles.unshift(currAngles);\n    }\n\n    return ringAngles;\n};\n\nexport const renderProportionalView = ({\n    g,\n    subspaces,\n    ringVisibility,\n    maxRadius,\n    ringLabels,\n    pointsData,\n    getSectorColor,\n    renderPoints,\n}) => {\n    const ringAngles = calculateProportionalAngles(pointsData);\n    if (!ringAngles || ringAngles.length !== pointsData.length) {\n        console.error(\"Invalid ring angles:\", ringAngles);\n        return;\n    }\n\n    subspaces.forEach((key, index) => {\n        if (!ringVisibility[key]) return;\n        const innerRadius = (index / subspaces.length) * maxRadius;\n        const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n        let currentAngle = Math.PI / 2;\n        const numSectors = pointsData;\n\n        ringAngles[index].forEach((angle, i) => {\n            const startAngle = currentAngle;\n            const endAngle = currentAngle + angle;\n\n            g.append(\"path\")\n                .attr(\"d\", d3.arc()\n                    .innerRadius(innerRadius)\n                    .outerRadius(outerRadius)\n                    .startAngle(startAngle)\n                    .endAngle(endAngle)\n                )\n                .attr(\"fill\", getSectorColor(index, i))\n                .attr(\"fill-opacity\", 0.3)\n                .attr(\"stroke\", \"black\")\n                .attr(\"stroke-width\", 0.5)\n                .style(\"cursor\", \"pointer\");\n\n            currentAngle = endAngle;\n        });\n\n        g.append(\"text\")\n            .attr(\"x\", 0)\n            .attr(\"y\", -outerRadius - 5)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"font-size\", \"16px\")\n            .attr(\"fill\", \"red\")\n            .attr(\"font-weight\", \"bold\")\n            .text(ringLabels[index]);\n\n        renderPoints(index, innerRadius, outerRadius, ringAngles[index]);\n    });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}