{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates, ringVisibility }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (\n//       !jsonData ||\n//       typeof jsonData !== \"object\" ||\n//       Object.keys(jsonData).length === 0\n//     ) {\n//       console.error(\"Invalid or empty jsonData:\", jsonData);\n//       return;\n//     }\n\n//     if (!labelsData || typeof labelsData !== \"object\") {\n//       console.error(\"Invalid labelsData:\", labelsData);\n//       return;\n//     }\n\n//     const svg = d3.select(graphRef.current);\n//     svg.selectAll(\"*\").remove();\n\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     const edgePopup = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"edge-popup\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(255, 255, 255, 0.9)\")\n//       .style(\"color\", \"black\")\n//       .style(\"padding\", \"10px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\")\n//       .style(\"box-shadow\", \"0 2px 4px rgba(0,0,0,0.2)\")\n//       .style(\"max-width\", \"300px\");\n\n//     const getLabelColor = (pointId) => {\n//       if (!labelsData || !labelsData.labels) return \"gray\";\n//       for (const label of Object.keys(labelsData.labels)) {\n//         const pointList = labelsData.labels[label];\n//         if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n//           return colorScale(label);\n//         }\n//       }\n//       return \"gray\";\n//     };\n\n//     const colorScale = d3\n//       .scaleOrdinal(d3.schemeCategory10)\n//       .domain(Object.keys(labelsData.labels || {}));\n\n//     const getSectorColor = (index, sectorIndex) => {\n//       return d3.hsl(sectorIndex % 2 === 0 ? 0 : 220, 0.9, 0.6);\n//     };\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n//     const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i)); \n\n//     const pointPositions = {};\n//     let highlightedElements = null;\n\n//     // Function to clear highlights\n//     const clearHighlights = () => {\n//       if (highlightedElements) {\n//         highlightedElements.line.attr(\"stroke-width\", 0.3).attr(\"stroke\", highlightedElements.originalColor);\n//         highlightedElements.circles.forEach(circle =>\n//           circle.attr(\"r\", 3).attr(\"fill\", \"black\")\n//         );\n//         highlightedElements = null;\n//       }\n//     };\n\n//     subspaces.forEach((key, index) => {\n//       if (!ringVisibility[key]) return;\n\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1);\n//       const rotationOffset = Math.PI / 2;\n\n//       for (let i = 0; i < sectors; i++) {\n//         const startAngle = (2 * Math.PI * i) / sectors + rotationOffset;\n//         const endAngle = (2 * Math.PI * (i + 1)) / sectors + rotationOffset;\n\n//         g.append(\"path\")\n//           .attr(\"d\", d3.arc()\n//             .innerRadius(innerRadius)\n//             .outerRadius(outerRadius)\n//             .startAngle(startAngle)\n//             .endAngle(endAngle)\n//           )\n//           .attr(\"fill\", getSectorColor(index, i))\n//           .attr(\"fill-opacity\", 0.3)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.1)\n//           .style(\"cursor\", \"pointer\");\n\n//         g.append(\"text\")\n//           .attr(\"x\", 0)\n//           .attr(\"y\", -outerRadius - 5)\n//           .attr(\"text-anchor\", \"middle\")\n//           .attr(\"font-size\", \"16px\")\n//           .attr(\"fill\", \"red\")\n//           .attr(\"font-weight\", \"bold\")\n//         // .text(key);\n//           .text(ringLabels[index]); // Use generated lab\n//       }\n\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         const x2 = innerRadius * Math.cos(angle);\n//         const y2 = innerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", x2)\n//           .attr(\"y1\", y2)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.25)\n//           .style(\"pointer-events\", \"none\");\n//       }\n\n//       pointsData[index].points.forEach((point, i) => {\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n//           .join(\"\");\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         const bitVectorIndex = parseInt(bitVector, 2);\n//         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n//         const centerAngle = (angleStart + angleEnd) / 2;\n\n//         const totalPoints = pointsData[index].points.length;\n//         const clusterFactor = 0.86;\n//         const overlapRadius =\n//           innerRadius +\n//           (clusterFactor * (outerRadius - innerRadius) * (i % totalPoints)) /\n//           totalPoints;\n\n//         const x = overlapRadius * Math.cos(centerAngle);\n//         const y = overlapRadius * Math.sin(centerAngle);\n//         point.Point_ID.forEach((id) => {\n//           if (!pointPositions[id]) {\n//             pointPositions[id] = [];\n//           }\n//           pointPositions[id].push({ x, y, point, subspaceId: key });\n//         });\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             const pointIds = point.Point_ID.join(\", \");\n//             let associatedLabels = [];\n//             if (labelsData && labelsData.labels) {\n//               Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n//                 if (point.Point_ID.some(id => pointList.includes(Number(id)))) {\n//                   associatedLabels.push(label);\n//                 }\n//               });\n//             }\n//             const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(\n//                 `Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})<br>Subspace: ${key}<br>Label: ${labelText}`\n//               );\n//             setHoveredCoordinates({ ...point, label: labelText });\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//             setHoveredCoordinates(null);\n//           });\n//       });\n//     });\n\n//     Object.entries(pointPositions).forEach(([pointId, positions]) => {\n//       if (positions.length > 1) {\n//         for (let i = 0; i < positions.length - 1; i++) {\n//           const line = g.append(\"line\")\n//             .attr(\"x1\", positions[i].x)\n//             .attr(\"y1\", positions[i].y)\n//             .attr(\"x2\", positions[i + 1].x)\n//             .attr(\"y2\", positions[i + 1].y)\n//             .attr(\"stroke\", getLabelColor(pointId))\n//             .attr(\"stroke-width\", 0.3)\n//             .style(\"cursor\", \"pointer\")\n//             .on(\"mouseover\", (event) => {\n//               tooltip\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`Connection: Point_ID ${pointId}`);\n//             })\n//             .on(\"mousemove\", (event) => {\n//               tooltip\n//                 .style(\"top\", event.pageY + 10 + \"px\")\n//                 .style(\"left\", event.pageX + 10 + \"px\");\n//             })\n//             .on(\"mouseout\", () => {\n//               tooltip.style(\"visibility\", \"hidden\");\n//             })\n//             .on(\"click\", (event) => {\n//               // Clear previous highlights\n//               clearHighlights();\n\n//               // Highlight the clicked edge\n//               const originalColor = getLabelColor(pointId);\n//               line.attr(\"stroke-width\", 2).attr(\"stroke\", \"yellow\");\n\n//               // Highlight connected points\n//               const circles = g.selectAll(\"circle\")\n//                 .filter(d => {\n//                   const circleX = parseFloat(this.getAttribute(\"cx\"));\n//                   const circleY = parseFloat(this.getAttribute(\"cy\"));\n//                   return (\n//                     (Math.abs(circleX - positions[i].x) < 0.1 && Math.abs(circleY - positions[i].y) < 0.1) ||\n//                     (Math.abs(circleX - positions[i + 1].x) < 0.1 && Math.abs(circleY - positions[i + 1].y) < 0.1)\n//                 )})\n//                 .attr(\"r\", 6)\n//                 .attr(\"fill\", \"yellow\");\n\n//               highlightedElements = { line, circles, originalColor };\n\n//               // Show popup\n//               const point1 = positions[i].point;\n//               const point2 = positions[i + 1].point;\n\n//               const coords1 = Object.entries(point1)\n//                 .filter(([key]) => key !== \"Point_ID\")\n//                 .map(([key, value]) => `${key}: ${value}`)\n//                 .join(\", \");\n//               const coords2 = Object.entries(point2)\n//                 .filter(([key]) => key !== \"Point_ID\")\n//                 .map(([key, value]) => `${key}: ${value}`)\n//                 .join(\", \");\n\n//               const label1 = Object.entries(labelsData?.labels || {})\n//                 .find(([_, ids]) => ids.includes(Number(pointId)))?.[0] || \"No Label\";\n\n//               edgePopup\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`\n//                   <strong>Connected Points (ID: ${pointId})</strong><br><br>\n//                   <strong>Point 1</strong><br>\n//                   Subspace: ${positions[i].subspaceId}<br>\n//                   Coordinates: ${coords1}<br>\n//                   Label: ${label1}<br><br>\n//                   <strong>Point 2</strong><br>\n//                   Subspace: ${positions[i + 1].subspaceId}<br>\n//                   Coordinates: ${coords2}<br>\n//                   Label: ${label1}\n//                 `)\n//                 .style(\"top\", event.pageY + 15 + \"px\")\n//                 .style(\"left\", event.pageX + 15 + \"px\");\n\n//               d3.select(\"body\").on(\"click.edgePopup\", (e) => {\n//                 if (!edgePopup.node().contains(e.target)) {\n//                   edgePopup.style(\"visibility\", \"hidden\");\n//                   clearHighlights();\n//                   d3.select(\"body\").on(\"click.edgePopup\", null);\n//                 }\n//               });\n//             });\n//         }\n//       }\n//     });\n\n//     const zoom = d3.zoom().on(\"zoom\", (event) => {\n//       g.attr(\"transform\", event.transform);\n//     });\n//     svg.call(zoom);\n//     return () => {\n//       tooltip.remove();\n//       edgePopup.remove();\n//       svg.select(\".zoom-view\").remove();\n//     };\n\n//   }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates]);\n\n//   return (\n//     <div style={{ width: \"100%\", height: \"100%\" }}>\n//       <svg ref={graphRef} style={{ width: \"100%\", height: \"800px\" }}></svg>\n//     </div>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  labelsData,\n  setHoveredCoordinates,\n  ringVisibility\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  const [isProportionalView, setIsProportionalView] = useState(false);\n  const [applyToAllRings, setApplyToAllRings] = useState(false);\n  useEffect(() => {\n    if (!jsonData || !labelsData) return;\n    const svg = d3.select(graphRef.current);\n    svg.selectAll(\"*\").remove();\n    const width = 800;\n    const height = 800;\n    const margin = 20;\n    const maxRadius = Math.min(width, height) / 2 - margin;\n\n    // Improved tooltip styling\n    const tooltip = d3.select(\"body\").append(\"div\").attr(\"class\", \"tooltip\").style(\"position\", \"absolute\").style(\"visibility\", \"hidden\").style(\"background-color\", \"rgba(0, 0, 0, 0.8)\").style(\"color\", \"white\").style(\"padding\", \"8px\").style(\"border-radius\", \"4px\");\n    const edgePopup = d3.select(\"body\").append(\"div\").attr(\"class\", \"edge-popup\").style(\"position\", \"absolute\").style(\"visibility\", \"hidden\").style(\"background-color\", \"rgba(255, 255, 255, 0.95)\").style(\"padding\", \"12px\").style(\"border-radius\", \"4px\").style(\"box-shadow\", \"0 2px 6px rgba(0,0,0,0.2)\");\n\n    // Improved color handling\n    const colorScale = d3.scaleOrdinal().domain(Object.keys(labelsData.labels || {})).range(d3.schemeCategory10);\n    const getLabelColor = pointId => {\n      if (!(labelsData !== null && labelsData !== void 0 && labelsData.labels)) return \"#666\";\n      for (const [label, points] of Object.entries(labelsData.labels)) {\n        if (points.includes(Number(pointId))) {\n          return colorScale(label);\n        }\n      }\n      return \"#666\";\n    };\n    const getSectorColor = index => {\n      return d3.hsl(index * 137.5 % 360, 0.7, 0.7); // Golden angle for better color distribution\n    };\n    const subspaces = Object.keys(jsonData).sort((a, b) => a.length - b.length);\n    const pointsData = subspaces.map(key => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length,\n      subspaceId: key\n    }));\n    const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i));\n    const pointPositions = {};\n    const drawGraph = () => {\n      svg.selectAll(\"*\").remove();\n      const g = svg.attr(\"width\", width).attr(\"height\", height).append(\"g\").attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n      subspaces.forEach((key, index) => {\n        if (!ringVisibility[key]) return;\n        const innerRadius = index / subspaces.length * maxRadius;\n        const outerRadius = (index + 1) / subspaces.length * maxRadius;\n        const sectors = 2 ** key.length; // Corrected sector calculation based on subspace dimensions\n\n        const pointsBySector = {};\n        pointsData[index].points.forEach(point => {\n          const pointData = Object.entries(point).filter(([k]) => k !== \"Point_ID\");\n          const bitVector = pointData.map(([_, coord]) => coord >= 0 ? \"1\" : \"0\").join(\"\");\n          pointsBySector[bitVector] = (pointsBySector[bitVector] || 0) + 1;\n        });\n        const totalPoints = pointsData[index].points.length;\n        const sectorCount = Object.keys(pointsBySector).length;\n        const baseAngle = 2 * Math.PI / sectors;\n        const sectorAngles = new Array(sectors).fill(baseAngle);\n        if (isProportionalView && (applyToAllRings || index === subspaces.length - 1)) {\n          const totalAngle = 2 * Math.PI;\n          const minAngle = totalAngle * 0.05; // Minimum angle for empty sectors\n          const remainingAngle = totalAngle - sectors * minAngle;\n          Object.entries(pointsBySector).forEach(([bitVector, count]) => {\n            const sectorIndex = parseInt(bitVector, 2);\n            sectorAngles[sectorIndex] = minAngle + remainingAngle * count / totalPoints;\n          });\n        }\n        let currentAngle = 0;\n        const sectorInfo = [];\n\n        // Draw sectors\n        for (let i = 0; i < sectors; i++) {\n          const startAngle = currentAngle;\n          const endAngle = currentAngle + sectorAngles[i];\n          sectorInfo.push({\n            startAngle,\n            endAngle,\n            index: i,\n            bitVector: i.toString(2).padStart(key.length, \"0\")\n          });\n          g.append(\"path\").attr(\"d\", d3.arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(startAngle).endAngle(endAngle)).attr(\"fill\", getSectorColor(i)).attr(\"fill-opacity\", 0.4).attr(\"stroke\", \"#333\").attr(\"stroke-width\", 0.5);\n          currentAngle = endAngle;\n\n          // Ring label\n          if (i === 0) {\n            g.append(\"text\").attr(\"x\", 0).attr(\"y\", -outerRadius - 5).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"16px\").attr(\"fill\", \"red\").text(ringLabels[index]);\n          }\n        }\n\n        // Place points in center of sectors\n        pointsData[index].points.forEach(point => {\n          const pointData = Object.entries(point).filter(([k]) => k !== \"Point_ID\");\n          const bitVector = pointData.map(([_, coord]) => coord >= 0 ? \"1\" : \"0\").join(\"\");\n          const sectorIndex = parseInt(bitVector, 2);\n          const sector = sectorInfo[sectorIndex];\n          const radius = (innerRadius + outerRadius) / 2; // Center of the ring\n          const angle = (sector.startAngle + sector.endAngle) / 2; // Center of the sector\n\n          const x = radius * Math.cos(angle);\n          const y = radius * Math.sin(angle);\n          point.Point_ID.forEach(id => {\n            pointPositions[id] = pointPositions[id] || [];\n            pointPositions[id].push({\n              x,\n              y,\n              point,\n              subspaceId: key\n            });\n          });\n          g.append(\"circle\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", 3).attr(\"fill\", getLabelColor(point.Point_ID[0])).attr(\"stroke\", \"white\").attr(\"stroke-width\", 0.5).on(\"mouseover\", event => {\n            const pointIds = point.Point_ID.join(\", \");\n            const labels = Object.entries(labelsData.labels || {}).filter(([_, points]) => point.Point_ID.some(id => points.includes(Number(id)))).map(([label]) => label).join(\", \") || \"No Label\";\n            tooltip.style(\"visibility\", \"visible\").html(`Point_IDs: ${pointIds}<br>Subspace: ${key}<br>Label: ${labels}`);\n            setHoveredCoordinates({\n              ...point,\n              label: labels\n            });\n          }).on(\"mousemove\", event => {\n            tooltip.style(\"top\", `${event.pageY + 10}px`).style(\"left\", `${event.pageX + 10}px`);\n          }).on(\"mouseout\", () => {\n            tooltip.style(\"visibility\", \"hidden\");\n            setHoveredCoordinates(null);\n          });\n        });\n      });\n\n      // Draw connections\n      Object.entries(pointPositions).forEach(([pointId, positions]) => {\n        if (positions.length > 1) {\n          for (let i = 0; i < positions.length - 1; i++) {\n            g.append(\"line\").attr(\"x1\", positions[i].x).attr(\"y1\", positions[i].y).attr(\"x2\", positions[i + 1].x).attr(\"y2\", positions[i + 1].y).attr(\"stroke\", getLabelColor(pointId)).attr(\"stroke-width\", 1).style(\"opacity\", 0.7);\n          }\n        }\n      });\n      svg.call(d3.zoom().on(\"zoom\", event => {\n        g.attr(\"transform\", event.transform);\n      }));\n    };\n    drawGraph();\n    return () => {\n      tooltip.remove();\n      edgePopup.remove();\n    };\n  }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates, isProportionalView, applyToAllRings]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginBottom: \"10px\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setIsProportionalView(!isProportionalView),\n        style: {\n          padding: \"5px 10px\",\n          marginRight: \"10px\",\n          backgroundColor: isProportionalView ? \"#4CAF50\" : \"#f0f0f0\",\n          color: isProportionalView ? \"white\" : \"black\",\n          border: \"1px solid #ccc\",\n          borderRadius: \"4px\",\n          cursor: \"pointer\"\n        },\n        children: isProportionalView ? \"Normal View\" : \"Proportional View\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 573,\n        columnNumber: 9\n      }, this), isProportionalView && /*#__PURE__*/_jsxDEV(\"label\", {\n        style: {\n          marginLeft: \"10px\"\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"checkbox\",\n          checked: applyToAllRings,\n          onChange: e => setApplyToAllRings(e.target.checked)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 589,\n          columnNumber: 13\n        }, this), \"Apply to all rings\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 588,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 572,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: graphRef,\n      style: {\n        width: \"100%\",\n        height: \"800px\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 598,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 571,\n    columnNumber: 5\n  }, this);\n};\n_s(HierarchicalGraph, \"+9iTWDC2o4a4XKe++z4fFE0OpKI=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","useState","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","labelsData","setHoveredCoordinates","ringVisibility","_s","graphRef","isProportionalView","setIsProportionalView","applyToAllRings","setApplyToAllRings","svg","select","current","selectAll","remove","width","height","margin","maxRadius","Math","min","tooltip","append","attr","style","edgePopup","colorScale","scaleOrdinal","domain","Object","keys","labels","range","schemeCategory10","getLabelColor","pointId","label","points","entries","includes","Number","getSectorColor","index","hsl","subspaces","sort","a","b","length","pointsData","map","key","dimensions","subspaceId","ringLabels","_","i","String","fromCharCode","pointPositions","drawGraph","g","forEach","innerRadius","outerRadius","sectors","pointsBySector","point","pointData","filter","k","bitVector","coord","join","totalPoints","sectorCount","baseAngle","PI","sectorAngles","Array","fill","totalAngle","minAngle","remainingAngle","count","sectorIndex","parseInt","currentAngle","sectorInfo","startAngle","endAngle","push","toString","padStart","arc","text","sector","radius","angle","x","cos","y","sin","Point_ID","id","on","event","pointIds","some","html","pageY","pageX","positions","call","zoom","transform","children","marginBottom","onClick","padding","marginRight","backgroundColor","color","border","borderRadius","cursor","fileName","_jsxFileName","lineNumber","columnNumber","marginLeft","type","checked","onChange","e","target","ref","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates, ringVisibility }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (\n//       !jsonData ||\n//       typeof jsonData !== \"object\" ||\n//       Object.keys(jsonData).length === 0\n//     ) {\n//       console.error(\"Invalid or empty jsonData:\", jsonData);\n//       return;\n//     }\n\n//     if (!labelsData || typeof labelsData !== \"object\") {\n//       console.error(\"Invalid labelsData:\", labelsData);\n//       return;\n//     }\n\n//     const svg = d3.select(graphRef.current);\n//     svg.selectAll(\"*\").remove();\n\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     const edgePopup = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"edge-popup\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(255, 255, 255, 0.9)\")\n//       .style(\"color\", \"black\")\n//       .style(\"padding\", \"10px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\")\n//       .style(\"box-shadow\", \"0 2px 4px rgba(0,0,0,0.2)\")\n//       .style(\"max-width\", \"300px\");\n\n//     const getLabelColor = (pointId) => {\n//       if (!labelsData || !labelsData.labels) return \"gray\";\n//       for (const label of Object.keys(labelsData.labels)) {\n//         const pointList = labelsData.labels[label];\n//         if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n//           return colorScale(label);\n//         }\n//       }\n//       return \"gray\";\n//     };\n\n//     const colorScale = d3\n//       .scaleOrdinal(d3.schemeCategory10)\n//       .domain(Object.keys(labelsData.labels || {}));\n\n//     const getSectorColor = (index, sectorIndex) => {\n//       return d3.hsl(sectorIndex % 2 === 0 ? 0 : 220, 0.9, 0.6);\n//     };\n\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n//     const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i)); \n\n//     const pointPositions = {};\n//     let highlightedElements = null;\n\n//     // Function to clear highlights\n//     const clearHighlights = () => {\n//       if (highlightedElements) {\n//         highlightedElements.line.attr(\"stroke-width\", 0.3).attr(\"stroke\", highlightedElements.originalColor);\n//         highlightedElements.circles.forEach(circle =>\n//           circle.attr(\"r\", 3).attr(\"fill\", \"black\")\n//         );\n//         highlightedElements = null;\n//       }\n//     };\n\n//     subspaces.forEach((key, index) => {\n//       if (!ringVisibility[key]) return;\n\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1);\n//       const rotationOffset = Math.PI / 2;\n\n//       for (let i = 0; i < sectors; i++) {\n//         const startAngle = (2 * Math.PI * i) / sectors + rotationOffset;\n//         const endAngle = (2 * Math.PI * (i + 1)) / sectors + rotationOffset;\n\n//         g.append(\"path\")\n//           .attr(\"d\", d3.arc()\n//             .innerRadius(innerRadius)\n//             .outerRadius(outerRadius)\n//             .startAngle(startAngle)\n//             .endAngle(endAngle)\n//           )\n//           .attr(\"fill\", getSectorColor(index, i))\n//           .attr(\"fill-opacity\", 0.3)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.1)\n//           .style(\"cursor\", \"pointer\");\n\n//         g.append(\"text\")\n//           .attr(\"x\", 0)\n//           .attr(\"y\", -outerRadius - 5)\n//           .attr(\"text-anchor\", \"middle\")\n//           .attr(\"font-size\", \"16px\")\n//           .attr(\"fill\", \"red\")\n//           .attr(\"font-weight\", \"bold\")\n//         // .text(key);\n//           .text(ringLabels[index]); // Use generated lab\n//       }\n\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         const x2 = innerRadius * Math.cos(angle);\n//         const y2 = innerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", x2)\n//           .attr(\"y1\", y2)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.25)\n//           .style(\"pointer-events\", \"none\");\n//       }\n\n//       pointsData[index].points.forEach((point, i) => {\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n//           .join(\"\");\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         const bitVectorIndex = parseInt(bitVector, 2);\n//         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n//         const centerAngle = (angleStart + angleEnd) / 2;\n\n//         const totalPoints = pointsData[index].points.length;\n//         const clusterFactor = 0.86;\n//         const overlapRadius =\n//           innerRadius +\n//           (clusterFactor * (outerRadius - innerRadius) * (i % totalPoints)) /\n//           totalPoints;\n\n//         const x = overlapRadius * Math.cos(centerAngle);\n//         const y = overlapRadius * Math.sin(centerAngle);\n//         point.Point_ID.forEach((id) => {\n//           if (!pointPositions[id]) {\n//             pointPositions[id] = [];\n//           }\n//           pointPositions[id].push({ x, y, point, subspaceId: key });\n//         });\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             const pointIds = point.Point_ID.join(\", \");\n//             let associatedLabels = [];\n//             if (labelsData && labelsData.labels) {\n//               Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n//                 if (point.Point_ID.some(id => pointList.includes(Number(id)))) {\n//                   associatedLabels.push(label);\n//                 }\n//               });\n//             }\n//             const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(\n//                 `Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})<br>Subspace: ${key}<br>Label: ${labelText}`\n//               );\n//             setHoveredCoordinates({ ...point, label: labelText });\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//             setHoveredCoordinates(null);\n//           });\n//       });\n//     });\n\n//     Object.entries(pointPositions).forEach(([pointId, positions]) => {\n//       if (positions.length > 1) {\n//         for (let i = 0; i < positions.length - 1; i++) {\n//           const line = g.append(\"line\")\n//             .attr(\"x1\", positions[i].x)\n//             .attr(\"y1\", positions[i].y)\n//             .attr(\"x2\", positions[i + 1].x)\n//             .attr(\"y2\", positions[i + 1].y)\n//             .attr(\"stroke\", getLabelColor(pointId))\n//             .attr(\"stroke-width\", 0.3)\n//             .style(\"cursor\", \"pointer\")\n//             .on(\"mouseover\", (event) => {\n//               tooltip\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`Connection: Point_ID ${pointId}`);\n//             })\n//             .on(\"mousemove\", (event) => {\n//               tooltip\n//                 .style(\"top\", event.pageY + 10 + \"px\")\n//                 .style(\"left\", event.pageX + 10 + \"px\");\n//             })\n//             .on(\"mouseout\", () => {\n//               tooltip.style(\"visibility\", \"hidden\");\n//             })\n//             .on(\"click\", (event) => {\n//               // Clear previous highlights\n//               clearHighlights();\n\n//               // Highlight the clicked edge\n//               const originalColor = getLabelColor(pointId);\n//               line.attr(\"stroke-width\", 2).attr(\"stroke\", \"yellow\");\n\n//               // Highlight connected points\n//               const circles = g.selectAll(\"circle\")\n//                 .filter(d => {\n//                   const circleX = parseFloat(this.getAttribute(\"cx\"));\n//                   const circleY = parseFloat(this.getAttribute(\"cy\"));\n//                   return (\n//                     (Math.abs(circleX - positions[i].x) < 0.1 && Math.abs(circleY - positions[i].y) < 0.1) ||\n//                     (Math.abs(circleX - positions[i + 1].x) < 0.1 && Math.abs(circleY - positions[i + 1].y) < 0.1)\n//                 )})\n//                 .attr(\"r\", 6)\n//                 .attr(\"fill\", \"yellow\");\n\n//               highlightedElements = { line, circles, originalColor };\n\n//               // Show popup\n//               const point1 = positions[i].point;\n//               const point2 = positions[i + 1].point;\n\n//               const coords1 = Object.entries(point1)\n//                 .filter(([key]) => key !== \"Point_ID\")\n//                 .map(([key, value]) => `${key}: ${value}`)\n//                 .join(\", \");\n//               const coords2 = Object.entries(point2)\n//                 .filter(([key]) => key !== \"Point_ID\")\n//                 .map(([key, value]) => `${key}: ${value}`)\n//                 .join(\", \");\n\n//               const label1 = Object.entries(labelsData?.labels || {})\n//                 .find(([_, ids]) => ids.includes(Number(pointId)))?.[0] || \"No Label\";\n\n//               edgePopup\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`\n//                   <strong>Connected Points (ID: ${pointId})</strong><br><br>\n//                   <strong>Point 1</strong><br>\n//                   Subspace: ${positions[i].subspaceId}<br>\n//                   Coordinates: ${coords1}<br>\n//                   Label: ${label1}<br><br>\n//                   <strong>Point 2</strong><br>\n//                   Subspace: ${positions[i + 1].subspaceId}<br>\n//                   Coordinates: ${coords2}<br>\n//                   Label: ${label1}\n//                 `)\n//                 .style(\"top\", event.pageY + 15 + \"px\")\n//                 .style(\"left\", event.pageX + 15 + \"px\");\n\n//               d3.select(\"body\").on(\"click.edgePopup\", (e) => {\n//                 if (!edgePopup.node().contains(e.target)) {\n//                   edgePopup.style(\"visibility\", \"hidden\");\n//                   clearHighlights();\n//                   d3.select(\"body\").on(\"click.edgePopup\", null);\n//                 }\n//               });\n//             });\n//         }\n//       }\n//     });\n\n//     const zoom = d3.zoom().on(\"zoom\", (event) => {\n//       g.attr(\"transform\", event.transform);\n//     });\n//     svg.call(zoom);\n//     return () => {\n//       tooltip.remove();\n//       edgePopup.remove();\n//       svg.select(\".zoom-view\").remove();\n//     };\n\n    \n//   }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates]);\n\n//   return (\n//     <div style={{ width: \"100%\", height: \"100%\" }}>\n//       <svg ref={graphRef} style={{ width: \"100%\", height: \"800px\" }}></svg>\n//     </div>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates, ringVisibility }) => {\n  const graphRef = useRef(null);\n  const [isProportionalView, setIsProportionalView] = useState(false);\n  const [applyToAllRings, setApplyToAllRings] = useState(false);\n\n  useEffect(() => {\n    if (!jsonData || !labelsData) return;\n\n    const svg = d3.select(graphRef.current);\n    svg.selectAll(\"*\").remove();\n\n    const width = 800;\n    const height = 800;\n    const margin = 20;\n    const maxRadius = Math.min(width, height) / 2 - margin;\n\n    // Improved tooltip styling\n    const tooltip = d3.select(\"body\")\n      .append(\"div\")\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"visibility\", \"hidden\")\n      .style(\"background-color\", \"rgba(0, 0, 0, 0.8)\")\n      .style(\"color\", \"white\")\n      .style(\"padding\", \"8px\")\n      .style(\"border-radius\", \"4px\");\n\n    const edgePopup = d3.select(\"body\")\n      .append(\"div\")\n      .attr(\"class\", \"edge-popup\")\n      .style(\"position\", \"absolute\")\n      .style(\"visibility\", \"hidden\")\n      .style(\"background-color\", \"rgba(255, 255, 255, 0.95)\")\n      .style(\"padding\", \"12px\")\n      .style(\"border-radius\", \"4px\")\n      .style(\"box-shadow\", \"0 2px 6px rgba(0,0,0,0.2)\");\n\n    // Improved color handling\n    const colorScale = d3.scaleOrdinal()\n      .domain(Object.keys(labelsData.labels || {}))\n      .range(d3.schemeCategory10);\n\n    const getLabelColor = (pointId) => {\n      if (!labelsData?.labels) return \"#666\";\n      for (const [label, points] of Object.entries(labelsData.labels)) {\n        if (points.includes(Number(pointId))) {\n          return colorScale(label);\n        }\n      }\n      return \"#666\";\n    };\n\n    const getSectorColor = (index) => {\n      return d3.hsl((index * 137.5) % 360, 0.7, 0.7); // Golden angle for better color distribution\n    };\n\n    const subspaces = Object.keys(jsonData).sort((a, b) => a.length - b.length);\n    const pointsData = subspaces.map(key => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length,\n      subspaceId: key,\n    }));\n    const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i));\n    const pointPositions = {};\n\n    const drawGraph = () => {\n      svg.selectAll(\"*\").remove();\n      const g = svg\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .append(\"g\")\n        .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n      subspaces.forEach((key, index) => {\n        if (!ringVisibility[key]) return;\n\n        const innerRadius = (index / subspaces.length) * maxRadius;\n        const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n        const sectors = 2 ** key.length; // Corrected sector calculation based on subspace dimensions\n\n        const pointsBySector = {};\n        pointsData[index].points.forEach(point => {\n          const pointData = Object.entries(point).filter(([k]) => k !== \"Point_ID\");\n          const bitVector = pointData.map(([_, coord]) => coord >= 0 ? \"1\" : \"0\").join(\"\");\n          pointsBySector[bitVector] = (pointsBySector[bitVector] || 0) + 1;\n        });\n\n        const totalPoints = pointsData[index].points.length;\n        const sectorCount = Object.keys(pointsBySector).length;\n        const baseAngle = 2 * Math.PI / sectors;\n\n        const sectorAngles = new Array(sectors).fill(baseAngle);\n        if (isProportionalView && (applyToAllRings || index === subspaces.length - 1)) {\n          const totalAngle = 2 * Math.PI;\n          const minAngle = totalAngle * 0.05; // Minimum angle for empty sectors\n          const remainingAngle = totalAngle - (sectors * minAngle);\n\n          Object.entries(pointsBySector).forEach(([bitVector, count]) => {\n            const sectorIndex = parseInt(bitVector, 2);\n            sectorAngles[sectorIndex] = minAngle + (remainingAngle * count / totalPoints);\n          });\n        }\n\n        let currentAngle = 0;\n        const sectorInfo = [];\n\n        // Draw sectors\n        for (let i = 0; i < sectors; i++) {\n          const startAngle = currentAngle;\n          const endAngle = currentAngle + sectorAngles[i];\n\n          sectorInfo.push({\n            startAngle,\n            endAngle,\n            index: i,\n            bitVector: i.toString(2).padStart(key.length, \"0\")\n          });\n\n          g.append(\"path\")\n            .attr(\"d\", d3.arc()\n              .innerRadius(innerRadius)\n              .outerRadius(outerRadius)\n              .startAngle(startAngle)\n              .endAngle(endAngle)\n            )\n            .attr(\"fill\", getSectorColor(i))\n            .attr(\"fill-opacity\", 0.4)\n            .attr(\"stroke\", \"#333\")\n            .attr(\"stroke-width\", 0.5);\n\n          currentAngle = endAngle;\n\n          // Ring label\n          if (i === 0) {\n            g.append(\"text\")\n              .attr(\"x\", 0)\n              .attr(\"y\", -outerRadius - 5)\n              .attr(\"text-anchor\", \"middle\")\n              .attr(\"font-size\", \"16px\")\n              .attr(\"fill\", \"red\")\n              .text(ringLabels[index]);\n          }\n        }\n\n        // Place points in center of sectors\n        pointsData[index].points.forEach(point => {\n          const pointData = Object.entries(point).filter(([k]) => k !== \"Point_ID\");\n          const bitVector = pointData.map(([_, coord]) => coord >= 0 ? \"1\" : \"0\").join(\"\");\n          const sectorIndex = parseInt(bitVector, 2);\n          const sector = sectorInfo[sectorIndex];\n\n          const radius = (innerRadius + outerRadius) / 2; // Center of the ring\n          const angle = (sector.startAngle + sector.endAngle) / 2; // Center of the sector\n\n          const x = radius * Math.cos(angle);\n          const y = radius * Math.sin(angle);\n\n          point.Point_ID.forEach(id => {\n            pointPositions[id] = pointPositions[id] || [];\n            pointPositions[id].push({ x, y, point, subspaceId: key });\n          });\n\n          g.append(\"circle\")\n            .attr(\"cx\", x)\n            .attr(\"cy\", y)\n            .attr(\"r\", 3)\n            .attr(\"fill\", getLabelColor(point.Point_ID[0]))\n            .attr(\"stroke\", \"white\")\n            .attr(\"stroke-width\", 0.5)\n            .on(\"mouseover\", (event) => {\n              const pointIds = point.Point_ID.join(\", \");\n              const labels = Object.entries(labelsData.labels || {})\n                .filter(([_, points]) => point.Point_ID.some(id => points.includes(Number(id))))\n                .map(([label]) => label)\n                .join(\", \") || \"No Label\";\n\n              tooltip\n                .style(\"visibility\", \"visible\")\n                .html(`Point_IDs: ${pointIds}<br>Subspace: ${key}<br>Label: ${labels}`);\n              setHoveredCoordinates({ ...point, label: labels });\n            })\n            .on(\"mousemove\", (event) => {\n              tooltip\n                .style(\"top\", `${event.pageY + 10}px`)\n                .style(\"left\", `${event.pageX + 10}px`);\n            })\n            .on(\"mouseout\", () => {\n              tooltip.style(\"visibility\", \"hidden\");\n              setHoveredCoordinates(null);\n            });\n        });\n      });\n\n      // Draw connections\n      Object.entries(pointPositions).forEach(([pointId, positions]) => {\n        if (positions.length > 1) {\n          for (let i = 0; i < positions.length - 1; i++) {\n            g.append(\"line\")\n              .attr(\"x1\", positions[i].x)\n              .attr(\"y1\", positions[i].y)\n              .attr(\"x2\", positions[i + 1].x)\n              .attr(\"y2\", positions[i + 1].y)\n              .attr(\"stroke\", getLabelColor(pointId))\n              .attr(\"stroke-width\", 1)\n              .style(\"opacity\", 0.7);\n          }\n        }\n      });\n\n      svg.call(d3.zoom().on(\"zoom\", (event) => {\n        g.attr(\"transform\", event.transform);\n      }));\n    };\n\n    drawGraph();\n\n    return () => {\n      tooltip.remove();\n      edgePopup.remove();\n    };\n  }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates, isProportionalView, applyToAllRings]);\n\n  return (\n    <div style={{ width: \"100%\", height: \"100%\" }}>\n      <div style={{ marginBottom: \"10px\" }}>\n        <button\n          onClick={() => setIsProportionalView(!isProportionalView)}\n          style={{\n            padding: \"5px 10px\",\n            marginRight: \"10px\",\n            backgroundColor: isProportionalView ? \"#4CAF50\" : \"#f0f0f0\",\n            color: isProportionalView ? \"white\" : \"black\",\n            border: \"1px solid #ccc\",\n            borderRadius: \"4px\",\n            cursor: \"pointer\"\n          }}\n        >\n          {isProportionalView ? \"Normal View\" : \"Proportional View\"}\n        </button>\n        {isProportionalView && (\n          <label style={{ marginLeft: \"10px\" }}>\n            <input\n              type=\"checkbox\"\n              checked={applyToAllRings}\n              onChange={(e) => setApplyToAllRings(e.target.checked)}\n            />\n            Apply to all rings\n          </label>\n        )}\n      </div>\n      <svg ref={graphRef} style={{ width: \"100%\", height: \"800px\" }}></svg>\n    </div>\n  );\n};\n\nexport default HierarchicalGraph;"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}