{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// // HERE ___________________________________---------------------__________________________\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, // Length of the key determines the dimensions\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove(); // Clear previous content\n\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`); // Correct syntax\n\n//     // Start with the largest square and reduce size for each subsequent subspace\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize =\n//         maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n//       const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n//       // Define a color scale (you can customize these colors)\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); // Gold, Pink, Light Blue\n\n//       // Determine color based on subspace dimension\n//       const subspaceColor = colorScale(\n//         subspace.dimensions % colorScale.range().length\n//       );\n\n//       // Draw square for the subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"white\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.75)\n//         .attr(\"stroke-width\", 1);\n\n//       // Draw sector lines (dividing the square into equal parts)\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = (squareSize / 2) * Math.cos(angle);\n//         const y1 = (squareSize / 2) * Math.sin(angle);\n\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 1);\n//       }\n\n//       // Scale for plotting points, now relative to sector\n//       const sectorRadius = squareSize / 2;\n\n//       // Plot points within their respective square and sector\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(\n//           subspace.dimensions,\n//           \"0\"\n//         );\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n//         const sectorAngleMid = (sectorAngleStart + sectorAngleEnd) / 2; // Angle in the middle of sector\n\n//         // Place points randomly inside the sector\n//         const randomRadius = Math.random() * sectorRadius;\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3) // Reduce radius\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .append(\"title\")\n//           .text(`ID: ${point.Point_ID}, Binary: ${bitPattern}`);\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return (\n//     <svg\n//       ref={graphRef}\n//       style={{ width: \"600px\", height: \"600px\", border: \"1px solid black\" }}\n//     ></svg>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || Object.keys(jsonData).length === 0) return;\n    const subspaces = Object.keys(jsonData);\n    const pointsData = subspaces.map(key => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length // Length of the key determines the dimensions\n    }));\n    const svg = d3.select(graphRef.current);\n    const width = 600;\n    const height = 600;\n    const margin = 20;\n    svg.selectAll(\"*\").remove(); // Clear previous content\n\n    const maxSquareSize = Math.min(width, height) - 2 * margin;\n    const g = svg.attr(\"width\", width).attr(\"height\", height).append(\"g\").attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n    // Define a color scale for subspaces\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n    // Start with the largest square and reduce size for each subsequent subspace\n    pointsData.forEach((subspace, index) => {\n      const squareSize = maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n      const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n      // Draw square for the subspace\n      g.append(\"rect\").attr(\"x\", -squareSize / 2).attr(\"y\", -squareSize / 2).attr(\"width\", squareSize).attr(\"height\", squareSize).attr(\"stroke\", \"black\").attr(\"fill\", colorScale(subspace.dimensions)).attr(\"fill-opacity\", 0.2) // Light fill for better visibility\n      .attr(\"stroke-width\", 2); // Thicker stroke for clarity\n\n      // Draw sector lines (dividing the square into equal parts)\n      if (subspace.dimensions > 1) {\n        for (let i = 0; i < sectors; i++) {\n          const angle = 2 * Math.PI * i / sectors;\n          const x1 = squareSize / 2 * Math.cos(angle);\n          const y1 = squareSize / 2 * Math.sin(angle);\n          g.append(\"line\").attr(\"x1\", 0).attr(\"y1\", 0).attr(\"x2\", x1).attr(\"y2\", y1).attr(\"stroke\", \"black\").attr(\"stroke-width\", 1);\n        }\n      }\n\n      // Scale for plotting points\n      const scale = d3.scaleLinear().domain([-1, 1]).range([-squareSize / 2, squareSize / 2]);\n\n      // Plot points within their respective square and sector\n      subspace.points.forEach(point => {\n        const bitPattern = point.Point_ID.toString(2).padStart(subspace.dimensions, \"0\");\n        const sectorIndex = parseInt(bitPattern, 2);\n        const sectorAngleStart = 2 * Math.PI * sectorIndex / sectors;\n        const sectorAngleEnd = 2 * Math.PI * (sectorIndex + 1) / sectors;\n        const sectorAngleMid = (sectorAngleStart + sectorAngleEnd) / 2; // Middle of the sector\n\n        // Place points systematically within the sector\n        const radius = squareSize / 2 * 0.8; // Leave some margin from the edges\n        const angle = sectorAngleMid;\n        const x = radius * Math.cos(angle);\n        const y = radius * Math.sin(angle);\n        g.append(\"circle\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", 4) // Slightly larger radius\n        .attr(\"fill\", \"black\").attr(\"stroke\", \"white\").attr(\"stroke-width\", 0.5).append(\"title\").text(`ID: ${point.Point_ID}, Binary: ${bitPattern}`);\n      });\n    });\n  }, [jsonData]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: graphRef,\n    style: {\n      width: \"600px\",\n      height: \"600px\",\n      border: \"1px solid black\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n};\n_s(HierarchicalGraph, \"XNG/roOlNWxTF7ymftfdirhS32A=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","_s","graphRef","Object","keys","length","subspaces","pointsData","map","key","points","dimensions","svg","select","current","width","height","margin","selectAll","remove","maxSquareSize","Math","min","g","attr","append","colorScale","scaleOrdinal","schemeCategory10","forEach","subspace","index","squareSize","sectors","i","angle","PI","x1","cos","y1","sin","scale","scaleLinear","domain","range","point","bitPattern","Point_ID","toString","padStart","sectorIndex","parseInt","sectorAngleStart","sectorAngleEnd","sectorAngleMid","radius","x","y","text","ref","style","border","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n\n// // HERE ___________________________________---------------------__________________________\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, // Length of the key determines the dimensions\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove(); // Clear previous content\n\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`); // Correct syntax\n\n//     // Start with the largest square and reduce size for each subsequent subspace\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize =\n//         maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n//       const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n//       // Define a color scale (you can customize these colors)\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); // Gold, Pink, Light Blue\n\n//       // Determine color based on subspace dimension\n//       const subspaceColor = colorScale(\n//         subspace.dimensions % colorScale.range().length\n//       );\n\n//       // Draw square for the subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"white\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.75)\n//         .attr(\"stroke-width\", 1);\n\n//       // Draw sector lines (dividing the square into equal parts)\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = (squareSize / 2) * Math.cos(angle);\n//         const y1 = (squareSize / 2) * Math.sin(angle);\n\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 1);\n//       }\n\n//       // Scale for plotting points, now relative to sector\n//       const sectorRadius = squareSize / 2;\n\n//       // Plot points within their respective square and sector\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(\n//           subspace.dimensions,\n//           \"0\"\n//         );\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n//         const sectorAngleMid = (sectorAngleStart + sectorAngleEnd) / 2; // Angle in the middle of sector\n\n//         // Place points randomly inside the sector\n//         const randomRadius = Math.random() * sectorRadius;\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3) // Reduce radius\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .append(\"title\")\n//           .text(`ID: ${point.Point_ID}, Binary: ${bitPattern}`);\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return (\n//     <svg\n//       ref={graphRef}\n//       style={{ width: \"600px\", height: \"600px\", border: \"1px solid black\" }}\n//     ></svg>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\n\n\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData }) => {\n  const graphRef = useRef(null);\n\n  useEffect(() => {\n    if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n    const subspaces = Object.keys(jsonData);\n    const pointsData = subspaces.map((key) => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length, // Length of the key determines the dimensions\n    }));\n\n    const svg = d3.select(graphRef.current);\n    const width = 600;\n    const height = 600;\n    const margin = 20;\n\n    svg.selectAll(\"*\").remove(); // Clear previous content\n\n    const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n    const g = svg\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .append(\"g\")\n      .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n    // Define a color scale for subspaces\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n    // Start with the largest square and reduce size for each subsequent subspace\n    pointsData.forEach((subspace, index) => {\n      const squareSize =\n        maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n      const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n      // Draw square for the subspace\n      g.append(\"rect\")\n        .attr(\"x\", -squareSize / 2)\n        .attr(\"y\", -squareSize / 2)\n        .attr(\"width\", squareSize)\n        .attr(\"height\", squareSize)\n        .attr(\"stroke\", \"black\")\n        .attr(\"fill\", colorScale(subspace.dimensions))\n        .attr(\"fill-opacity\", 0.2) // Light fill for better visibility\n        .attr(\"stroke-width\", 2); // Thicker stroke for clarity\n\n      // Draw sector lines (dividing the square into equal parts)\n      if (subspace.dimensions > 1) {\n        for (let i = 0; i < sectors; i++) {\n          const angle = (2 * Math.PI * i) / sectors;\n          const x1 = (squareSize / 2) * Math.cos(angle);\n          const y1 = (squareSize / 2) * Math.sin(angle);\n\n          g.append(\"line\")\n            .attr(\"x1\", 0)\n            .attr(\"y1\", 0)\n            .attr(\"x2\", x1)\n            .attr(\"y2\", y1)\n            .attr(\"stroke\", \"black\")\n            .attr(\"stroke-width\", 1);\n        }\n      }\n\n      // Scale for plotting points\n      const scale = d3\n        .scaleLinear()\n        .domain([-1, 1])\n        .range([-squareSize / 2, squareSize / 2]);\n\n      // Plot points within their respective square and sector\n      subspace.points.forEach((point) => {\n        const bitPattern = point.Point_ID.toString(2).padStart(\n          subspace.dimensions,\n          \"0\"\n        );\n        const sectorIndex = parseInt(bitPattern, 2);\n        const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n        const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n        const sectorAngleMid = (sectorAngleStart + sectorAngleEnd) / 2; // Middle of the sector\n\n        // Place points systematically within the sector\n        const radius = (squareSize / 2) * 0.8; // Leave some margin from the edges\n        const angle = sectorAngleMid;\n\n        const x = radius * Math.cos(angle);\n        const y = radius * Math.sin(angle);\n\n        g.append(\"circle\")\n          .attr(\"cx\", x)\n          .attr(\"cy\", y)\n          .attr(\"r\", 4) // Slightly larger radius\n          .attr(\"fill\", \"black\")\n          .attr(\"stroke\", \"white\")\n          .attr(\"stroke-width\", 0.5)\n          .append(\"title\")\n          .text(`ID: ${point.Point_ID}, Binary: ${bitPattern}`);\n      });\n    });\n  }, [jsonData]);\n\n  return (\n    <svg\n      ref={graphRef}\n      style={{ width: \"600px\", height: \"600px\", border: \"1px solid black\" }}\n    ></svg>\n  );\n};\n\nexport default HierarchicalGraph;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}