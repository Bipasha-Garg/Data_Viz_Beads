{"ast":null,"code":"const calculateProportionalAngles = pointsData => {\n  if (!pointsData || pointsData.length === 0) {\n    console.warn(\"pointsData is empty or invalid, returning empty angles\");\n    return [];\n  }\n  const lastRing = pointsData[pointsData.length - 1];\n  const lastRingPoints = lastRing.points || [];\n  const sectorsCount = Math.max(2, 2 ** pointsData.dimensions);\n  if (lastRingPoints.length === 0 || !Number.isFinite(sectorsCount)) {\n    console.warn(\"Last ring has no points or invalid sectors, using fallback angles\");\n    return pointsData.map((_, i) => Array(Math.max(1, 2 ** (i + 1))).fill(2 * Math.PI / Math.max(1, 2 ** (i + 1))));\n  }\n\n  // Count points per sector\n  const pointCounts = new Array(sectorsCount).fill(0);\n  lastRingPoints.forEach(point => {\n    const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n    const bitVector = pointData.map(([_, coord]) => coord >= 0 ? 1 : 0).join(\"\");\n    const sectorIndex = parseInt(bitVector, 2);\n    if (sectorIndex >= 0 && sectorIndex < sectorsCount) pointCounts[sectorIndex]++;\n  });\n\n  // Calculate proportional angles\n  const totalAngle = 2 * Math.PI;\n  const totalPoints = Math.max(1, pointCounts.reduce((sum, count) => sum + count, 0));\n  const baseAngle = totalAngle / sectorsCount; // Equal angle for reference\n  const minAngle = Math.PI / 360; // Minimum angle per sector\n  const remainingAngle = totalAngle - sectorsCount * minAngle;\n  const sectorAngles = pointCounts.map(count => {\n    if (count === 0) return minAngle; // Empty sectors get minimum angle\n    const proportionalShare = count / totalPoints * remainingAngle;\n    return minAngle + proportionalShare;\n  });\n\n  // Normalize to ensure totalAngle is respected\n  const angleSum = sectorAngles.reduce((sum, angle) => sum + angle, 0);\n  const normalizedAngles = sectorAngles.map(angle => angle / angleSum * totalAngle);\n\n  // Propagate angles to previous rings\n  const ringAngles = [normalizedAngles];\n  for (let i = pointsData.length - 2; i >= 0; i--) {\n    const prevAngles = ringAngles[0];\n    const sectorCount = Math.max(1, 2 ** (i + 1));\n    const currAngles = new Array(sectorCount).fill(0).map((_, j) => (prevAngles[j * 2] || 0) + (prevAngles[j * 2 + 1] || 0));\n    ringAngles.unshift(currAngles);\n  }\n  return ringAngles;\n};","map":{"version":3,"names":["calculateProportionalAngles","pointsData","length","console","warn","lastRing","lastRingPoints","points","sectorsCount","Math","max","dimensions","Number","isFinite","map","_","i","Array","fill","PI","pointCounts","forEach","point","pointData","Object","entries","filter","key","bitVector","coord","join","sectorIndex","parseInt","totalAngle","totalPoints","reduce","sum","count","baseAngle","minAngle","remainingAngle","sectorAngles","proportionalShare","angleSum","angle","normalizedAngles","ringAngles","prevAngles","sectorCount","currAngles","j","unshift"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/ProportionalView.js"],"sourcesContent":["const calculateProportionalAngles = (pointsData) => {\n    if (!pointsData || pointsData.length === 0) {\n        console.warn(\"pointsData is empty or invalid, returning empty angles\");\n        return [];\n    }\n\n    const lastRing = pointsData[pointsData.length - 1];\n    const lastRingPoints = lastRing.points || [];\n    const sectorsCount = Math.max(2, 2 ** pointsData.dimensions);\n\n    if (lastRingPoints.length === 0 || !Number.isFinite(sectorsCount)) {\n        console.warn(\"Last ring has no points or invalid sectors, using fallback angles\");\n        return pointsData.map((_, i) =>\n            Array(Math.max(1, 2 ** (i + 1))).fill(2 * Math.PI / Math.max(1, 2 ** (i + 1)))\n        );\n    }\n\n    // Count points per sector\n    const pointCounts = new Array(sectorsCount).fill(0);\n    lastRingPoints.forEach((point) => {\n        const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n        const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n        const sectorIndex = parseInt(bitVector, 2);\n        if (sectorIndex >= 0 && sectorIndex < sectorsCount) pointCounts[sectorIndex]++;\n    });\n\n    // Calculate proportional angles\n    const totalAngle = 2 * Math.PI;\n    const totalPoints = Math.max(1, pointCounts.reduce((sum, count) => sum + count, 0));\n    const baseAngle = totalAngle / sectorsCount; // Equal angle for reference\n    const minAngle = Math.PI / 360; // Minimum angle per sector\n    const remainingAngle = totalAngle - sectorsCount * minAngle;\n\n    const sectorAngles = pointCounts.map((count) => {\n        if (count === 0) return minAngle; // Empty sectors get minimum angle\n        const proportionalShare = (count / totalPoints) * remainingAngle;\n        return minAngle + proportionalShare;\n    });\n\n    // Normalize to ensure totalAngle is respected\n    const angleSum = sectorAngles.reduce((sum, angle) => sum + angle, 0);\n    const normalizedAngles = sectorAngles.map(angle => (angle / angleSum) * totalAngle);\n\n    // Propagate angles to previous rings\n    const ringAngles = [normalizedAngles];\n    for (let i = pointsData.length - 2; i >= 0; i--) {\n        const prevAngles = ringAngles[0];\n        const sectorCount = Math.max(1, 2 ** (i + 1));\n        const currAngles = new Array(sectorCount).fill(0).map((_, j) =>\n            (prevAngles[j * 2] || 0) + (prevAngles[j * 2 + 1] || 0)\n        );\n        ringAngles.unshift(currAngles);\n    }\n\n    return ringAngles;\n};"],"mappings":"AAAA,MAAMA,2BAA2B,GAAIC,UAAU,IAAK;EAChD,IAAI,CAACA,UAAU,IAAIA,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE;IACxCC,OAAO,CAACC,IAAI,CAAC,wDAAwD,CAAC;IACtE,OAAO,EAAE;EACb;EAEA,MAAMC,QAAQ,GAAGJ,UAAU,CAACA,UAAU,CAACC,MAAM,GAAG,CAAC,CAAC;EAClD,MAAMI,cAAc,GAAGD,QAAQ,CAACE,MAAM,IAAI,EAAE;EAC5C,MAAMC,YAAY,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,IAAIT,UAAU,CAACU,UAAU,CAAC;EAE5D,IAAIL,cAAc,CAACJ,MAAM,KAAK,CAAC,IAAI,CAACU,MAAM,CAACC,QAAQ,CAACL,YAAY,CAAC,EAAE;IAC/DL,OAAO,CAACC,IAAI,CAAC,mEAAmE,CAAC;IACjF,OAAOH,UAAU,CAACa,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KACvBC,KAAK,CAACR,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,KAAKM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC,GAAGT,IAAI,CAACU,EAAE,GAAGV,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,KAAKM,CAAC,GAAG,CAAC,CAAC,CAAC,CACjF,CAAC;EACL;;EAEA;EACA,MAAMI,WAAW,GAAG,IAAIH,KAAK,CAACT,YAAY,CAAC,CAACU,IAAI,CAAC,CAAC,CAAC;EACnDZ,cAAc,CAACe,OAAO,CAAEC,KAAK,IAAK;IAC9B,MAAMC,SAAS,GAAGC,MAAM,CAACC,OAAO,CAACH,KAAK,CAAC,CAACI,MAAM,CAAC,CAAC,CAACC,GAAG,CAAC,KAAKA,GAAG,KAAK,UAAU,CAAC;IAC7E,MAAMC,SAAS,GAAGL,SAAS,CAACT,GAAG,CAAC,CAAC,CAACC,CAAC,EAAEc,KAAK,CAAC,KAAMA,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC;IAC9E,MAAMC,WAAW,GAAGC,QAAQ,CAACJ,SAAS,EAAE,CAAC,CAAC;IAC1C,IAAIG,WAAW,IAAI,CAAC,IAAIA,WAAW,GAAGvB,YAAY,EAAEY,WAAW,CAACW,WAAW,CAAC,EAAE;EAClF,CAAC,CAAC;;EAEF;EACA,MAAME,UAAU,GAAG,CAAC,GAAGxB,IAAI,CAACU,EAAE;EAC9B,MAAMe,WAAW,GAAGzB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEU,WAAW,CAACe,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAKD,GAAG,GAAGC,KAAK,EAAE,CAAC,CAAC,CAAC;EACnF,MAAMC,SAAS,GAAGL,UAAU,GAAGzB,YAAY,CAAC,CAAC;EAC7C,MAAM+B,QAAQ,GAAG9B,IAAI,CAACU,EAAE,GAAG,GAAG,CAAC,CAAC;EAChC,MAAMqB,cAAc,GAAGP,UAAU,GAAGzB,YAAY,GAAG+B,QAAQ;EAE3D,MAAME,YAAY,GAAGrB,WAAW,CAACN,GAAG,CAAEuB,KAAK,IAAK;IAC5C,IAAIA,KAAK,KAAK,CAAC,EAAE,OAAOE,QAAQ,CAAC,CAAC;IAClC,MAAMG,iBAAiB,GAAIL,KAAK,GAAGH,WAAW,GAAIM,cAAc;IAChE,OAAOD,QAAQ,GAAGG,iBAAiB;EACvC,CAAC,CAAC;;EAEF;EACA,MAAMC,QAAQ,GAAGF,YAAY,CAACN,MAAM,CAAC,CAACC,GAAG,EAAEQ,KAAK,KAAKR,GAAG,GAAGQ,KAAK,EAAE,CAAC,CAAC;EACpE,MAAMC,gBAAgB,GAAGJ,YAAY,CAAC3B,GAAG,CAAC8B,KAAK,IAAKA,KAAK,GAAGD,QAAQ,GAAIV,UAAU,CAAC;;EAEnF;EACA,MAAMa,UAAU,GAAG,CAACD,gBAAgB,CAAC;EACrC,KAAK,IAAI7B,CAAC,GAAGf,UAAU,CAACC,MAAM,GAAG,CAAC,EAAEc,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC7C,MAAM+B,UAAU,GAAGD,UAAU,CAAC,CAAC,CAAC;IAChC,MAAME,WAAW,GAAGvC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,KAAKM,CAAC,GAAG,CAAC,CAAC,CAAC;IAC7C,MAAMiC,UAAU,GAAG,IAAIhC,KAAK,CAAC+B,WAAW,CAAC,CAAC9B,IAAI,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAACC,CAAC,EAAEmC,CAAC,KACvD,CAACH,UAAU,CAACG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAKH,UAAU,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAC1D,CAAC;IACDJ,UAAU,CAACK,OAAO,CAACF,UAAU,CAAC;EAClC;EAEA,OAAOH,UAAU;AACrB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}