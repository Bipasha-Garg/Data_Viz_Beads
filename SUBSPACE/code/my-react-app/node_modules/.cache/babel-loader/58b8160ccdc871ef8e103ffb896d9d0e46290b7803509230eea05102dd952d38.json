{"ast":null,"code":"\n// import React, { useEffect, useRef, useState } from \"react\";\n// import * as d3 from \"d3\";\n\n// const ParallelCoordinates = ({ data }) => {\n//     const svgRef = useRef(null);\n//     const containerRef = useRef(null);\n//     const [dimensions, setDimensions] = useState({ width: 600, height: 400 });\n\n//     // Update dimensions on resize\n//     useEffect(() => {\n//         const updateDimensions = () => {\n//             if (containerRef.current) {\n//                 const { width, height } = containerRef.current.getBoundingClientRect();\n//                 setDimensions({\n//                     width: Math.max(width, 300), // Minimum width\n//                     height: Math.max(height, 200) // Minimum height\n//                 });\n//             }\n//         };\n\n//         updateDimensions();\n//         window.addEventListener('resize', updateDimensions);\n//         return () => window.removeEventListener('resize', updateDimensions);\n//     }, []);\n\n//     useEffect(() => {\n//         if (!data || !data.data || !Array.isArray(data.data) || !data.dimensions) return;\n\n//         const svg = d3.select(svgRef.current);\n//         svg.selectAll(\"*\").remove();\n\n//         // Use dynamic dimensions\n//         const width = dimensions.width;\n//         const height = dimensions.height;\n//         const margin = {\n//             top: Math.max(40, height * 0.1),\n//             right: Math.max(40, width * 0.05),\n//             bottom: Math.max(20, height * 0.05),\n//             left: Math.max(40, width * 0.05)\n//         };\n\n//         const dimensionsList = data.dimensions;\n\n//         // Create y-scales for each dimension\n//         const yScales = {};\n//         dimensionsList.forEach(dim => {\n//             yScales[dim] = d3\n//                 .scaleLinear()\n//                 .domain(d3.extent(data.data, d => d.values[dim]))\n//                 .range([height - margin.top - margin.bottom, 0])\n//                 .nice();\n//         });\n\n//         // Create x-scale for dimensions\n//         const xScale = d3\n//             .scalePoint()\n//             .domain(dimensionsList)\n//             .range([0, width - margin.left - margin.right])\n//             .padding(0.1);\n\n//         // Color scale based on actual labels\n//         const colorScale = d3\n//             .scaleOrdinal(d3.schemeCategory10)\n//             .domain([...new Set(data.data.map(d => d.label))]);\n\n//         const g = svg\n//             .attr(\"width\", width)\n//             .attr(\"height\", height)\n//             .append(\"g\")\n//             .attr(\"transform\", `translate(${margin.left}, ${margin.top})`);\n\n//         // Axes\n//         const axes = g.selectAll(\".axis\")\n//             .data(dimensionsList)\n//             .enter()\n//             .append(\"g\")\n//             .attr(\"class\", \"axis\")\n//             .attr(\"transform\", d => `translate(${xScale(d)}, 0)`);\n\n//         axes.each(function (d) {\n//             d3.select(this)\n//                 .call(d3.axisLeft(yScales[d])\n//                     .ticks(Math.max(3, Math.floor(height / 100))) // Dynamic tick count\n//                     .tickFormat(d3.format(\".2f\")))\n//                 .selectAll(\"text\")\n//                 .style(\"font-size\", `${Math.max(10, width / 100)}px`);\n//         });\n\n//         // Axis labels\n//         axes.append(\"text\")\n//             .attr(\"y\", -margin.top * 0.4)\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"fill\", \"black\")\n//             .style(\"font-size\", `${Math.max(10, width / 80)}px`)\n//             .text(d => d);\n\n//         // Lines\n//         const line = d3.line();\n//         const lines = g.selectAll(\".line\")\n//             .data(data.data)\n//             .enter()\n//             .append(\"path\")\n//             .attr(\"class\", \"line\")\n//             .attr(\"d\", d =>\n//                 line(dimensionsList.map(dim => [xScale(dim), yScales[dim](d.values[dim])]))\n//             )\n//             .attr(\"stroke\", d => colorScale(d.label))\n//             .attr(\"stroke-width\", Math.max(1, width / 600))\n//             .attr(\"fill\", \"none\")\n//             .attr(\"opacity\", 0.5)\n//             .append(\"title\")\n//             .text(d => `ID: ${d.Point_ID}\\nActual: ${d.label}\\nPredicted: ${d.prediction}`);\n\n//         // Add legend\n//         const legendWidth = Math.min(120, width * 0.2);\n//         const legend = g.append(\"g\")\n//             .attr(\"transform\", `translate(${width - margin.left - margin.right - legendWidth}, 0)`);\n\n//         const uniqueLabels = [...new Set(data.data.map(d => d.label))];\n//         const legendItemHeight = Math.max(20, height / 20);\n\n//         // Only show legend if it fits\n//         if (legendWidth > 50 && uniqueLabels.length * legendItemHeight < height - margin.top) {\n//             uniqueLabels.forEach((label, i) => {\n//                 const legendRow = legend.append(\"g\")\n//                     .attr(\"transform\", `translate(0, ${i * legendItemHeight})`);\n\n//                 legendRow.append(\"rect\")\n//                     .attr(\"width\", legendWidth * 0.2)\n//                     .attr(\"height\", legendWidth * 0.2)\n//                     .attr(\"fill\", colorScale(label));\n\n//                 legendRow.append(\"text\")\n//                     .attr(\"x\", legendWidth * 0.3)\n//                     .attr(\"y\", legendWidth * 0.2 * 0.8)\n//                     .attr(\"fill\", \"black\")\n//                     .style(\"font-size\", `${Math.max(10, width / 80)}px`)\n//                     .text(label)\n//                     .attr(\"text-anchor\", \"start\")\n//                     .attr(\"dominant-baseline\", \"middle\");\n//             });\n//         }\n\n//     }, [data, dimensions]);\n\n//     return (\n//         <div\n//             ref={containerRef}\n//             className=\"w-full h-full overflow-auto\"\n//             style={{ minHeight: '200px', minWidth: '300px' }}\n//         >\n//             <svg\n//                 ref={svgRef}\n//                 style={{\n//                     width: '100%',\n//                     height: '100%',\n//                     minWidth: '100%',\n//                     minHeight: '100%'\n//                 }}\n//             />\n//         </div>\n//     );\n// };\n\n// export default ParallelCoordinates;","map":{"version":3,"names":[],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/ParallelCoordinates.js"],"sourcesContent":["\n// import React, { useEffect, useRef, useState } from \"react\";\n// import * as d3 from \"d3\";\n\n// const ParallelCoordinates = ({ data }) => {\n//     const svgRef = useRef(null);\n//     const containerRef = useRef(null);\n//     const [dimensions, setDimensions] = useState({ width: 600, height: 400 });\n\n//     // Update dimensions on resize\n//     useEffect(() => {\n//         const updateDimensions = () => {\n//             if (containerRef.current) {\n//                 const { width, height } = containerRef.current.getBoundingClientRect();\n//                 setDimensions({\n//                     width: Math.max(width, 300), // Minimum width\n//                     height: Math.max(height, 200) // Minimum height\n//                 });\n//             }\n//         };\n\n//         updateDimensions();\n//         window.addEventListener('resize', updateDimensions);\n//         return () => window.removeEventListener('resize', updateDimensions);\n//     }, []);\n\n//     useEffect(() => {\n//         if (!data || !data.data || !Array.isArray(data.data) || !data.dimensions) return;\n\n//         const svg = d3.select(svgRef.current);\n//         svg.selectAll(\"*\").remove();\n\n//         // Use dynamic dimensions\n//         const width = dimensions.width;\n//         const height = dimensions.height;\n//         const margin = {\n//             top: Math.max(40, height * 0.1),\n//             right: Math.max(40, width * 0.05),\n//             bottom: Math.max(20, height * 0.05),\n//             left: Math.max(40, width * 0.05)\n//         };\n\n//         const dimensionsList = data.dimensions;\n\n//         // Create y-scales for each dimension\n//         const yScales = {};\n//         dimensionsList.forEach(dim => {\n//             yScales[dim] = d3\n//                 .scaleLinear()\n//                 .domain(d3.extent(data.data, d => d.values[dim]))\n//                 .range([height - margin.top - margin.bottom, 0])\n//                 .nice();\n//         });\n\n//         // Create x-scale for dimensions\n//         const xScale = d3\n//             .scalePoint()\n//             .domain(dimensionsList)\n//             .range([0, width - margin.left - margin.right])\n//             .padding(0.1);\n\n//         // Color scale based on actual labels\n//         const colorScale = d3\n//             .scaleOrdinal(d3.schemeCategory10)\n//             .domain([...new Set(data.data.map(d => d.label))]);\n\n//         const g = svg\n//             .attr(\"width\", width)\n//             .attr(\"height\", height)\n//             .append(\"g\")\n//             .attr(\"transform\", `translate(${margin.left}, ${margin.top})`);\n\n//         // Axes\n//         const axes = g.selectAll(\".axis\")\n//             .data(dimensionsList)\n//             .enter()\n//             .append(\"g\")\n//             .attr(\"class\", \"axis\")\n//             .attr(\"transform\", d => `translate(${xScale(d)}, 0)`);\n\n//         axes.each(function (d) {\n//             d3.select(this)\n//                 .call(d3.axisLeft(yScales[d])\n//                     .ticks(Math.max(3, Math.floor(height / 100))) // Dynamic tick count\n//                     .tickFormat(d3.format(\".2f\")))\n//                 .selectAll(\"text\")\n//                 .style(\"font-size\", `${Math.max(10, width / 100)}px`);\n//         });\n\n//         // Axis labels\n//         axes.append(\"text\")\n//             .attr(\"y\", -margin.top * 0.4)\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"fill\", \"black\")\n//             .style(\"font-size\", `${Math.max(10, width / 80)}px`)\n//             .text(d => d);\n\n//         // Lines\n//         const line = d3.line();\n//         const lines = g.selectAll(\".line\")\n//             .data(data.data)\n//             .enter()\n//             .append(\"path\")\n//             .attr(\"class\", \"line\")\n//             .attr(\"d\", d =>\n//                 line(dimensionsList.map(dim => [xScale(dim), yScales[dim](d.values[dim])]))\n//             )\n//             .attr(\"stroke\", d => colorScale(d.label))\n//             .attr(\"stroke-width\", Math.max(1, width / 600))\n//             .attr(\"fill\", \"none\")\n//             .attr(\"opacity\", 0.5)\n//             .append(\"title\")\n//             .text(d => `ID: ${d.Point_ID}\\nActual: ${d.label}\\nPredicted: ${d.prediction}`);\n\n//         // Add legend\n//         const legendWidth = Math.min(120, width * 0.2);\n//         const legend = g.append(\"g\")\n//             .attr(\"transform\", `translate(${width - margin.left - margin.right - legendWidth}, 0)`);\n\n//         const uniqueLabels = [...new Set(data.data.map(d => d.label))];\n//         const legendItemHeight = Math.max(20, height / 20);\n\n//         // Only show legend if it fits\n//         if (legendWidth > 50 && uniqueLabels.length * legendItemHeight < height - margin.top) {\n//             uniqueLabels.forEach((label, i) => {\n//                 const legendRow = legend.append(\"g\")\n//                     .attr(\"transform\", `translate(0, ${i * legendItemHeight})`);\n\n//                 legendRow.append(\"rect\")\n//                     .attr(\"width\", legendWidth * 0.2)\n//                     .attr(\"height\", legendWidth * 0.2)\n//                     .attr(\"fill\", colorScale(label));\n\n//                 legendRow.append(\"text\")\n//                     .attr(\"x\", legendWidth * 0.3)\n//                     .attr(\"y\", legendWidth * 0.2 * 0.8)\n//                     .attr(\"fill\", \"black\")\n//                     .style(\"font-size\", `${Math.max(10, width / 80)}px`)\n//                     .text(label)\n//                     .attr(\"text-anchor\", \"start\")\n//                     .attr(\"dominant-baseline\", \"middle\");\n//             });\n//         }\n\n//     }, [data, dimensions]);\n\n//     return (\n//         <div\n//             ref={containerRef}\n//             className=\"w-full h-full overflow-auto\"\n//             style={{ minHeight: '200px', minWidth: '300px' }}\n//         >\n//             <svg\n//                 ref={svgRef}\n//                 style={{\n//                     width: '100%',\n//                     height: '100%',\n//                     minWidth: '100%',\n//                     minHeight: '100%'\n//                 }}\n//             />\n//         </div>\n//     );\n// };\n\n// export default ParallelCoordinates;"],"mappings":";AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}