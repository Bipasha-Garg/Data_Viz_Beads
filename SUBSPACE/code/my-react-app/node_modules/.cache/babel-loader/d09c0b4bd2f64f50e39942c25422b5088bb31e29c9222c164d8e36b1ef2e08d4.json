{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/ScatterPlot.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const ScatterPlotMatrix = ({ data }) => {\n//     const svgRef = useRef(null);\n\n//     useEffect(() => {\n//         if (!data || !data.points || !Array.isArray(data.points) || data.points.length === 0) return;\n\n//         const svg = d3.select(svgRef.current);\n//         svg.selectAll(\"*\").remove();\n\n//         // Get all feature names\n//         const features = Object.keys(data.points[0].features);\n//         const n = features.length;\n\n//         const size = 200; // Increased size for better visibility\n//         const padding = 40; // Increased padding for labels\n//         const totalSize = n * (size + padding);\n\n//         svg.attr(\"width\", totalSize + padding)\n//             .attr(\"height\", totalSize + padding);\n\n//         const colorScale = d3\n//             .scaleOrdinal(d3.schemeCategory10)\n//             .domain([...new Set(data.points.map(d => d.actual_label))]);\n\n//         // Create scales for each feature\n//         const scales = features.map(feat => {\n//             return d3.scaleLinear()\n//                 .domain(d3.extent(data.points, d => d.features[feat]))\n//                 .range([padding / 2, size - padding / 2])\n//                 .nice(); // Rounds domain for nicer tick values\n//         });\n\n//         // Create the matrix\n//         features.forEach((featX, i) => {\n//             features.forEach((featY, j) => {\n//                 const g = svg.append(\"g\")\n//                     .attr(\"transform\", `translate(${i * (size + padding)}, ${j * (size + padding)})`);\n\n//                 // Add background rectangle for better contrast\n//                 g.append(\"rect\")\n//                     .attr(\"width\", size)\n//                     .attr(\"height\", size)\n//                     .attr(\"fill\", \"#f5f5f5\");\n\n//                 // Add axes with better formatting\n//                 const xAxis = d3.axisBottom(scales[i])\n//                     .ticks(5)\n//                     .tickFormat(d3.format(\".2f\"));\n\n//                 const yAxis = d3.axisLeft(scales[j])\n//                     .ticks(5)\n//                     .tickFormat(d3.format(\".2f\"));\n\n//                 // Bottom axis\n//                 g.append(\"g\")\n//                     .attr(\"transform\", `translate(0, ${size - padding / 2})`)\n//                     .call(xAxis)\n//                     .selectAll(\"text\")\n//                     .style(\"font-size\", \"10px\");\n\n//                 // Left axis\n//                 g.append(\"g\")\n//                     .attr(\"transform\", `translate(${padding / 2}, 0)`)\n//                     .call(yAxis)\n//                     .selectAll(\"text\")\n//                     .style(\"font-size\", \"10px\");\n\n//                 // Add feature labels\n//                 if (j === 0) {\n//                     g.append(\"text\")\n//                         .attr(\"x\", size / 2)\n//                         .attr(\"y\", -padding / 2)\n//                         .attr(\"text-anchor\", \"middle\")\n//                         .style(\"font-size\", \"12px\")\n//                         .text(featX);\n//                 }\n//                 if (i === 0) {\n//                     g.append(\"text\")\n//                         .attr(\"transform\", \"rotate(-90)\")\n//                         .attr(\"x\", -size / 2)\n//                         .attr(\"y\", padding / 4)\n//                         .attr(\"text-anchor\", \"middle\")\n//                         .style(\"font-size\", \"12px\")\n//                         .text(featY);\n//                 }\n\n//                 // Add points or diagonal text\n//                 if (i === j) {\n//                     g.append(\"text\")\n//                         .attr(\"x\", size / 2)\n//                         .attr(\"y\", size / 2)\n//                         .attr(\"text-anchor\", \"middle\")\n//                         .attr(\"dominant-baseline\", \"middle\")\n//                         .style(\"font-size\", \"14px\")\n//                         .style(\"font-style\", \"italic\")\n//                         .text(featX);\n//                 } else {\n//                     g.selectAll(\"circle\")\n//                         .data(data.points)\n//                         .enter()\n//                         .append(\"circle\")\n//                         .attr(\"cx\", d => scales[i](d.features[featX]))\n//                         .attr(\"cy\", d => scales[j](d.features[featY]))\n//                         .attr(\"r\", 4)\n//                         .attr(\"fill\", d => colorScale(d.actual_label))\n//                         .attr(\"opacity\", 0.7)\n//                         .append(\"title\")\n//                         .text(d => `ID: ${d.Point_ID}\\nActual: ${d.actual_label}\\nPredicted: ${d.predicted_label}`);\n//                 }\n//             });\n//         });\n\n//         // Add legend\n//         const legend = svg.append(\"g\")\n//             .attr(\"transform\", `translate(${totalSize - 120}, ${padding})`);\n\n//         const uniqueLabels = [...new Set(data.points.map(d => d.actual_label))];\n//         uniqueLabels.forEach((label, i) => {\n//             const legendRow = legend.append(\"g\")\n//                 .attr(\"transform\", `translate(0, ${i * 20})`);\n\n//             legendRow.append(\"rect\")\n//                 .attr(\"width\", 12)\n//                 .attr(\"height\", 12)\n//                 .attr(\"fill\", colorScale(label));\n\n//             legendRow.append(\"text\")\n//                 .attr(\"x\", 18)\n//                 .attr(\"y\", 10)\n//                 .attr(\"fill\", \"black\")\n//                 .style(\"font-size\", \"12px\")\n//                 .text(label);\n//         });\n\n//     }, [data]);\n\n//     return (\n//         <div style={{ width: \"100%\", overflow: \"auto\", padding: \"20px\" }}>\n//             <svg ref={svgRef}></svg>\n//         </div>\n//     );\n// };\n\n// export default ScatterPlotMatrix;\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ScatterPlotMatrix = ({\n  data\n}) => {\n  _s();\n  const svgRef = useRef(null);\n  const containerRef = useRef(null);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [selectedPoints, setSelectedPoints] = useState(new Set());\n\n  // Handle resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const {\n          width,\n          height\n        } = containerRef.current.getBoundingClientRect();\n        setDimensions({\n          width: Math.max(width, 300),\n          // Minimum width\n          height: Math.max(height, 300) // Minimum height\n        });\n      }\n    };\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, []);\n  useEffect(() => {\n    if (!data || !data.points || !data.points.length) return;\n    const svg = d3.select(svgRef.current);\n    svg.selectAll(\"*\").remove();\n    const features = Object.keys(data.points[0].features);\n    const n = features.length;\n\n    // Responsive sizing\n    const padding = Math.max(40, dimensions.width * 0.05);\n    const size = Math.min(200, Math.floor((dimensions.width - padding) / n));\n    const totalSize = n * (size + padding);\n    svg.attr(\"width\", totalSize + padding).attr(\"height\", totalSize + padding);\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain([...new Set(data.points.map(d => d.actual_label))]);\n\n    // Create scales\n    const scales = features.map(feat => {\n      return d3.scaleLinear().domain(d3.extent(data.points, d => d.features[feat])).range([padding / 2, size - padding / 2]).nice();\n    });\n\n    // Create matrix\n    features.forEach((featX, i) => {\n      features.forEach((featY, j) => {\n        const g = svg.append(\"g\").attr(\"transform\", `translate(${i * (size + padding)}, ${j * (size + padding)})`);\n        g.append(\"rect\").attr(\"width\", size).attr(\"height\", size).attr(\"fill\", \"#f5f5f5\");\n\n        // Axes\n        const xAxis = d3.axisBottom(scales[i]).ticks(Math.max(3, Math.floor(size / 50))).tickFormat(d3.format(\".2f\"));\n        const yAxis = d3.axisLeft(scales[j]).ticks(Math.max(3, Math.floor(size / 50))).tickFormat(d3.format(\".2f\"));\n        g.append(\"g\").attr(\"transform\", `translate(0, ${size - padding / 2})`).call(xAxis).selectAll(\"text\").style(\"font-size\", `${Math.max(8, size / 20)}px`);\n        g.append(\"g\").attr(\"transform\", `translate(${padding / 2}, 0)`).call(yAxis).selectAll(\"text\").style(\"font-size\", `${Math.max(8, size / 20)}px`);\n\n        // Labels\n        if (j === 0) {\n          g.append(\"text\").attr(\"x\", size / 2).attr(\"y\", -padding / 2).attr(\"text-anchor\", \"middle\").style(\"font-size\", `${Math.max(10, size / 15)}px`).text(featX);\n        }\n        if (i === 0) {\n          g.append(\"text\").attr(\"transform\", \"rotate(-90)\").attr(\"x\", -size / 2).attr(\"y\", padding / 4).attr(\"text-anchor\", \"middle\").style(\"font-size\", `${Math.max(10, size / 15)}px`).text(featY);\n        }\n\n        // Points or diagonal text\n        if (i === j) {\n          g.append(\"text\").attr(\"x\", size / 2).attr(\"y\", size / 2).attr(\"text-anchor\", \"middle\").attr(\"dominant-baseline\", \"middle\").style(\"font-size\", `${Math.max(12, size / 12)}px`).style(\"font-style\", \"italic\").text(featX);\n        } else {\n          const points = g.selectAll(\"circle\").data(data.points).enter().append(\"circle\").attr(\"cx\", d => scales[i](d.features[featX])).attr(\"cy\", d => scales[j](d.features[featY])).attr(\"r\", Math.max(3, size / 50)).attr(\"fill\", d => colorScale(d.actual_label)).attr(\"opacity\", d => selectedPoints.has(d.Point_ID) ? 1 : 0.7).append(\"title\").text(d => `ID: ${d.Point_ID}\\nActual: ${d.actual_label}\\nPredicted: ${d.predicted_label}`);\n\n          // Add brushing\n          const brush = d3.brush().extent([[0, 0], [size, size]]).on(\"start brush end\", event => {\n            if (event.selection) {\n              const [[x0, y0], [x1, y1]] = event.selection;\n              const selected = new Set();\n              points.each(d => {\n                const x = scales[i](d.features[featX]);\n                const y = scales[j](d.features[featY]);\n                if (x >= x0 && x <= x1 && y >= y0 && y <= y1) {\n                  selected.add(d.Point_ID);\n                }\n              });\n              setSelectedPoints(selected);\n              points.attr(\"opacity\", d => selected.has(d.Point_ID) ? 1 : 0.3);\n            } else {\n              setSelectedPoints(new Set());\n              points.attr(\"opacity\", 0.7);\n            }\n          });\n          g.append(\"g\").attr(\"class\", \"brush\").call(brush);\n        }\n      });\n    });\n\n    // Legend\n    const legendWidth = Math.min(120, dimensions.width * 0.1);\n    const legend = svg.append(\"g\").attr(\"transform\", `translate(${totalSize - legendWidth - padding / 2}, ${padding})`);\n    const uniqueLabels = [...new Set(data.points.map(d => d.actual_label))];\n    const legendItemHeight = Math.max(20, size / 10);\n    if (legendWidth > 50 && uniqueLabels.length * legendItemHeight < totalSize - padding) {\n      uniqueLabels.forEach((label, i) => {\n        const legendRow = legend.append(\"g\").attr(\"transform\", `translate(0, ${i * legendItemHeight})`);\n        legendRow.append(\"rect\").attr(\"width\", legendWidth * 0.2).attr(\"height\", legendWidth * 0.2).attr(\"fill\", colorScale(label));\n        legendRow.append(\"text\").attr(\"x\", legendWidth * 0.3).attr(\"y\", legendWidth * 0.2 * 0.8).attr(\"fill\", \"black\").style(\"font-size\", `${Math.max(10, size / 15)}px`).text(label);\n      });\n    }\n  }, [data, dimensions]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: \"w-full h-full overflow-auto\",\n    style: {\n      minHeight: '300px',\n      minWidth: '300px',\n      padding: '20px'\n    },\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: svgRef,\n      style: {\n        width: '100%',\n        height: '100%',\n        minWidth: '100%',\n        minHeight: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 341,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 336,\n    columnNumber: 9\n  }, this);\n};\n_s(ScatterPlotMatrix, \"4Mw4qGeQBJ93rqM1Aujr3Zqr8Fk=\");\n_c = ScatterPlotMatrix;\nexport default ScatterPlotMatrix;\nvar _c;\n$RefreshReg$(_c, \"ScatterPlotMatrix\");","map":{"version":3,"names":["React","useEffect","useRef","useState","d3","jsxDEV","_jsxDEV","ScatterPlotMatrix","data","_s","svgRef","containerRef","dimensions","setDimensions","width","height","selectedPoints","setSelectedPoints","Set","updateDimensions","current","getBoundingClientRect","Math","max","window","addEventListener","removeEventListener","points","length","svg","select","selectAll","remove","features","Object","keys","n","padding","size","min","floor","totalSize","attr","colorScale","scaleOrdinal","schemeCategory10","domain","map","d","actual_label","scales","feat","scaleLinear","extent","range","nice","forEach","featX","i","featY","j","g","append","xAxis","axisBottom","ticks","tickFormat","format","yAxis","axisLeft","call","style","text","enter","has","Point_ID","predicted_label","brush","on","event","selection","x0","y0","x1","y1","selected","each","x","y","add","legendWidth","legend","uniqueLabels","legendItemHeight","label","legendRow","ref","className","minHeight","minWidth","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/ScatterPlot.js"],"sourcesContent":["// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const ScatterPlotMatrix = ({ data }) => {\n//     const svgRef = useRef(null);\n\n//     useEffect(() => {\n//         if (!data || !data.points || !Array.isArray(data.points) || data.points.length === 0) return;\n\n//         const svg = d3.select(svgRef.current);\n//         svg.selectAll(\"*\").remove();\n\n//         // Get all feature names\n//         const features = Object.keys(data.points[0].features);\n//         const n = features.length;\n\n//         const size = 200; // Increased size for better visibility\n//         const padding = 40; // Increased padding for labels\n//         const totalSize = n * (size + padding);\n\n//         svg.attr(\"width\", totalSize + padding)\n//             .attr(\"height\", totalSize + padding);\n\n//         const colorScale = d3\n//             .scaleOrdinal(d3.schemeCategory10)\n//             .domain([...new Set(data.points.map(d => d.actual_label))]);\n\n//         // Create scales for each feature\n//         const scales = features.map(feat => {\n//             return d3.scaleLinear()\n//                 .domain(d3.extent(data.points, d => d.features[feat]))\n//                 .range([padding / 2, size - padding / 2])\n//                 .nice(); // Rounds domain for nicer tick values\n//         });\n\n//         // Create the matrix\n//         features.forEach((featX, i) => {\n//             features.forEach((featY, j) => {\n//                 const g = svg.append(\"g\")\n//                     .attr(\"transform\", `translate(${i * (size + padding)}, ${j * (size + padding)})`);\n\n//                 // Add background rectangle for better contrast\n//                 g.append(\"rect\")\n//                     .attr(\"width\", size)\n//                     .attr(\"height\", size)\n//                     .attr(\"fill\", \"#f5f5f5\");\n\n//                 // Add axes with better formatting\n//                 const xAxis = d3.axisBottom(scales[i])\n//                     .ticks(5)\n//                     .tickFormat(d3.format(\".2f\"));\n\n//                 const yAxis = d3.axisLeft(scales[j])\n//                     .ticks(5)\n//                     .tickFormat(d3.format(\".2f\"));\n\n//                 // Bottom axis\n//                 g.append(\"g\")\n//                     .attr(\"transform\", `translate(0, ${size - padding / 2})`)\n//                     .call(xAxis)\n//                     .selectAll(\"text\")\n//                     .style(\"font-size\", \"10px\");\n\n//                 // Left axis\n//                 g.append(\"g\")\n//                     .attr(\"transform\", `translate(${padding / 2}, 0)`)\n//                     .call(yAxis)\n//                     .selectAll(\"text\")\n//                     .style(\"font-size\", \"10px\");\n\n//                 // Add feature labels\n//                 if (j === 0) {\n//                     g.append(\"text\")\n//                         .attr(\"x\", size / 2)\n//                         .attr(\"y\", -padding / 2)\n//                         .attr(\"text-anchor\", \"middle\")\n//                         .style(\"font-size\", \"12px\")\n//                         .text(featX);\n//                 }\n//                 if (i === 0) {\n//                     g.append(\"text\")\n//                         .attr(\"transform\", \"rotate(-90)\")\n//                         .attr(\"x\", -size / 2)\n//                         .attr(\"y\", padding / 4)\n//                         .attr(\"text-anchor\", \"middle\")\n//                         .style(\"font-size\", \"12px\")\n//                         .text(featY);\n//                 }\n\n//                 // Add points or diagonal text\n//                 if (i === j) {\n//                     g.append(\"text\")\n//                         .attr(\"x\", size / 2)\n//                         .attr(\"y\", size / 2)\n//                         .attr(\"text-anchor\", \"middle\")\n//                         .attr(\"dominant-baseline\", \"middle\")\n//                         .style(\"font-size\", \"14px\")\n//                         .style(\"font-style\", \"italic\")\n//                         .text(featX);\n//                 } else {\n//                     g.selectAll(\"circle\")\n//                         .data(data.points)\n//                         .enter()\n//                         .append(\"circle\")\n//                         .attr(\"cx\", d => scales[i](d.features[featX]))\n//                         .attr(\"cy\", d => scales[j](d.features[featY]))\n//                         .attr(\"r\", 4)\n//                         .attr(\"fill\", d => colorScale(d.actual_label))\n//                         .attr(\"opacity\", 0.7)\n//                         .append(\"title\")\n//                         .text(d => `ID: ${d.Point_ID}\\nActual: ${d.actual_label}\\nPredicted: ${d.predicted_label}`);\n//                 }\n//             });\n//         });\n\n//         // Add legend\n//         const legend = svg.append(\"g\")\n//             .attr(\"transform\", `translate(${totalSize - 120}, ${padding})`);\n\n//         const uniqueLabels = [...new Set(data.points.map(d => d.actual_label))];\n//         uniqueLabels.forEach((label, i) => {\n//             const legendRow = legend.append(\"g\")\n//                 .attr(\"transform\", `translate(0, ${i * 20})`);\n\n//             legendRow.append(\"rect\")\n//                 .attr(\"width\", 12)\n//                 .attr(\"height\", 12)\n//                 .attr(\"fill\", colorScale(label));\n\n//             legendRow.append(\"text\")\n//                 .attr(\"x\", 18)\n//                 .attr(\"y\", 10)\n//                 .attr(\"fill\", \"black\")\n//                 .style(\"font-size\", \"12px\")\n//                 .text(label);\n//         });\n\n//     }, [data]);\n\n//     return (\n//         <div style={{ width: \"100%\", overflow: \"auto\", padding: \"20px\" }}>\n//             <svg ref={svgRef}></svg>\n//         </div>\n//     );\n// };\n\n// export default ScatterPlotMatrix;\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\n\nconst ScatterPlotMatrix = ({ data }) => {\n    const svgRef = useRef(null);\n    const containerRef = useRef(null);\n    const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n    const [selectedPoints, setSelectedPoints] = useState(new Set());\n\n    // Handle resize\n    useEffect(() => {\n        const updateDimensions = () => {\n            if (containerRef.current) {\n                const { width, height } = containerRef.current.getBoundingClientRect();\n                setDimensions({\n                    width: Math.max(width, 300), // Minimum width\n                    height: Math.max(height, 300) // Minimum height\n                });\n            }\n        };\n\n        updateDimensions();\n        window.addEventListener('resize', updateDimensions);\n        return () => window.removeEventListener('resize', updateDimensions);\n    }, []);\n\n    useEffect(() => {\n        if (!data || !data.points || !data.points.length) return;\n\n        const svg = d3.select(svgRef.current);\n        svg.selectAll(\"*\").remove();\n\n        const features = Object.keys(data.points[0].features);\n        const n = features.length;\n\n        // Responsive sizing\n        const padding = Math.max(40, dimensions.width * 0.05);\n        const size = Math.min(200, Math.floor((dimensions.width - padding) / n));\n        const totalSize = n * (size + padding);\n\n        svg.attr(\"width\", totalSize + padding)\n            .attr(\"height\", totalSize + padding);\n\n        const colorScale = d3\n            .scaleOrdinal(d3.schemeCategory10)\n            .domain([...new Set(data.points.map(d => d.actual_label))]);\n\n        // Create scales\n        const scales = features.map(feat => {\n            return d3.scaleLinear()\n                .domain(d3.extent(data.points, d => d.features[feat]))\n                .range([padding / 2, size - padding / 2])\n                .nice();\n        });\n\n        // Create matrix\n        features.forEach((featX, i) => {\n            features.forEach((featY, j) => {\n                const g = svg.append(\"g\")\n                    .attr(\"transform\", `translate(${i * (size + padding)}, ${j * (size + padding)})`);\n\n                g.append(\"rect\")\n                    .attr(\"width\", size)\n                    .attr(\"height\", size)\n                    .attr(\"fill\", \"#f5f5f5\");\n\n                // Axes\n                const xAxis = d3.axisBottom(scales[i])\n                    .ticks(Math.max(3, Math.floor(size / 50)))\n                    .tickFormat(d3.format(\".2f\"));\n\n                const yAxis = d3.axisLeft(scales[j])\n                    .ticks(Math.max(3, Math.floor(size / 50)))\n                    .tickFormat(d3.format(\".2f\"));\n\n                g.append(\"g\")\n                    .attr(\"transform\", `translate(0, ${size - padding / 2})`)\n                    .call(xAxis)\n                    .selectAll(\"text\")\n                    .style(\"font-size\", `${Math.max(8, size / 20)}px`);\n\n                g.append(\"g\")\n                    .attr(\"transform\", `translate(${padding / 2}, 0)`)\n                    .call(yAxis)\n                    .selectAll(\"text\")\n                    .style(\"font-size\", `${Math.max(8, size / 20)}px`);\n\n                // Labels\n                if (j === 0) {\n                    g.append(\"text\")\n                        .attr(\"x\", size / 2)\n                        .attr(\"y\", -padding / 2)\n                        .attr(\"text-anchor\", \"middle\")\n                        .style(\"font-size\", `${Math.max(10, size / 15)}px`)\n                        .text(featX);\n                }\n                if (i === 0) {\n                    g.append(\"text\")\n                        .attr(\"transform\", \"rotate(-90)\")\n                        .attr(\"x\", -size / 2)\n                        .attr(\"y\", padding / 4)\n                        .attr(\"text-anchor\", \"middle\")\n                        .style(\"font-size\", `${Math.max(10, size / 15)}px`)\n                        .text(featY);\n                }\n\n                // Points or diagonal text\n                if (i === j) {\n                    g.append(\"text\")\n                        .attr(\"x\", size / 2)\n                        .attr(\"y\", size / 2)\n                        .attr(\"text-anchor\", \"middle\")\n                        .attr(\"dominant-baseline\", \"middle\")\n                        .style(\"font-size\", `${Math.max(12, size / 12)}px`)\n                        .style(\"font-style\", \"italic\")\n                        .text(featX);\n                } else {\n                    const points = g.selectAll(\"circle\")\n                        .data(data.points)\n                        .enter()\n                        .append(\"circle\")\n                        .attr(\"cx\", d => scales[i](d.features[featX]))\n                        .attr(\"cy\", d => scales[j](d.features[featY]))\n                        .attr(\"r\", Math.max(3, size / 50))\n                        .attr(\"fill\", d => colorScale(d.actual_label))\n                        .attr(\"opacity\", d => selectedPoints.has(d.Point_ID) ? 1 : 0.7)\n                        .append(\"title\")\n                        .text(d => `ID: ${d.Point_ID}\\nActual: ${d.actual_label}\\nPredicted: ${d.predicted_label}`);\n\n                    // Add brushing\n                    const brush = d3.brush()\n                        .extent([[0, 0], [size, size]])\n                        .on(\"start brush end\", (event) => {\n                            if (event.selection) {\n                                const [[x0, y0], [x1, y1]] = event.selection;\n                                const selected = new Set();\n                                points.each(d => {\n                                    const x = scales[i](d.features[featX]);\n                                    const y = scales[j](d.features[featY]);\n                                    if (x >= x0 && x <= x1 && y >= y0 && y <= y1) {\n                                        selected.add(d.Point_ID);\n                                    }\n                                });\n                                setSelectedPoints(selected);\n                                points.attr(\"opacity\", d => selected.has(d.Point_ID) ? 1 : 0.3);\n                            } else {\n                                setSelectedPoints(new Set());\n                                points.attr(\"opacity\", 0.7);\n                            }\n                        });\n\n                    g.append(\"g\")\n                        .attr(\"class\", \"brush\")\n                        .call(brush);\n                }\n            });\n        });\n\n        // Legend\n        const legendWidth = Math.min(120, dimensions.width * 0.1);\n        const legend = svg.append(\"g\")\n            .attr(\"transform\", `translate(${totalSize - legendWidth - padding / 2}, ${padding})`);\n\n        const uniqueLabels = [...new Set(data.points.map(d => d.actual_label))];\n        const legendItemHeight = Math.max(20, size / 10);\n\n        if (legendWidth > 50 && uniqueLabels.length * legendItemHeight < totalSize - padding) {\n            uniqueLabels.forEach((label, i) => {\n                const legendRow = legend.append(\"g\")\n                    .attr(\"transform\", `translate(0, ${i * legendItemHeight})`);\n\n                legendRow.append(\"rect\")\n                    .attr(\"width\", legendWidth * 0.2)\n                    .attr(\"height\", legendWidth * 0.2)\n                    .attr(\"fill\", colorScale(label));\n\n                legendRow.append(\"text\")\n                    .attr(\"x\", legendWidth * 0.3)\n                    .attr(\"y\", legendWidth * 0.2 * 0.8)\n                    .attr(\"fill\", \"black\")\n                    .style(\"font-size\", `${Math.max(10, size / 15)}px`)\n                    .text(label);\n            });\n        }\n\n    }, [data, dimensions]);\n\n    return (\n        <div\n            ref={containerRef}\n            className=\"w-full h-full overflow-auto\"\n            style={{ minHeight: '300px', minWidth: '300px', padding: '20px' }}\n        >\n            <svg\n                ref={svgRef}\n                style={{\n                    width: '100%',\n                    height: '100%',\n                    minWidth: '100%',\n                    minHeight: '100%'\n                }}\n            />\n        </div>\n    );\n};\n\nexport default ScatterPlotMatrix;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}