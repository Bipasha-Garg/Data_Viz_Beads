{"ast":null,"code":"var _s = $RefreshSig$();\n// Here points are on boundary ________________________________________\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     // Dynamically extract subspace keys\n//     const subspaceKeys = Object.keys(jsonData);\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate center and square spacing\n//     const centerX = width / 2;\n//     const centerY = height / 2;\n//     const squareSpacing = 200; // Distance between consecutive squares\n\n//     const nodes = [];\n//     const links = [];\n\n//     // Function to calculate node positions on the square's perimeter\n//     const calculateSquarePerimeterPositions = (numPoints, squareIndex) => {\n//       const size = squareSpacing * (squareIndex + 1); // Square size grows with the index\n//       const positions = [];\n//       const pointsPerSide = Math.ceil(numPoints / 4);\n//       const sideLength = size;\n\n//       for (let i = 0; i < numPoints; i++) {\n//         const side = Math.floor(i / pointsPerSide); // Determine which side of the square\n//         const offset = i % pointsPerSide;\n//         let x, y;\n\n//         if (side === 0) {\n//           // Top side\n//           x = centerX - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//           y = centerY - sideLength / 2;\n//         } else if (side === 1) {\n//           // Right side\n//           x = centerX + sideLength / 2;\n//           y = centerY - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//         } else if (side === 2) {\n//           // Bottom side\n//           x = centerX + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//           y = centerY + sideLength / 2;\n//         } else {\n//           // Left side\n//           x = centerX - sideLength / 2;\n//           y = centerY + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//         }\n\n//         positions.push({ x, y });\n//       }\n//       return positions;\n//     };\n\n//     // Build hierarchical nodes and links\n//     subspaceKeys.forEach((subspace, index) => {\n//       const points = jsonData[subspace];\n//       const positions = calculateSquarePerimeterPositions(points.length, index);\n\n//       points.forEach((point, i) => {\n//         const id = `${subspace}-${i}`;\n//         const node = {\n//           id,\n//           ...point,\n//           x: positions[i].x,\n//           y: positions[i].y,\n//         };\n//         nodes.push(node);\n\n//         // Add links to the previous square\n//         if (index > 0) {\n//           links.push({\n//             source: nodes[nodes.length - points.length - i - 1].id,\n//             target: id,\n//           });\n//         }\n//       });\n//     });\n\n//     // Draw squares\n//     subspaceKeys.forEach((_, index) => {\n//       const size = squareSpacing * (index + 1);\n//       svg\n//         .append(\"rect\")\n//         .attr(\"x\", centerX - size / 2)\n//         .attr(\"y\", centerY - size / 2)\n//         .attr(\"width\", size)\n//         .attr(\"height\", size)\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 2);\n//     });\n\n//     // Draw links\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"x1\", (d) => nodes.find((node) => node.id === d.source)?.x)\n//       .attr(\"y1\", (d) => nodes.find((node) => node.id === d.source)?.y)\n//       .attr(\"x2\", (d) => nodes.find((node) => node.id === d.target)?.x)\n//       .attr(\"y2\", (d) => nodes.find((node) => node.id === d.target)?.y)\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 1);\n\n//     // Draw nodes\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"cx\", (d) => d.x)\n//       .attr(\"cy\", (d) => d.y)\n//       .attr(\"fill\", (d, i) =>\n//         i < jsonData[subspaceKeys[0]].length\n//           ? \"red\"\n//           : i < jsonData[subspaceKeys[1]].length\n//           ? \"blue\"\n//           : \"green\"\n//       )\n//       .on(\"mouseover\", (event, d) => {\n//         setHoveredCoordinates({\n//           ...d,\n//           id: d.id,\n//         });\n//       });\n\n//     // Add tooltips\n//     svg\n//       .selectAll(\"circle\")\n//       .append(\"title\")\n//       .text((d) => `ID: ${d.id}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n// // box mei points________________________________________\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     // Extract subspaces (keys like \"x\", \"xy\", \"xyz\") from jsonData\n//     const subspaces = Object.keys(jsonData);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width =400; // Canvas width\n//     const height =400; // Canvas height\n//     const margin = 20;\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Compute square sizes\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n//     const squareStep = maxSquareSize / (2 * subspaces.length);\n\n//     // Draw concentric squares\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\n//         \"transform\",\n//         `translate(${width / 2}, ${height / 2})` // Center alignment\n//       );\n\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize = maxSquareSize - 2 * index * squareStep;\n\n//       // Draw the square for the current subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke-width\", 1);\n\n//       // Scale for plotting points inside the current square\n//       const scaleX = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n//       const scaleY = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n\n//       // Plot the points for this subspace\n//       g.selectAll(`.point-${subspace.key}`)\n//         .data(subspace.points)\n//         .enter()\n//         .append(\"circle\")\n//         .attr(\"cx\", (d) => scaleX(d.x))\n//         .attr(\"cy\", (d) => (d.y !== undefined ? scaleY(d.y) : 0))\n//         .attr(\"r\", 4)\n//         .attr(\"fill\", \"steelblue\")\n//         .attr(\"stroke\", \"white\")\n//         .attr(\"stroke-width\", 1)\n//         .append(\"title\") // Tooltip for the point\n//         .text((d) => `ID: ${d.Point_ID}`);\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, // Length of the key determines the dimensions\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     // Start with largest square and reduce size for each subsequent subspace\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize =\n//         maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n//       const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n//       // Draw square for the subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke-width\", 1);\n\n//       // Draw sector lines (dividing the square into equal parts)\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = (squareSize / 2) * Math.cos(angle);\n//         const y1 = (squareSize / 2) * Math.sin(angle);\n\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"gray\")\n//           .attr(\"stroke-width\", 1);\n//       }\n\n//       // Scale for plotting points\n//       const scaleX = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n//       const scaleY = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n\n//       // Plot points within their respective square\n//       g.selectAll(`.point-${subspace.key}`)\n//         .data(subspace.points)\n//         .enter()\n//         .append(\"circle\")\n//         .attr(\"cx\", (d) => scaleX(d.x))\n//         .attr(\"cy\", (d) => scaleY(d.y || 0)) // Default y = 0 if not defined\n//         .attr(\"r\", 4)\n//         .attr(\"fill\", \"steelblue\")\n//         .attr(\"stroke\", \"white\")\n//         .attr(\"stroke-width\", 1)\n//         .append(\"title\")\n//         .text((d) => `ID: ${d.Point_ID}`);\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nconst HierarchicalGraph = ({\n  jsonData\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || Object.keys(jsonData).length === 0) return;\n    const subspaces = Object.keys(jsonData);\n    const pointsData = subspaces.map(key => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length // Length of the key determines the dimensions\n    }));\n    const svg = d3.select(graphRef.current);\n    const width = 600;\n    const height = 600;\n    const margin = 20;\n    svg.selectAll(\"*\").remove();\n    const maxSquareSize = Math.min(width, height) - 2 * margin;\n    const g = svg.attr(\"width\", width).attr(\"height\", height).append(\"g\").attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n    // Start with largest square and reduce size for each subsequent subspace\n    pointsData.forEach((subspace, index) => {\n      const squareSize = maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n      const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n      // Draw square for the subspace\n      g.append(\"rect\").attr(\"x\", -squareSize / 2).attr(\"y\", -squareSize / 2).attr(\"width\", squareSize).attr(\"height\", squareSize).attr(\"stroke\", \"black\").attr(\"fill\", \"none\").attr(\"stroke-width\", 1);\n\n      // Draw sector lines (dividing the square into equal parts)\n      for (let i = 0; i < sectors; i++) {\n        const angle = 2 * Math.PI * i / sectors;\n        const x1 = squareSize / 2 * Math.cos(angle);\n        const y1 = squareSize / 2 * Math.sin(angle);\n        g.append(\"line\").attr(\"x1\", 0).attr(\"y1\", 0).attr(\"x2\", x1).attr(\"y2\", y1).attr(\"stroke\", \"gray\").attr(\"stroke-width\", 1);\n      }\n\n      // Scale for plotting points\n      const scaleX = d3.scaleLinear().domain([-1, 1]).range([-squareSize / 2, squareSize / 2]);\n      const scaleY = d3.scaleLinear().domain([-1, 1]).range([-squareSize / 2, squareSize / 2]);\n\n      // Plot points within their respective square and sector\n      subspace.points.forEach(point => {\n        const bitPattern = point.Point_ID.toString(2).padStart(subspace.dimensions, \"0\");\n        const sectorIndex = parseInt(bitPattern, 2);\n        const sectorAngle = 2 * Math.PI * sectorIndex / sectors;\n        const radius = Math.sqrt(point.x ** 2 + (point.y || 0) ** 2);\n        const angle = Math.atan2(point.y || 0, point.x);\n        const scaledRadius = scaleX(radius * Math.cos(angle));\n        const scaledAngle = scaleY(radius * Math.sin(angle));\n        g.append(\"circle\").attr(\"cx\", scaledRadius).attr(\"cy\", scaledAngle).attr(\"r\", 4).attr(\"fill\", \"steelblue\").attr(\"stroke\", \"white\").attr(\"stroke-width\", 1).append(\"title\").text(`ID: ${point.Point_ID}`);\n      });\n    });\n  }, [jsonData]);\n\n  // return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n};\n_s(HierarchicalGraph, \"XNG/roOlNWxTF7ymftfdirhS32A=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","HierarchicalGraph","jsonData","_s","graphRef","Object","keys","length","subspaces","pointsData","map","key","points","dimensions","svg","select","current","width","height","margin","selectAll","remove","maxSquareSize","Math","min","g","attr","append","forEach","subspace","index","squareSize","sectors","i","angle","PI","x1","cos","y1","sin","scaleX","scaleLinear","domain","range","scaleY","point","bitPattern","Point_ID","toString","padStart","sectorIndex","parseInt","sectorAngle","radius","sqrt","x","y","atan2","scaledRadius","scaledAngle","text","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["// Here points are on boundary ________________________________________\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     // Dynamically extract subspace keys\n//     const subspaceKeys = Object.keys(jsonData);\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate center and square spacing\n//     const centerX = width / 2;\n//     const centerY = height / 2;\n//     const squareSpacing = 200; // Distance between consecutive squares\n\n//     const nodes = [];\n//     const links = [];\n\n//     // Function to calculate node positions on the square's perimeter\n//     const calculateSquarePerimeterPositions = (numPoints, squareIndex) => {\n//       const size = squareSpacing * (squareIndex + 1); // Square size grows with the index\n//       const positions = [];\n//       const pointsPerSide = Math.ceil(numPoints / 4);\n//       const sideLength = size;\n\n//       for (let i = 0; i < numPoints; i++) {\n//         const side = Math.floor(i / pointsPerSide); // Determine which side of the square\n//         const offset = i % pointsPerSide;\n//         let x, y;\n\n//         if (side === 0) {\n//           // Top side\n//           x = centerX - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//           y = centerY - sideLength / 2;\n//         } else if (side === 1) {\n//           // Right side\n//           x = centerX + sideLength / 2;\n//           y = centerY - sideLength / 2 + (offset / pointsPerSide) * sideLength;\n//         } else if (side === 2) {\n//           // Bottom side\n//           x = centerX + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//           y = centerY + sideLength / 2;\n//         } else {\n//           // Left side\n//           x = centerX - sideLength / 2;\n//           y = centerY + sideLength / 2 - (offset / pointsPerSide) * sideLength;\n//         }\n\n//         positions.push({ x, y });\n//       }\n//       return positions;\n//     };\n\n//     // Build hierarchical nodes and links\n//     subspaceKeys.forEach((subspace, index) => {\n//       const points = jsonData[subspace];\n//       const positions = calculateSquarePerimeterPositions(points.length, index);\n\n//       points.forEach((point, i) => {\n//         const id = `${subspace}-${i}`;\n//         const node = {\n//           id,\n//           ...point,\n//           x: positions[i].x,\n//           y: positions[i].y,\n//         };\n//         nodes.push(node);\n\n//         // Add links to the previous square\n//         if (index > 0) {\n//           links.push({\n//             source: nodes[nodes.length - points.length - i - 1].id,\n//             target: id,\n//           });\n//         }\n//       });\n//     });\n\n//     // Draw squares\n//     subspaceKeys.forEach((_, index) => {\n//       const size = squareSpacing * (index + 1);\n//       svg\n//         .append(\"rect\")\n//         .attr(\"x\", centerX - size / 2)\n//         .attr(\"y\", centerY - size / 2)\n//         .attr(\"width\", size)\n//         .attr(\"height\", size)\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 2);\n//     });\n\n//     // Draw links\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"x1\", (d) => nodes.find((node) => node.id === d.source)?.x)\n//       .attr(\"y1\", (d) => nodes.find((node) => node.id === d.source)?.y)\n//       .attr(\"x2\", (d) => nodes.find((node) => node.id === d.target)?.x)\n//       .attr(\"y2\", (d) => nodes.find((node) => node.id === d.target)?.y)\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 1);\n\n//     // Draw nodes\n//     svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"cx\", (d) => d.x)\n//       .attr(\"cy\", (d) => d.y)\n//       .attr(\"fill\", (d, i) =>\n//         i < jsonData[subspaceKeys[0]].length\n//           ? \"red\"\n//           : i < jsonData[subspaceKeys[1]].length\n//           ? \"blue\"\n//           : \"green\"\n//       )\n//       .on(\"mouseover\", (event, d) => {\n//         setHoveredCoordinates({\n//           ...d,\n//           id: d.id,\n//         });\n//       });\n\n//     // Add tooltips\n//     svg\n//       .selectAll(\"circle\")\n//       .append(\"title\")\n//       .text((d) => `ID: ${d.id}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n\n// // box mei points________________________________________\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     // Extract subspaces (keys like \"x\", \"xy\", \"xyz\") from jsonData\n//     const subspaces = Object.keys(jsonData);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width =400; // Canvas width\n//     const height =400; // Canvas height\n//     const margin = 20;\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Compute square sizes\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n//     const squareStep = maxSquareSize / (2 * subspaces.length);\n\n//     // Draw concentric squares\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\n//         \"transform\",\n//         `translate(${width / 2}, ${height / 2})` // Center alignment\n//       );\n\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize = maxSquareSize - 2 * index * squareStep;\n\n//       // Draw the square for the current subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke-width\", 1);\n\n//       // Scale for plotting points inside the current square\n//       const scaleX = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n//       const scaleY = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n\n//       // Plot the points for this subspace\n//       g.selectAll(`.point-${subspace.key}`)\n//         .data(subspace.points)\n//         .enter()\n//         .append(\"circle\")\n//         .attr(\"cx\", (d) => scaleX(d.x))\n//         .attr(\"cy\", (d) => (d.y !== undefined ? scaleY(d.y) : 0))\n//         .attr(\"r\", 4)\n//         .attr(\"fill\", \"steelblue\")\n//         .attr(\"stroke\", \"white\")\n//         .attr(\"stroke-width\", 1)\n//         .append(\"title\") // Tooltip for the point\n//         .text((d) => `ID: ${d.Point_ID}`);\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, // Length of the key determines the dimensions\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n\n//     const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     // Start with largest square and reduce size for each subsequent subspace\n//     pointsData.forEach((subspace, index) => {\n//       const squareSize =\n//         maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n//       const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n//       // Draw square for the subspace\n//       g.append(\"rect\")\n//         .attr(\"x\", -squareSize / 2)\n//         .attr(\"y\", -squareSize / 2)\n//         .attr(\"width\", squareSize)\n//         .attr(\"height\", squareSize)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", \"none\")\n//         .attr(\"stroke-width\", 1);\n\n//       // Draw sector lines (dividing the square into equal parts)\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = (squareSize / 2) * Math.cos(angle);\n//         const y1 = (squareSize / 2) * Math.sin(angle);\n\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"gray\")\n//           .attr(\"stroke-width\", 1);\n//       }\n\n//       // Scale for plotting points\n//       const scaleX = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n//       const scaleY = d3\n//         .scaleLinear()\n//         .domain([-1, 1])\n//         .range([-squareSize / 2, squareSize / 2]);\n\n//       // Plot points within their respective square\n//       g.selectAll(`.point-${subspace.key}`)\n//         .data(subspace.points)\n//         .enter()\n//         .append(\"circle\")\n//         .attr(\"cx\", (d) => scaleX(d.x))\n//         .attr(\"cy\", (d) => scaleY(d.y || 0)) // Default y = 0 if not defined\n//         .attr(\"r\", 4)\n//         .attr(\"fill\", \"steelblue\")\n//         .attr(\"stroke\", \"white\")\n//         .attr(\"stroke-width\", 1)\n//         .append(\"title\")\n//         .text((d) => `ID: ${d.Point_ID}`);\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n\n\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData }) => {\n  const graphRef = useRef(null);\n\n  useEffect(() => {\n    if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n    const subspaces = Object.keys(jsonData);\n    const pointsData = subspaces.map((key) => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length, // Length of the key determines the dimensions\n    }));\n\n    const svg = d3.select(graphRef.current);\n    const width = 600;\n    const height = 600;\n    const margin = 20;\n\n    svg.selectAll(\"*\").remove();\n\n    const maxSquareSize = Math.min(width, height) - 2 * margin;\n\n    const g = svg\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .append(\"g\")\n      .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n    // Start with largest square and reduce size for each subsequent subspace\n    pointsData.forEach((subspace, index) => {\n      const squareSize =\n        maxSquareSize - 2 * index * (maxSquareSize / subspaces.length);\n      const sectors = 2 ** subspace.dimensions; // Number of sectors\n\n      // Draw square for the subspace\n      g.append(\"rect\")\n        .attr(\"x\", -squareSize / 2)\n        .attr(\"y\", -squareSize / 2)\n        .attr(\"width\", squareSize)\n        .attr(\"height\", squareSize)\n        .attr(\"stroke\", \"black\")\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke-width\", 1);\n\n      // Draw sector lines (dividing the square into equal parts)\n      for (let i = 0; i < sectors; i++) {\n        const angle = (2 * Math.PI * i) / sectors;\n        const x1 = (squareSize / 2) * Math.cos(angle);\n        const y1 = (squareSize / 2) * Math.sin(angle);\n\n        g.append(\"line\")\n          .attr(\"x1\", 0)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", x1)\n          .attr(\"y2\", y1)\n          .attr(\"stroke\", \"gray\")\n          .attr(\"stroke-width\", 1);\n      }\n\n      // Scale for plotting points\n      const scaleX = d3\n        .scaleLinear()\n        .domain([-1, 1])\n        .range([-squareSize / 2, squareSize / 2]);\n      const scaleY = d3\n        .scaleLinear()\n        .domain([-1, 1])\n        .range([-squareSize / 2, squareSize / 2]);\n\n      // Plot points within their respective square and sector\n      subspace.points.forEach((point) => {\n        const bitPattern = point.Point_ID.toString(2).padStart(\n          subspace.dimensions,\n          \"0\"\n        );\n        const sectorIndex = parseInt(bitPattern, 2);\n        const sectorAngle = (2 * Math.PI * sectorIndex) / sectors;\n\n        const radius = Math.sqrt(point.x ** 2 + (point.y || 0) ** 2);\n        const angle = Math.atan2(point.y || 0, point.x);\n\n        const scaledRadius = scaleX(radius * Math.cos(angle));\n        const scaledAngle = scaleY(radius * Math.sin(angle));\n\n        g.append(\"circle\")\n          .attr(\"cx\", scaledRadius)\n          .attr(\"cy\", scaledAngle)\n          .attr(\"r\", 4)\n          .attr(\"fill\", \"steelblue\")\n          .attr(\"stroke\", \"white\")\n          .attr(\"stroke-width\", 1)\n          .append(\"title\")\n          .text(`ID: ${point.Point_ID}`);\n      });\n    });\n  }, [jsonData]);\n\n  // return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n};\n\nexport default HierarchicalGraph;"],"mappings":";AAAA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}