{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point,\n//           bitVector: assignBitVector(point), });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(20)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-100))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n//       )\n\n//       .force(\"charge\", d3.forceManyBody().strength(-10))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  coordinateKeys\n}) => {\n  _s();\n  const svgRef = useRef();\n\n  // Helper function to calculate the centroid of a set of points\n  const calculateCentroid = points => {\n    const centroid = {};\n    points.forEach(point => {\n      coordinateKeys.forEach(key => {\n        centroid[key] = (centroid[key] || 0) + point[key];\n      });\n    });\n    coordinateKeys.forEach(key => {\n      centroid[key] /= points.length;\n    });\n    return centroid;\n  };\n\n  // Helper function to calculate Euclidean distance\n  const calculateEuclideanDistance = (p1, p2, keys) => {\n    return Math.sqrt(keys.reduce((sum, key) => sum + Math.pow(p1[key] - p2[key], 2), 0));\n  };\n\n  // Helper function to assign a bit vector based on coordinate values\n  const assignBitVector = point => {\n    return coordinateKeys.map(key => point[key] != null && point[key] >= 0 ? \"1\" : \"0\").join(\"\");\n  };\n  useEffect(() => {\n    const svg = d3.select(svgRef.current);\n    svg.selectAll(\"*\").remove(); // Clear previous content\n\n    // Parse JSON data to calculate centroids and relationships\n    const beads = d3.group(jsonData, d => `${d.cluster}-${d.bead}`);\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      const centroid = calculateCentroid(points);\n      return {\n        id: `bead-${cluster}-${bead}`,\n        cluster,\n        bead,\n        centroid,\n        points,\n        bitVector: assignBitVector(centroid)\n      };\n    });\n    const clusterCentroids = d3.group(beadCentroids, d => d.cluster).map(([cluster, beads]) => {\n      const centroid = calculateCentroid(beads.map(b => b.centroid));\n      return {\n        id: `cluster-${cluster}`,\n        cluster,\n        centroid,\n        beads,\n        bitVector: assignBitVector(centroid)\n      };\n    });\n    const rootCentroid = calculateCentroid(clusterCentroids.map(c => c.centroid));\n    const rootBitVector = assignBitVector(rootCentroid);\n\n    // Nodes and links for the hierarchical graph\n    const nodes = [{\n      id: \"root\",\n      ...rootCentroid,\n      bitVector: rootBitVector\n    }, ...clusterCentroids.map(({\n      cluster,\n      centroid,\n      bitVector\n    }) => ({\n      id: `cluster-${cluster}`,\n      ...centroid,\n      bitVector\n    })), ...beadCentroids.map(bead => ({\n      id: bead.id,\n      ...bead.centroid,\n      bitVector: bead.bitVector\n    }))];\n    const links = [...clusterCentroids.map(c => ({\n      source: \"root\",\n      target: c.id\n    })), ...beadCentroids.map(b => ({\n      source: `cluster-${b.cluster}`,\n      target: b.id\n    }))];\n\n    // Force simulation setup\n    const simulation = d3.forceSimulation(nodes).force(\"link\", d3.forceLink(links).id(d => d.id).distance(100)).force(\"charge\", d3.forceManyBody().strength(-300)).force(\"center\", d3.forceCenter(500, 300)).on(\"tick\", () => {\n      svg.selectAll(\"line\").data(links).join(\"line\").attr(\"x1\", d => d.source.x).attr(\"y1\", d => d.source.y).attr(\"x2\", d => d.target.x).attr(\"y2\", d => d.target.y).attr(\"stroke\", \"#aaa\");\n      svg.selectAll(\"circle\").data(nodes).join(\"circle\").attr(\"r\", 10).attr(\"cx\", d => d.x).attr(\"cy\", d => d.y).attr(\"fill\", d => d.id === \"root\" ? \"red\" : \"steelblue\").append(\"title\").text(d => `ID: ${d.id}\\nBit Vector: ${d.bitVector}\\nCoordinates: ${JSON.stringify(d)}`);\n    });\n    return () => simulation.stop(); // Clean up simulation on unmount\n  }, [jsonData, coordinateKeys]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: svgRef,\n    width: 1000,\n    height: 600\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 359,\n    columnNumber: 10\n  }, this);\n};\n_s(HierarchicalGraph, \"89Ty783ABEwsfMbSOeu9vscWF34=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","coordinateKeys","_s","svgRef","calculateCentroid","points","centroid","forEach","point","key","length","calculateEuclideanDistance","p1","p2","keys","Math","sqrt","reduce","sum","pow","assignBitVector","map","join","svg","select","current","selectAll","remove","beads","group","d","cluster","bead","beadCentroids","Array","from","split","id","bitVector","clusterCentroids","b","rootCentroid","c","rootBitVector","nodes","links","source","target","simulation","forceSimulation","force","forceLink","distance","forceManyBody","strength","forceCenter","on","data","attr","x","y","append","text","JSON","stringify","stop","ref","width","height","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point,\n//           bitVector: assignBitVector(point), });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(20)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-100))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n//       )\n\n//       .force(\"charge\", d3.forceManyBody().strength(-10))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, coordinateKeys }) => {\n  const svgRef = useRef();\n\n  // Helper function to calculate the centroid of a set of points\n  const calculateCentroid = (points) => {\n    const centroid = {};\n    points.forEach((point) => {\n      coordinateKeys.forEach((key) => {\n        centroid[key] = (centroid[key] || 0) + point[key];\n      });\n    });\n    coordinateKeys.forEach((key) => {\n      centroid[key] /= points.length;\n    });\n    return centroid;\n  };\n\n  // Helper function to calculate Euclidean distance\n  const calculateEuclideanDistance = (p1, p2, keys) => {\n    return Math.sqrt(\n      keys.reduce((sum, key) => sum + Math.pow(p1[key] - p2[key], 2), 0)\n    );\n  };\n\n  // Helper function to assign a bit vector based on coordinate values\n  const assignBitVector = (point) => {\n    return coordinateKeys\n      .map((key) => (point[key] != null && point[key] >= 0 ? \"1\" : \"0\"))\n      .join(\"\");\n  };\n\n  useEffect(() => {\n    const svg = d3.select(svgRef.current);\n    svg.selectAll(\"*\").remove(); // Clear previous content\n\n    // Parse JSON data to calculate centroids and relationships\n    const beads = d3.group(jsonData, (d) => `${d.cluster}-${d.bead}`);\n\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      const centroid = calculateCentroid(points);\n      return {\n        id: `bead-${cluster}-${bead}`,\n        cluster,\n        bead,\n        centroid,\n        points,\n        bitVector: assignBitVector(centroid),\n      };\n    });\n\n    const clusterCentroids = d3\n      .group(beadCentroids, (d) => d.cluster)\n      .map(([cluster, beads]) => {\n        const centroid = calculateCentroid(beads.map((b) => b.centroid));\n        return {\n          id: `cluster-${cluster}`,\n          cluster,\n          centroid,\n          beads,\n          bitVector: assignBitVector(centroid),\n        };\n      });\n\n    const rootCentroid = calculateCentroid(\n      clusterCentroids.map((c) => c.centroid)\n    );\n    const rootBitVector = assignBitVector(rootCentroid);\n\n    // Nodes and links for the hierarchical graph\n    const nodes = [\n      { id: \"root\", ...rootCentroid, bitVector: rootBitVector },\n      ...clusterCentroids.map(({ cluster, centroid, bitVector }) => ({\n        id: `cluster-${cluster}`,\n        ...centroid,\n        bitVector,\n      })),\n      ...beadCentroids.map((bead) => ({\n        id: bead.id,\n        ...bead.centroid,\n        bitVector: bead.bitVector,\n      })),\n    ];\n\n    const links = [\n      ...clusterCentroids.map((c) => ({\n        source: \"root\",\n        target: c.id,\n      })),\n      ...beadCentroids.map((b) => ({\n        source: `cluster-${b.cluster}`,\n        target: b.id,\n      })),\n    ];\n\n    // Force simulation setup\n    const simulation = d3\n      .forceSimulation(nodes)\n      .force(\n        \"link\",\n        d3\n          .forceLink(links)\n          .id((d) => d.id)\n          .distance(100)\n      )\n      .force(\"charge\", d3.forceManyBody().strength(-300))\n      .force(\"center\", d3.forceCenter(500, 300))\n      .on(\"tick\", () => {\n        svg\n          .selectAll(\"line\")\n          .data(links)\n          .join(\"line\")\n          .attr(\"x1\", (d) => d.source.x)\n          .attr(\"y1\", (d) => d.source.y)\n          .attr(\"x2\", (d) => d.target.x)\n          .attr(\"y2\", (d) => d.target.y)\n          .attr(\"stroke\", \"#aaa\");\n\n        svg\n          .selectAll(\"circle\")\n          .data(nodes)\n          .join(\"circle\")\n          .attr(\"r\", 10)\n          .attr(\"cx\", (d) => d.x)\n          .attr(\"cy\", (d) => d.y)\n          .attr(\"fill\", (d) => (d.id === \"root\" ? \"red\" : \"steelblue\"))\n          .append(\"title\")\n          .text(\n            (d) =>\n              `ID: ${d.id}\\nBit Vector: ${\n                d.bitVector\n              }\\nCoordinates: ${JSON.stringify(d)}`\n          );\n      });\n\n    return () => simulation.stop(); // Clean up simulation on unmount\n  }, [jsonData, coordinateKeys]);\n\n  return <svg ref={svgRef} width={1000} height={600}></svg>;\n};\n\nexport default HierarchicalGraph;\n"],"mappings":";;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAO,KAAKC,EAAE,MAAM,IAAI;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEzB,MAAMC,iBAAiB,GAAGA,CAAC;EAAEC,QAAQ;EAAEC;AAAe,CAAC,KAAK;EAAAC,EAAA;EAC1D,MAAMC,MAAM,GAAGR,MAAM,CAAC,CAAC;;EAEvB;E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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}