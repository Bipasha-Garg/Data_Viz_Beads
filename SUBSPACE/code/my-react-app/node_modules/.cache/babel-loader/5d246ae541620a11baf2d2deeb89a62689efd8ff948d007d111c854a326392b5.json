{"ast":null,"code":"\n// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // // //     const subspaces = Object.keys(jsonData);\n// // // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // // //     const pointsData = subspaces.map((key) => ({\n// // // //       key,\n// // // //       points: jsonData[key],\n// // // //       dimensions: key.length,\n// // // //       subspaceId: key,\n// // // //     }));\n\n// // // //     const svg = d3.select(graphRef.current);\n// // // //     const width = 800;\n// // // //     const height = 800;\n// // // //     const margin = 20;\n\n// // // //     svg.selectAll(\"*\").remove();\n// // // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // // //     const g = svg\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .append(\"g\")\n// // // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // // //     // Tooltip container\n// // // //     const tooltip = d3\n// // // //       .select(\"body\")\n// // // //       .append(\"div\")\n// // // //       .attr(\"class\", \"tooltip\")\n// // // //       .style(\"position\", \"absolute\")\n// // // //       .style(\"visibility\", \"hidden\")\n// // // //       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n// // // //       .style(\"color\", \"white\")\n// // // //       .style(\"padding\", \"5px\")\n// // // //       .style(\"border-radius\", \"4px\")\n// // // //       .style(\"font-size\", \"12px\");\n\n// // // //     pointsData.forEach((subspace, index) => {\n// // // //       const innerRadius = (index / subspaces.length) * maxRadius;\n// // // //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// // // //       const sectors = 2 ** (index+1); // Number of sectors based on subspace dimensions\n// // // //       const colorScale = d3\n// // // //         .scaleOrdinal()\n// // // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// // // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // // //       // Draw the outer circle representing the subspace\n// // // //       g.append(\"circle\")\n// // // //         .attr(\"r\", outerRadius)\n// // // //         .attr(\"stroke\", \"black\")\n// // // //         .attr(\"fill\", subspaceColor)\n// // // //         .attr(\"fill-opacity\", 0.2)\n// // // //         .attr(\"stroke-width\", 2)\n// // // //         .style(\"pointer-events\", \"none\"); // Ensure circles do not block hover\n\n// // // //       // Draw the radial lines dividing the sectors\n// // // //       for (let i = 0; i < sectors; i++) {\n// // // //         const angle = (2 * Math.PI * i) / sectors;\n// // // //         const x1 = outerRadius * Math.cos(angle);\n// // // //         const y1 = outerRadius * Math.sin(angle);\n// // // //         g.append(\"line\")\n// // // //           .attr(\"x1\", 0)\n// // // //           .attr(\"y1\", 0)\n// // // //           .attr(\"x2\", x1)\n// // // //           .attr(\"y2\", y1)\n// // // //           .attr(\"stroke\", \"black\")\n// // // //           .attr(\"stroke-width\", 1)\n// // // //           .style(\"pointer-events\", \"none\"); // Ensure radial lines do not block hover\n// // // //       }\n\n// // // //       // Place points inside the subspace with bit vectors\n// // // //       subspace.points.forEach((point) => {\n// // // //         // Exclude Point_ID from bit vector calculation if present\n// // // //         const pointData = Object.entries(point).filter(\n// // // //           ([key]) => key !== \"Point_ID\"\n// // // //         );\n\n// // // //         // Generate bit vector for all coordinates excluding Point_ID\n// // // //         const bitVector = pointData\n// // // //           .map(([key, coord]) => (coord >= 0 ? 1 : 0)) // 1 if positive, 0 if negative\n// // // //           .join(\"\"); // Combine into a bit vector string\n\n// // // //         // Calculate inner and outer radius for placement\n// // // //         const minRadius = innerRadius;\n// // // //         const maxRadius = outerRadius;\n// // // //         const randomRadius =\n// // // //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// // // //         // Calculate the angle for the sector based on the bit vector\n// // // //         const bitVectorIndex = parseInt(bitVector, 2); // Convert bit vector to a decimal number (sector index)\n// // // //         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n// // // //         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n\n// // // //         // Generate a random angle within the sector's angular range\n// // // //         const randomAngle =\n// // // //           angleStart + Math.random() * (angleEnd - angleStart);\n\n// // // //         // Position based on the calculated angle and random radius\n// // // //         const x = randomRadius * Math.cos(randomAngle);\n// // // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // // //         // Create a circle for each point and make sure they are on top\n// // // //         const pointElement = g\n// // // //           .append(\"circle\")\n// // // //           .attr(\"cx\", x)\n// // // //           .attr(\"cy\", y)\n// // // //           .attr(\"r\", 4)\n// // // //           .attr(\"fill\", \"black\")\n// // // //           .attr(\"stroke\", \"white\")\n// // // //           .attr(\"stroke-width\", 0.5)\n// // // //           .style(\"pointer-events\", \"visible\") // Make points interactive\n// // // //           .on(\"mouseover\", (event) => {\n// // // //             tooltip.style(\"visibility\", \"visible\").html(`\n// // // //                 <strong>Bit Vector:</strong> ${bitVector}<br>\n// // // //                 <strong>Coordinates:</strong> (${pointData\n// // // //                   .map(([key, coord]) => `${key}: ${coord}`)\n// // // //                   .join(\", \")})\n// // // //               `);\n// // // //           })\n// // // //           .on(\"mousemove\", (event) => {\n// // // //             tooltip\n// // // //               .style(\"top\", event.pageY + 10 + \"px\")\n// // // //               .style(\"left\", event.pageX + 10 + \"px\");\n// // // //           })\n// // // //           .on(\"mouseout\", () => {\n// // // //             tooltip.style(\"visibility\", \"hidden\");\n// // // //           });\n// // // //       });\n// // // //     });\n// // // //   }, [jsonData]);\n\n// // // //   return (\n// // // //     <>\n// // // //       <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>\n// // // //     </>\n// // // //   );\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // //     const subspaces = Object.keys(jsonData);\n// // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // //     const pointsData = subspaces.map((key) => ({\n// // //       key,\n// // //       points: jsonData[key],\n// // //       dimensions: key.length,\n// // //       subspaceId: key,\n// // //     }));\n\n// // //     const svg = d3.select(graphRef.current);\n// // //     const width = 800;\n// // //     const height = 800;\n// // //     const margin = 20;\n\n// // //     svg.selectAll(\"*\").remove();\n// // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // //     const g = svg\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .append(\"g\")\n// // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // //     const pointPositions = {}; // Store positions of points by Point_ID\n\n// // //     const tooltip = d3\n// // //       .select(\"body\")\n// // //       .append(\"div\")\n// // //       .attr(\"class\", \"tooltip\")\n// // //       .style(\"position\", \"absolute\")\n// // //       .style(\"visibility\", \"hidden\")\n// // //       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n// // //       .style(\"color\", \"white\")\n// // //       .style(\"padding\", \"5px\")\n// // //       .style(\"border-radius\", \"4px\")\n// // //       .style(\"font-size\", \"12px\");\n\n// // //     pointsData.forEach((subspace, index) => {\n// // //       const innerRadius = (index / subspaces.length) * maxRadius;\n// // //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// // //       const sectors = 2 ** (index + 1);\n// // //       const colorScale = d3\n// // //         .scaleOrdinal()\n// // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // //       g.append(\"circle\")\n// // //         .attr(\"r\", outerRadius)\n// // //         .attr(\"stroke\", \"black\")\n// // //         .attr(\"fill\", subspaceColor)\n// // //         .attr(\"fill-opacity\", 0.2)\n// // //         .attr(\"stroke-width\", 2)\n// // //         .style(\"pointer-events\", \"none\");\n\n// // //       for (let i = 0; i < sectors; i++) {\n// // //         const angle = (2 * Math.PI * i) / sectors;\n// // //         const x1 = outerRadius * Math.cos(angle);\n// // //         const y1 = outerRadius * Math.sin(angle);\n// // //         g.append(\"line\")\n// // //           .attr(\"x1\", 0)\n// // //           .attr(\"y1\", 0)\n// // //           .attr(\"x2\", x1)\n// // //           .attr(\"y2\", y1)\n// // //           .attr(\"stroke\", \"black\")\n// // //           .attr(\"stroke-width\", 1)\n// // //           .style(\"pointer-events\", \"none\");\n// // //       }\n\n// // //       subspace.points.forEach((point) => {\n// // //         const pointData = Object.entries(point).filter(\n// // //           ([key]) => key !== \"Point_ID\"\n// // //         );\n// // //         const bitVector = pointData\n// // //           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n// // //           .join(\"\");\n\n// // //         const minRadius = innerRadius;\n// // //         const maxRadius = outerRadius;\n// // //         const randomRadius =\n// // //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// // //         const bitVectorIndex = parseInt(bitVector, 2);\n// // //         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n// // //         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n// // //         const randomAngle =\n// // //           angleStart + Math.random() * (angleEnd - angleStart);\n\n// // //         const x = randomRadius * Math.cos(randomAngle);\n// // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // //         if (!pointPositions[point.Point_ID]) {\n// // //           pointPositions[point.Point_ID] = [];\n// // //         }\n// // //         pointPositions[point.Point_ID].push({ x, y });\n\n// // //         g.append(\"circle\")\n// // //           .attr(\"cx\", x)\n// // //           .attr(\"cy\", y)\n// // //           .attr(\"r\", 4)\n// // //           .attr(\"fill\", \"black\")\n// // //           .attr(\"stroke\", \"white\")\n// // //           .attr(\"stroke-width\", 0.5)\n// // //           .style(\"pointer-events\", \"visible\")\n// // //           .on(\"mouseover\", (event) => {\n// // //             tooltip\n// // //               .style(\"visibility\", \"visible\")\n// // //               .text(`Point_ID: ${point.Point_ID}`);\n// // //           })\n// // //           .on(\"mousemove\", (event) => {\n// // //             tooltip\n// // //               .style(\"top\", event.pageY + 10 + \"px\")\n// // //               .style(\"left\", event.pageX + 10 + \"px\");\n// // //           })\n// // //           .on(\"mouseout\", () => {\n// // //             tooltip.style(\"visibility\", \"hidden\");\n// // //           });\n// // //       });\n// // //     });\n\n// // //     Object.values(pointPositions).forEach((positions) => {\n// // //       if (positions.length > 1) {\n// // //         for (let i = 0; i < positions.length - 1; i++) {\n// // //           g.append(\"line\")\n// // //             .attr(\"x1\", positions[i].x)\n// // //             .attr(\"y1\", positions[i].y)\n// // //             .attr(\"x2\", positions[i + 1].x)\n// // //             .attr(\"y2\", positions[i + 1].y)\n// // //             .attr(\"stroke\", \"red\")\n// // //             .attr(\"stroke-width\", 1.5)\n// // //             .on(\"mouseover\", (event) => {\n// // //               tooltip\n// // //                 .style(\"visibility\", \"visible\")\n// // //                 .text(\"Connection between points\");\n// // //             })\n// // //             .on(\"mousemove\", (event) => {\n// // //               tooltip\n// // //                 .style(\"top\", event.pageY + 10 + \"px\")\n// // //                 .style(\"left\", event.pageX + 10 + \"px\");\n// // //             })\n// // //             .on(\"mouseout\", () => {\n// // //               tooltip.style(\"visibility\", \"hidden\");\n// // //             });\n// // //         }\n// // //       }\n// // //     });\n// // //   }, [jsonData]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// //     const subspaces = Object.keys(jsonData);\n// //     subspaces.sort((a, b) => a.length - b.length);\n\n// //     const pointsData = subspaces.map((key) => ({\n// //       key,\n// //       points: jsonData[key],\n// //       dimensions: key.length,\n// //       subspaceId: key,\n// //     }));\n\n// //     const svg = d3.select(graphRef.current);\n// //     const width = 800;\n// //     const height = 800;\n// //     const margin = 20;\n\n// //     svg.selectAll(\"*\").remove();\n// //     const maxRadius = Math.min(width, height) / 2 - margin;\n// //     const g = svg\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .append(\"g\")\n// //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// //     const pointPositions = {}; // Store positions of points by Point_ID\n\n// //     const tooltip = d3\n// //       .select(\"body\")\n// //       .append(\"div\")\n// //       .attr(\"class\", \"tooltip\")\n// //       .style(\"position\", \"absolute\")\n// //       .style(\"visibility\", \"hidden\")\n// //       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n// //       .style(\"color\", \"white\")\n// //       .style(\"padding\", \"5px\")\n// //       .style(\"border-radius\", \"4px\")\n// //       .style(\"font-size\", \"12px\");\n\n// //     pointsData.forEach((subspace, index) => {\n// //       const innerRadius = (index / subspaces.length) * maxRadius;\n// //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// //       const sectors = 2 ** (index + 1);\n// //       const colorScale = d3\n// //         .scaleOrdinal()\n// //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// //       g.append(\"circle\")\n// //         .attr(\"r\", outerRadius)\n// //         .attr(\"stroke\", \"black\")\n// //         .attr(\"fill\", subspaceColor)\n// //         .attr(\"fill-opacity\", 0.2)\n// //         .attr(\"stroke-width\", 2)\n// //         .style(\"pointer-events\", \"none\");\n\n// //       for (let i = 0; i < sectors; i++) {\n// //         const angle = (2 * Math.PI * i) / sectors;\n// //         const x1 = outerRadius * Math.cos(angle);\n// //         const y1 = outerRadius * Math.sin(angle);\n// //         g.append(\"line\")\n// //           .attr(\"x1\", 0)\n// //           .attr(\"y1\", 0)\n// //           .attr(\"x2\", x1)\n// //           .attr(\"y2\", y1)\n// //           .attr(\"stroke\", \"black\")\n// //           .attr(\"stroke-width\", 1)\n// //           .style(\"pointer-events\", \"none\");\n// //       }\n\n// //       subspace.points.forEach((point) => {\n// //         const pointData = Object.entries(point).filter(\n// //           ([key]) => key !== \"Point_ID\"\n// //         );\n// //         const bitVector = pointData\n// //           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n// //           .join(\"\");\n\n// //         const minRadius = innerRadius;\n// //         const maxRadius = outerRadius;\n// //         const randomRadius =\n// //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// //         const bitVectorIndex = parseInt(bitVector, 2);\n// //         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n// //         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n// //         const randomAngle =\n// //           angleStart + Math.random() * (angleEnd - angleStart);\n\n// //         const x = randomRadius * Math.cos(randomAngle);\n// //         const y = randomRadius * Math.sin(randomAngle);\n\n// //         if (!pointPositions[point.Point_ID]) {\n// //           pointPositions[point.Point_ID] = [];\n// //         }\n// //         pointPositions[point.Point_ID].push({ x, y, point });\n\n// //         g.append(\"circle\")\n// //           .attr(\"cx\", x)\n// //           .attr(\"cy\", y)\n// //           .attr(\"r\", 4)\n// //           .attr(\"fill\", \"black\")\n// //           .attr(\"stroke\", \"white\")\n// //           .attr(\"stroke-width\", 0.5)\n// //           .style(\"pointer-events\", \"visible\")\n// //           .on(\"mouseover\", (event) => {\n// //             tooltip\n// //               .style(\"visibility\", \"visible\")\n// //               .html(\n// //                 `Point_ID: ${point.Point_ID}<br>Coordinates: (${x.toFixed(\n// //                   2\n// //                 )}, ${y.toFixed(2)})`\n// //               );\n// //             setHoveredCoordinates(point);\n// //           })\n// //           .on(\"mousemove\", (event) => {\n// //             tooltip\n// //               .style(\"top\", event.pageY + 10 + \"px\")\n// //               .style(\"left\", event.pageX + 10 + \"px\");\n// //           })\n// //           .on(\"mouseout\", () => {\n// //             tooltip.style(\"visibility\", \"hidden\");\n// //             setHoveredCoordinates(null);\n// //           });\n// //       });\n// //     });\n\n// //     Object.values(pointPositions).forEach((positions) => {\n// //       if (positions.length > 1) {\n// //         for (let i = 0; i < positions.length - 1; i++) {\n// //           g.append(\"line\")\n// //             .attr(\"x1\", positions[i].x)\n// //             .attr(\"y1\", positions[i].y)\n// //             .attr(\"x2\", positions[i + 1].x)\n// //             .attr(\"y2\", positions[i + 1].y)\n// //             .attr(\"stroke\", \"red\")\n// //             .attr(\"stroke-width\", 0.3)\n// //             .on(\"mouseover\", (event) => {\n// //               tooltip\n// //                 .style(\"visibility\", \"visible\")\n// //                 .html(`Connection: Point_ID ${positions[i].point.Point_ID}`);\n// //             })\n// //             .on(\"mousemove\", (event) => {\n// //               tooltip\n// //                 .style(\"top\", event.pageY + 10 + \"px\")\n// //                 .style(\"left\", event.pageX + 10 + \"px\");\n// //             })\n// //             .on(\"mouseout\", () => {\n// //               tooltip.style(\"visibility\", \"hidden\");\n// //             });\n// //         }\n// //       }\n// //     });\n// //   }, [jsonData, setHoveredCoordinates]);\n\n// //   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const zoom = d3\n//       .zoom()\n//       .scaleExtent([0.5, 5])\n//       .on(\"zoom\", (event) => {\n//         g.attr(\"transform\", event.transform);\n//       });\n\n//     svg.call(zoom);\n\n//     const pointPositions = {};\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     pointsData.forEach((subspace, index) => {\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1);\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n//       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n//       g.append(\"circle\")\n//         .attr(\"r\", outerRadius)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2)\n//         .attr(\"stroke-width\", 2)\n//         .style(\"pointer-events\", \"none\");\n\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 1)\n//           .style(\"pointer-events\", \"none\");\n//       }\n\n//       subspace.points.forEach((point) => {\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n//           .join(\"\");\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         const bitVectorIndex = parseInt(bitVector, 2);\n//         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n//         const randomAngle =\n//           angleStart + Math.random() * (angleEnd - angleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         if (!pointPositions[point.Point_ID]) {\n//           pointPositions[point.Point_ID] = [];\n//         }\n//         pointPositions[point.Point_ID].push({ x, y, point });\n//       });\n//     });\n\n//     Object.values(pointPositions).forEach((points) => {\n//       for (let i = 0; i < points.length - 1; i++) {\n//         g.append(\"line\")\n//           .attr(\"x1\", points[i].x)\n//           .attr(\"y1\", points[i].y)\n//           .attr(\"x2\", points[i + 1].x)\n//           .attr(\"y2\", points[i + 1].y)\n//           .attr(\"stroke\", \"blue\")\n//           .attr(\"stroke-width\", 0.1)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(`Point_ID: ${points[i].point.Point_ID}`);\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//           });\n//       }\n//     });\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;","map":{"version":3,"names":[],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // // //     const subspaces = Object.keys(jsonData);\n// // // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // // //     const pointsData = subspaces.map((key) => ({\n// // // //       key,\n// // // //       points: jsonData[key],\n// // // //       dimensions: key.length,\n// // // //       subspaceId: key,\n// // // //     }));\n\n// // // //     const svg = d3.select(graphRef.current);\n// // // //     const width = 800;\n// // // //     const height = 800;\n// // // //     const margin = 20;\n\n// // // //     svg.selectAll(\"*\").remove();\n// // // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // // //     const g = svg\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .append(\"g\")\n// // // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // // //     // Tooltip container\n// // // //     const tooltip = d3\n// // // //       .select(\"body\")\n// // // //       .append(\"div\")\n// // // //       .attr(\"class\", \"tooltip\")\n// // // //       .style(\"position\", \"absolute\")\n// // // //       .style(\"visibility\", \"hidden\")\n// // // //       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n// // // //       .style(\"color\", \"white\")\n// // // //       .style(\"padding\", \"5px\")\n// // // //       .style(\"border-radius\", \"4px\")\n// // // //       .style(\"font-size\", \"12px\");\n\n// // // //     pointsData.forEach((subspace, index) => {\n// // // //       const innerRadius = (index / subspaces.length) * maxRadius;\n// // // //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// // // //       const sectors = 2 ** (index+1); // Number of sectors based on subspace dimensions\n// // // //       const colorScale = d3\n// // // //         .scaleOrdinal()\n// // // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// // // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // // //       // Draw the outer circle representing the subspace\n// // // //       g.append(\"circle\")\n// // // //         .attr(\"r\", outerRadius)\n// // // //         .attr(\"stroke\", \"black\")\n// // // //         .attr(\"fill\", subspaceColor)\n// // // //         .attr(\"fill-opacity\", 0.2)\n// // // //         .attr(\"stroke-width\", 2)\n// // // //         .style(\"pointer-events\", \"none\"); // Ensure circles do not block hover\n\n// // // //       // Draw the radial lines dividing the sectors\n// // // //       for (let i = 0; i < sectors; i++) {\n// // // //         const angle = (2 * Math.PI * i) / sectors;\n// // // //         const x1 = outerRadius * Math.cos(angle);\n// // // //         const y1 = outerRadius * Math.sin(angle);\n// // // //         g.append(\"line\")\n// // // //           .attr(\"x1\", 0)\n// // // //           .attr(\"y1\", 0)\n// // // //           .attr(\"x2\", x1)\n// // // //           .attr(\"y2\", y1)\n// // // //           .attr(\"stroke\", \"black\")\n// // // //           .attr(\"stroke-width\", 1)\n// // // //           .style(\"pointer-events\", \"none\"); // Ensure radial lines do not block hover\n// // // //       }\n\n// // // //       // Place points inside the subspace with bit vectors\n// // // //       subspace.points.forEach((point) => {\n// // // //         // Exclude Point_ID from bit vector calculation if present\n// // // //         const pointData = Object.entries(point).filter(\n// // // //           ([key]) => key !== \"Point_ID\"\n// // // //         );\n\n// // // //         // Generate bit vector for all coordinates excluding Point_ID\n// // // //         const bitVector = pointData\n// // // //           .map(([key, coord]) => (coord >= 0 ? 1 : 0)) // 1 if positive, 0 if negative\n// // // //           .join(\"\"); // Combine into a bit vector string\n\n// // // //         // Calculate inner and outer radius for placement\n// // // //         const minRadius = innerRadius;\n// // // //         const maxRadius = outerRadius;\n// // // //         const randomRadius =\n// // // //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// // // //         // Calculate the angle for the sector based on the bit vector\n// // // //         const bitVectorIndex = parseInt(bitVector, 2); // Convert bit vector to a decimal number (sector index)\n// // // //         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n// // // //         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n\n// // // //         // Generate a random angle within the sector's angular range\n// // // //         const randomAngle =\n// // // //           angleStart + Math.random() * (angleEnd - angleStart);\n\n// // // //         // Position based on the calculated angle and random radius\n// // // //         const x = randomRadius * Math.cos(randomAngle);\n// // // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // // //         // Create a circle for each point and make sure they are on top\n// // // //         const pointElement = g\n// // // //           .append(\"circle\")\n// // // //           .attr(\"cx\", x)\n// // // //           .attr(\"cy\", y)\n// // // //           .attr(\"r\", 4)\n// // // //           .attr(\"fill\", \"black\")\n// // // //           .attr(\"stroke\", \"white\")\n// // // //           .attr(\"stroke-width\", 0.5)\n// // // //           .style(\"pointer-events\", \"visible\") // Make points interactive\n// // // //           .on(\"mouseover\", (event) => {\n// // // //             tooltip.style(\"visibility\", \"visible\").html(`\n// // // //                 <strong>Bit Vector:</strong> ${bitVector}<br>\n// // // //                 <strong>Coordinates:</strong> (${pointData\n// // // //                   .map(([key, coord]) => `${key}: ${coord}`)\n// // // //                   .join(\", \")})\n// // // //               `);\n// // // //           })\n// // // //           .on(\"mousemove\", (event) => {\n// // // //             tooltip\n// // // //               .style(\"top\", event.pageY + 10 + \"px\")\n// // // //               .style(\"left\", event.pageX + 10 + \"px\");\n// // // //           })\n// // // //           .on(\"mouseout\", () => {\n// // // //             tooltip.style(\"visibility\", \"hidden\");\n// // // //           });\n// // // //       });\n// // // //     });\n// // // //   }, [jsonData]);\n\n// // // //   return (\n// // // //     <>\n// // // //       <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>\n// // // //     </>\n// // // //   );\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// // //     const subspaces = Object.keys(jsonData);\n// // //     subspaces.sort((a, b) => a.length - b.length);\n\n// // //     const pointsData = subspaces.map((key) => ({\n// // //       key,\n// // //       points: jsonData[key],\n// // //       dimensions: key.length,\n// // //       subspaceId: key,\n// // //     }));\n\n// // //     const svg = d3.select(graphRef.current);\n// // //     const width = 800;\n// // //     const height = 800;\n// // //     const margin = 20;\n\n// // //     svg.selectAll(\"*\").remove();\n// // //     const maxRadius = Math.min(width, height) / 2 - margin;\n// // //     const g = svg\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .append(\"g\")\n// // //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// // //     const pointPositions = {}; // Store positions of points by Point_ID\n\n// // //     const tooltip = d3\n// // //       .select(\"body\")\n// // //       .append(\"div\")\n// // //       .attr(\"class\", \"tooltip\")\n// // //       .style(\"position\", \"absolute\")\n// // //       .style(\"visibility\", \"hidden\")\n// // //       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n// // //       .style(\"color\", \"white\")\n// // //       .style(\"padding\", \"5px\")\n// // //       .style(\"border-radius\", \"4px\")\n// // //       .style(\"font-size\", \"12px\");\n\n// // //     pointsData.forEach((subspace, index) => {\n// // //       const innerRadius = (index / subspaces.length) * maxRadius;\n// // //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// // //       const sectors = 2 ** (index + 1);\n// // //       const colorScale = d3\n// // //         .scaleOrdinal()\n// // //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// // //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// // //       g.append(\"circle\")\n// // //         .attr(\"r\", outerRadius)\n// // //         .attr(\"stroke\", \"black\")\n// // //         .attr(\"fill\", subspaceColor)\n// // //         .attr(\"fill-opacity\", 0.2)\n// // //         .attr(\"stroke-width\", 2)\n// // //         .style(\"pointer-events\", \"none\");\n\n// // //       for (let i = 0; i < sectors; i++) {\n// // //         const angle = (2 * Math.PI * i) / sectors;\n// // //         const x1 = outerRadius * Math.cos(angle);\n// // //         const y1 = outerRadius * Math.sin(angle);\n// // //         g.append(\"line\")\n// // //           .attr(\"x1\", 0)\n// // //           .attr(\"y1\", 0)\n// // //           .attr(\"x2\", x1)\n// // //           .attr(\"y2\", y1)\n// // //           .attr(\"stroke\", \"black\")\n// // //           .attr(\"stroke-width\", 1)\n// // //           .style(\"pointer-events\", \"none\");\n// // //       }\n\n// // //       subspace.points.forEach((point) => {\n// // //         const pointData = Object.entries(point).filter(\n// // //           ([key]) => key !== \"Point_ID\"\n// // //         );\n// // //         const bitVector = pointData\n// // //           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n// // //           .join(\"\");\n\n// // //         const minRadius = innerRadius;\n// // //         const maxRadius = outerRadius;\n// // //         const randomRadius =\n// // //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// // //         const bitVectorIndex = parseInt(bitVector, 2);\n// // //         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n// // //         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n// // //         const randomAngle =\n// // //           angleStart + Math.random() * (angleEnd - angleStart);\n\n// // //         const x = randomRadius * Math.cos(randomAngle);\n// // //         const y = randomRadius * Math.sin(randomAngle);\n\n// // //         if (!pointPositions[point.Point_ID]) {\n// // //           pointPositions[point.Point_ID] = [];\n// // //         }\n// // //         pointPositions[point.Point_ID].push({ x, y });\n\n// // //         g.append(\"circle\")\n// // //           .attr(\"cx\", x)\n// // //           .attr(\"cy\", y)\n// // //           .attr(\"r\", 4)\n// // //           .attr(\"fill\", \"black\")\n// // //           .attr(\"stroke\", \"white\")\n// // //           .attr(\"stroke-width\", 0.5)\n// // //           .style(\"pointer-events\", \"visible\")\n// // //           .on(\"mouseover\", (event) => {\n// // //             tooltip\n// // //               .style(\"visibility\", \"visible\")\n// // //               .text(`Point_ID: ${point.Point_ID}`);\n// // //           })\n// // //           .on(\"mousemove\", (event) => {\n// // //             tooltip\n// // //               .style(\"top\", event.pageY + 10 + \"px\")\n// // //               .style(\"left\", event.pageX + 10 + \"px\");\n// // //           })\n// // //           .on(\"mouseout\", () => {\n// // //             tooltip.style(\"visibility\", \"hidden\");\n// // //           });\n// // //       });\n// // //     });\n\n// // //     Object.values(pointPositions).forEach((positions) => {\n// // //       if (positions.length > 1) {\n// // //         for (let i = 0; i < positions.length - 1; i++) {\n// // //           g.append(\"line\")\n// // //             .attr(\"x1\", positions[i].x)\n// // //             .attr(\"y1\", positions[i].y)\n// // //             .attr(\"x2\", positions[i + 1].x)\n// // //             .attr(\"y2\", positions[i + 1].y)\n// // //             .attr(\"stroke\", \"red\")\n// // //             .attr(\"stroke-width\", 1.5)\n// // //             .on(\"mouseover\", (event) => {\n// // //               tooltip\n// // //                 .style(\"visibility\", \"visible\")\n// // //                 .text(\"Connection between points\");\n// // //             })\n// // //             .on(\"mousemove\", (event) => {\n// // //               tooltip\n// // //                 .style(\"top\", event.pageY + 10 + \"px\")\n// // //                 .style(\"left\", event.pageX + 10 + \"px\");\n// // //             })\n// // //             .on(\"mouseout\", () => {\n// // //               tooltip.style(\"visibility\", \"hidden\");\n// // //             });\n// // //         }\n// // //       }\n// // //     });\n// // //   }, [jsonData]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n// //     const subspaces = Object.keys(jsonData);\n// //     subspaces.sort((a, b) => a.length - b.length);\n\n// //     const pointsData = subspaces.map((key) => ({\n// //       key,\n// //       points: jsonData[key],\n// //       dimensions: key.length,\n// //       subspaceId: key,\n// //     }));\n\n// //     const svg = d3.select(graphRef.current);\n// //     const width = 800;\n// //     const height = 800;\n// //     const margin = 20;\n\n// //     svg.selectAll(\"*\").remove();\n// //     const maxRadius = Math.min(width, height) / 2 - margin;\n// //     const g = svg\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .append(\"g\")\n// //       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n// //     const pointPositions = {}; // Store positions of points by Point_ID\n\n// //     const tooltip = d3\n// //       .select(\"body\")\n// //       .append(\"div\")\n// //       .attr(\"class\", \"tooltip\")\n// //       .style(\"position\", \"absolute\")\n// //       .style(\"visibility\", \"hidden\")\n// //       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n// //       .style(\"color\", \"white\")\n// //       .style(\"padding\", \"5px\")\n// //       .style(\"border-radius\", \"4px\")\n// //       .style(\"font-size\", \"12px\");\n\n// //     pointsData.forEach((subspace, index) => {\n// //       const innerRadius = (index / subspaces.length) * maxRadius;\n// //       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n// //       const sectors = 2 ** (index + 1);\n// //       const colorScale = d3\n// //         .scaleOrdinal()\n// //         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n// //       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n// //       g.append(\"circle\")\n// //         .attr(\"r\", outerRadius)\n// //         .attr(\"stroke\", \"black\")\n// //         .attr(\"fill\", subspaceColor)\n// //         .attr(\"fill-opacity\", 0.2)\n// //         .attr(\"stroke-width\", 2)\n// //         .style(\"pointer-events\", \"none\");\n\n// //       for (let i = 0; i < sectors; i++) {\n// //         const angle = (2 * Math.PI * i) / sectors;\n// //         const x1 = outerRadius * Math.cos(angle);\n// //         const y1 = outerRadius * Math.sin(angle);\n// //         g.append(\"line\")\n// //           .attr(\"x1\", 0)\n// //           .attr(\"y1\", 0)\n// //           .attr(\"x2\", x1)\n// //           .attr(\"y2\", y1)\n// //           .attr(\"stroke\", \"black\")\n// //           .attr(\"stroke-width\", 1)\n// //           .style(\"pointer-events\", \"none\");\n// //       }\n\n// //       subspace.points.forEach((point) => {\n// //         const pointData = Object.entries(point).filter(\n// //           ([key]) => key !== \"Point_ID\"\n// //         );\n// //         const bitVector = pointData\n// //           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n// //           .join(\"\");\n\n// //         const minRadius = innerRadius;\n// //         const maxRadius = outerRadius;\n// //         const randomRadius =\n// //           minRadius + Math.random() * (maxRadius - minRadius);\n\n// //         const bitVectorIndex = parseInt(bitVector, 2);\n// //         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n// //         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n// //         const randomAngle =\n// //           angleStart + Math.random() * (angleEnd - angleStart);\n\n// //         const x = randomRadius * Math.cos(randomAngle);\n// //         const y = randomRadius * Math.sin(randomAngle);\n\n// //         if (!pointPositions[point.Point_ID]) {\n// //           pointPositions[point.Point_ID] = [];\n// //         }\n// //         pointPositions[point.Point_ID].push({ x, y, point });\n\n// //         g.append(\"circle\")\n// //           .attr(\"cx\", x)\n// //           .attr(\"cy\", y)\n// //           .attr(\"r\", 4)\n// //           .attr(\"fill\", \"black\")\n// //           .attr(\"stroke\", \"white\")\n// //           .attr(\"stroke-width\", 0.5)\n// //           .style(\"pointer-events\", \"visible\")\n// //           .on(\"mouseover\", (event) => {\n// //             tooltip\n// //               .style(\"visibility\", \"visible\")\n// //               .html(\n// //                 `Point_ID: ${point.Point_ID}<br>Coordinates: (${x.toFixed(\n// //                   2\n// //                 )}, ${y.toFixed(2)})`\n// //               );\n// //             setHoveredCoordinates(point);\n// //           })\n// //           .on(\"mousemove\", (event) => {\n// //             tooltip\n// //               .style(\"top\", event.pageY + 10 + \"px\")\n// //               .style(\"left\", event.pageX + 10 + \"px\");\n// //           })\n// //           .on(\"mouseout\", () => {\n// //             tooltip.style(\"visibility\", \"hidden\");\n// //             setHoveredCoordinates(null);\n// //           });\n// //       });\n// //     });\n\n// //     Object.values(pointPositions).forEach((positions) => {\n// //       if (positions.length > 1) {\n// //         for (let i = 0; i < positions.length - 1; i++) {\n// //           g.append(\"line\")\n// //             .attr(\"x1\", positions[i].x)\n// //             .attr(\"y1\", positions[i].y)\n// //             .attr(\"x2\", positions[i + 1].x)\n// //             .attr(\"y2\", positions[i + 1].y)\n// //             .attr(\"stroke\", \"red\")\n// //             .attr(\"stroke-width\", 0.3)\n// //             .on(\"mouseover\", (event) => {\n// //               tooltip\n// //                 .style(\"visibility\", \"visible\")\n// //                 .html(`Connection: Point_ID ${positions[i].point.Point_ID}`);\n// //             })\n// //             .on(\"mousemove\", (event) => {\n// //               tooltip\n// //                 .style(\"top\", event.pageY + 10 + \"px\")\n// //                 .style(\"left\", event.pageX + 10 + \"px\");\n// //             })\n// //             .on(\"mouseout\", () => {\n// //               tooltip.style(\"visibility\", \"hidden\");\n// //             });\n// //         }\n// //       }\n// //     });\n// //   }, [jsonData, setHoveredCoordinates]);\n\n// //   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const zoom = d3\n//       .zoom()\n//       .scaleExtent([0.5, 5])\n//       .on(\"zoom\", (event) => {\n//         g.attr(\"transform\", event.transform);\n//       });\n\n//     svg.call(zoom);\n\n//     const pointPositions = {};\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     pointsData.forEach((subspace, index) => {\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1);\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n//       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n//       g.append(\"circle\")\n//         .attr(\"r\", outerRadius)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2)\n//         .attr(\"stroke-width\", 2)\n//         .style(\"pointer-events\", \"none\");\n\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", 0)\n//           .attr(\"y1\", 0)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 1)\n//           .style(\"pointer-events\", \"none\");\n//       }\n\n//       subspace.points.forEach((point) => {\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n//           .join(\"\");\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         const bitVectorIndex = parseInt(bitVector, 2);\n//         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n//         const randomAngle =\n//           angleStart + Math.random() * (angleEnd - angleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         if (!pointPositions[point.Point_ID]) {\n//           pointPositions[point.Point_ID] = [];\n//         }\n//         pointPositions[point.Point_ID].push({ x, y, point });\n//       });\n//     });\n\n//     Object.values(pointPositions).forEach((points) => {\n//       for (let i = 0; i < points.length - 1; i++) {\n//         g.append(\"line\")\n//           .attr(\"x1\", points[i].x)\n//           .attr(\"y1\", points[i].y)\n//           .attr(\"x2\", points[i + 1].x)\n//           .attr(\"y2\", points[i + 1].y)\n//           .attr(\"stroke\", \"blue\")\n//           .attr(\"stroke-width\", 0.1)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(`Point_ID: ${points[i].point.Point_ID}`);\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//           });\n//       }\n//     });\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;"],"mappings":";AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}