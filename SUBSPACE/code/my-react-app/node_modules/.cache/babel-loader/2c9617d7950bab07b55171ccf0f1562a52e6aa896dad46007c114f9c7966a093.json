{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || jsonData.length === 0) return;\n\n// // //     // Dynamically extract coordinate keys (dimensions)\n// // //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// // //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// // //     );\n\n// // //     // Helper to calculate centroid\n// // //     const calculateCentroid = (points) => {\n// // //       const n = points.length;\n// // //       const sum = points.reduce((acc, point) => {\n// // //         coordinateKeys.forEach((key) => {\n// // //           acc[key] = (acc[key] || 0) + point[key];\n// // //         });\n// // //         return acc;\n// // //       }, {});\n// // //       // Compute average for each dimension\n// // //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// // //       return sum;\n// // //     };\n// // //     // Assign bit vectors based on coordinate keys (planes)\n// // //     const assignBitVector = (point) => {\n// // //       return coordinateKeys\n// // //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// // //         .join(\"\");\n// // //     };\n// // //     // Parse and process data\n// // //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// // //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// // //     // Root centroid\n// // //     const rootCentroid = calculateCentroid(jsonData);\n\n// // //     // Cluster centroids\n// // //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// // //       cluster,\n// // //       centroid: calculateCentroid(points),\n// // //     }));\n\n// // //     // Bead centroids\n// // //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// // //       const [cluster, bead] = key.split(\"-\");\n// // //       return {\n// // //         cluster,\n// // //         bead,\n// // //         centroid: calculateCentroid(points),\n// // //         points,\n// // //       };\n// // //     });\n\n// // //     // Build hierarchical links\n// // //     const links = [];\n// // //     const nodes = [\n// // //       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n// // //     ];\n\n// // //     // Add cluster nodes and links\n// // //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// // //       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n// // //         bitVector: assignBitVector(centroid), });\n// // //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// // //     });\n\n// // //     // Add bead nodes and links\n// // //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// // //       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n// // //         bitVector: assignBitVector(centroid), });\n// // //       links.push({\n// // //         source: `cluster-${cluster}`,\n// // //         target: `bead-${cluster}-${bead}`,\n// // //       });\n\n// // //       // Add individual points and links\n// // //       points.forEach((point, index) => {\n// // //         const pointId = `point-${cluster}-${bead}-${index}`;\n// // //         nodes.push({ id: pointId, ...point,\n// // //           bitVector: assignBitVector(point), });\n// // //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// // //       });\n// // //     });\n\n// // //     // Set up container dimensions\n// // //     const container = d3.select(graphRef.current.parentNode);\n// // //     const width = container.node().getBoundingClientRect().width;\n// // //     const height = container.node().getBoundingClientRect().height;\n// // //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// // //     const svg = d3\n// // //       .select(graphRef.current)\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// // //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// // //     // Clear previous render\n// // //     svg.selectAll(\"*\").remove();\n\n// // //     // Force simulation\n// // //     const simulation = d3\n// // //       .forceSimulation(nodes)\n// // //       .force(\n// // //         \"link\",\n// // //         d3\n// // //           .forceLink(links)\n// // //           .id((d) => d.id)\n// // //           .distance(-10)\n// // //       )\n// // //       .force(\"charge\", d3.forceManyBody().strength(1))\n// // //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// // //       .force(\n// // //         \"collision\",\n// // //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// // //       )\n\n// // //       .force(\"charge\", d3.forceManyBody().strength( 3))\n// // //       .force(\n// // //         \"center\",\n// // //         d3.forceCenter(\n// // //           (width - margin.left - margin.right) / 2,\n// // //           (height - margin.top - margin.bottom) / 2\n// // //         )\n// // //       )\n// // //       .on(\"tick\", () => {\n// // //         link\n// // //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// // //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// // //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// // //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// // //         node\n// // //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// // //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// // //       });\n\n// // //     // Clamp function to restrict within bounds\n// // //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// // //     // Draw links\n// // //     const link = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"links\")\n// // //       .selectAll(\"line\")\n// // //       .data(links)\n// // //       .enter()\n// // //       .append(\"line\")\n// // //       .attr(\"stroke\", \"#aaa\")\n// // //       .attr(\"stroke-width\", 2);\n\n// // //     // Draw nodes\n// // //     const node = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"nodes\")\n// // //       .selectAll(\"circle\")\n// // //       .data(nodes)\n// // //       .enter()\n// // //       .append(\"circle\")\n// // //       .attr(\"r\", 5)\n// // //       .attr(\"fill\", (d) => {\n// // //         if (d.id === \"root\") return \"red\";\n// // //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// // //         if (d.id.startsWith(\"bead\")) return \"green\";\n// // //         return \"gray\";\n// // //       })\n\n// // //       .on(\"mouseover\", (event, d) => {\n// // //         // Create an object to hold all coordinate values\n// // //         const coordinates = {};\n\n// // //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// // //         coordinateKeys.forEach((key) => {\n// // //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// // //         });\n\n// // //         // Pass the full coordinates to the parent component\n// // //         setHoveredCoordinates({\n// // //           ...coordinates,\n// // //           id: d.id,\n// // //           bitVector: d.bitVector,\n// // //         });\n// // //       })\n\n// // //       .call(\n// // //         d3\n// // //           .drag()\n// // //           .on(\"start\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// // //             event.subject.fx = event.subject.x;\n// // //             event.subject.fy = event.subject.y;\n// // //           })\n// // //           .on(\"drag\", (event) => {\n// // //             event.subject.fx = event.x;\n// // //             event.subject.fy = event.y;\n// // //           })\n// // //           .on(\"end\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0);\n// // //             event.subject.fx = null;\n// // //             event.subject.fy = null;\n// // //           })\n// // //       );\n\n// // //     // Add tooltips\n// // //     // node.append(\"title\").text((d) => d.id);\n// // //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// // //   }, [jsonData, setHoveredCoordinates]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n\n// // // _____________________________________placement acc x and y bit vectors_________________________________\n\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || jsonData.length === 0) return;\n\n// //     // Dynamically extract coordinate keys (dimensions)\n// //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// //     );\n\n// //     // Helper to calculate centroid\n// //     const calculateCentroid = (points) => {\n// //       const n = points.length;\n// //       const sum = points.reduce((acc, point) => {\n// //         coordinateKeys.forEach((key) => {\n// //           acc[key] = (acc[key] || 0) + point[key];\n// //         });\n// //         return acc;\n// //       }, {});\n// //       // Compute average for each dimension\n// //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// //       return sum;\n// //     };\n// //     // Assign bit vectors based on coordinate keys (planes)\n// //     const assignBitVector = (point) => {\n// //       return coordinateKeys\n// //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// //         .join(\"\");\n// //     };\n// //     // Parse and process data\n// //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// //     // Root centroid\n// //     const rootCentroid = calculateCentroid(jsonData);\n\n// //     // Cluster centroids\n// //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// //       cluster,\n// //       centroid: calculateCentroid(points),\n// //     }));\n\n// //     // Bead centroids\n// //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// //       const [cluster, bead] = key.split(\"-\");\n// //       return {\n// //         cluster,\n// //         bead,\n// //         centroid: calculateCentroid(points),\n// //         points,\n// //       };\n// //     });\n\n// //     // Build hierarchical links\n// //     const links = [];\n// //     const nodes = [\n// //       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n// //     ];\n\n// //     // Add cluster nodes and links\n// //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// //       nodes.push({\n// //         id: `cluster-${cluster}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// //     });\n\n// //     // Add bead nodes and links\n// //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// //       nodes.push({\n// //         id: `bead-${cluster}-${bead}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({\n// //         source: `cluster-${cluster}`,\n// //         target: `bead-${cluster}-${bead}`,\n// //       });\n\n// //       // Add individual points and links\n// //       points.forEach((point, index) => {\n// //         const pointId = `point-${cluster}-${bead}-${index}`;\n// //         nodes.push({\n// //           id: pointId,\n// //           ...point,\n// //           bitVector: assignBitVector(point),\n// //         });\n// //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// //       });\n// //     });\n\n// //     // Set up container dimensions\n// //     const container = d3.select(graphRef.current.parentNode);\n// //     const width = container.node().getBoundingClientRect().width;\n// //     const height = container.node().getBoundingClientRect().height;\n// //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// //     const svg = d3\n// //       .select(graphRef.current)\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// //     // Clear previous render\n// //     svg.selectAll(\"*\").remove();\n\n// //     // Calculate initial positions based on bit vectors\n// //     nodes.forEach((node) => {\n// //       if (node.bitVector) {\n// //         // Avoid undefined case\n// //         let x = 0;\n// //         let y = 0;\n\n// //         for (let i = 0; i < coordinateKeys.length; i++) {\n// //           const key = coordinateKeys[i];\n// //           const bit = node.bitVector[i];\n// //           const dimensionMultiplier = 100; // You can increase or decrease this to change spread between clusters\n\n// //           // Use the dimensionMultiplier and add more multiplier if more than one dimension\n// //           x +=\n// //             (bit === \"1\"\n// //               ? dimensionMultiplier * 1.5\n// //               : -dimensionMultiplier * 1.5) *\n// //             (i + 1);\n// //           y +=\n// //             (bit === \"1\"\n// //               ? dimensionMultiplier * 1.5\n// //               : -dimensionMultiplier * 1.5) *\n// //             (i + 1);\n// //         }\n\n// //         node.x = x + width / 2;\n// //         node.y = y + height / 2;\n// //       }\n// //     });\n\n// //     // Force simulation\n// //     const simulation = d3\n// //       .forceSimulation(nodes)\n// //       .force(\n// //         \"link\",\n// //         d3\n// //           .forceLink(links)\n// //           .id((d) => d.id)\n// //           .distance(-10)\n// //       )\n// //       .force(\"charge\", d3.forceManyBody().strength(1))\n// //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// //       .force(\n// //         \"collision\",\n// //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// //       )\n\n// //       .force(\"charge\", d3.forceManyBody().strength(3))\n// //       .force(\n// //         \"center\",\n// //         d3.forceCenter(\n// //           (width - margin.left - margin.right) / 2,\n// //           (height - margin.top - margin.bottom) / 2\n// //         )\n// //       )\n// //       .on(\"tick\", () => {\n// //         link\n// //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// //         node\n// //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// //       });\n\n// //     // Clamp function to restrict within bounds\n// //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// //     // Draw links\n// //     const link = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"links\")\n// //       .selectAll(\"line\")\n// //       .data(links)\n// //       .enter()\n// //       .append(\"line\")\n// //       .attr(\"stroke\", \"#aaa\")\n// //       .attr(\"stroke-width\", 2);\n\n// //     // Draw nodes\n// //     const node = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"nodes\")\n// //       .selectAll(\"circle\")\n// //       .data(nodes)\n// //       .enter()\n// //       .append(\"circle\")\n// //       .attr(\"r\", 5)\n// //       .attr(\"fill\", (d) => {\n// //         if (d.id === \"root\") return \"red\";\n// //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// //         if (d.id.startsWith(\"bead\")) return \"green\";\n// //         return \"gray\";\n// //       })\n\n// //       .on(\"mouseover\", (event, d) => {\n// //         // Create an object to hold all coordinate values\n// //         const coordinates = {};\n\n// //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// //         coordinateKeys.forEach((key) => {\n// //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// //         });\n\n// //         // Pass the full coordinates to the parent component\n// //         setHoveredCoordinates({\n// //           ...coordinates,\n// //           id: d.id,\n// //           bitVector: d.bitVector,\n// //         });\n// //       })\n\n// //       .call(\n// //         d3\n// //           .drag()\n// //           .on(\"start\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// //             event.subject.fx = event.subject.x;\n// //             event.subject.fy = event.subject.y;\n// //           })\n// //           .on(\"drag\", (event) => {\n// //             event.subject.fx = event.x;\n// //             event.subject.fy = event.y;\n// //           })\n// //           .on(\"end\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0);\n// //             event.subject.fx = null;\n// //             event.subject.fy = null;\n// //           })\n// //       );\n\n// //     // Add tooltips\n// //     // node.append(\"title\").text((d) => d.id);\n// //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// //   }, [jsonData, setHoveredCoordinates]);\n\n// //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n\n// // _______________________________________________________QUANDRANT POSITIONING WITH SIMULATION_________________\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({\n//         id: `cluster-${cluster}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//       });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({\n//         id: `bead-${cluster}-${bead}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//       });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({\n//           id: pointId,\n//           ...point,\n//           bitVector: assignBitVector(point),\n//         });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate the number of quadrants based on the number of dimensions\n//     const numDimensions = coordinateKeys.length;\n//     const numQuadrants = 2 ** numDimensions;\n\n//     // Calculate initial positions based on bit vectors\n//     nodes.forEach((node) => {\n//       if (node.bitVector) {\n//         // Convert the bit vector to a decimal number\n//         const quadrantIndex = parseInt(node.bitVector, 2);\n\n//         // Calculate quadrant size and starting position\n//         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//         const numCols = Math.ceil(numQuadrants / numRows);\n//         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//         const row = Math.floor(quadrantIndex / numCols);\n//         const col = quadrantIndex % numCols;\n\n//         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n//         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n//         node.x = x;\n//         node.y = y;\n//       }\n//     });\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(-10)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(1))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15))\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(3))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       {\n//         id: \"root\",\n//         ...rootCentroid,\n//         bitVector: assignBitVector(rootCentroid),\n//         isCentroid: true,\n//       }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({\n//         id: `cluster-${cluster}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({\n//         id: `bead-${cluster}-${bead}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({\n//           id: pointId,\n//           ...point,\n//           bitVector: assignBitVector(point),\n//           isCentroid: false,\n//         });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate the number of quadrants based on the number of dimensions\n//     const numDimensions = coordinateKeys.length;\n//     const numQuadrants = 2 ** numDimensions;\n\n//     // Calculate initial positions based on bit vectors\n//     nodes.forEach((node) => {\n//       if (node.bitVector) {\n//         // Convert the bit vector to a decimal number\n//         const quadrantIndex = parseInt(node.bitVector, 2);\n\n//         // Calculate quadrant size and starting position\n//         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//         const numCols = Math.ceil(numQuadrants / numRows);\n//         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//         const row = Math.floor(quadrantIndex / numCols);\n//         const col = quadrantIndex % numCols;\n\n//         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n//         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n//         node.x = x;\n//         node.y = y;\n//       }\n//     });\n\n//     // Draw grid lines\n//     const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//     const numCols = Math.ceil(numQuadrants / numRows);\n//     const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//     const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//     const grid = svg.append(\"g\").attr(\"class\", \"grid\");\n\n//     // Draw vertical lines\n//     for (let i = 0; i <= numCols; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left + i * quadrantWidth)\n//         .attr(\"y1\", margin.top)\n//         .attr(\"x2\", margin.left + i * quadrantWidth)\n//         .attr(\"y2\", height - margin.bottom)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Draw horizontal lines\n//     for (let i = 0; i <= numRows; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left)\n//         .attr(\"y1\", margin.top + i * quadrantHeight)\n//         .attr(\"x2\", width - margin.right)\n//         .attr(\"y2\", margin.top + i * quadrantHeight)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(-10)\n//       )\n//       .force(\n//         \"charge\",\n//         d3.forceManyBody().strength((d) => (d.isCentroid ? -20 : 1))\n//       )\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.isCentroid ? 10 : 5))\n//       )\n\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) =>\n//             clamp(d.source.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y1\", (d) =>\n//             clamp(d.source.y, margin.top, height - margin.bottom)\n//           )\n//           .attr(\"x2\", (d) =>\n//             clamp(d.target.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y2\", (d) =>\n//             clamp(d.target.y, margin.top, height - margin.bottom)\n//           );\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, margin.left, width - margin.right))\n//           .attr(\"cy\", (d) => clamp(d.y, margin.top, height - margin.bottom));\n//       });\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", (d) => (d.isCentroid ? 10 : 5))\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .on(\"mouseover\", (event, d) => {\n//         const coordinates = {};\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key];\n//         });\n\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  setHoveredCoordinates\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(key => key !== \"Cluster\" && key !== \"Bead\");\n\n    // Helper to calculate centroid\n    const calculateCentroid = points => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach(key => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      // Compute average for each dimension\n      Object.keys(sum).forEach(key => sum[key] /= n);\n      return sum;\n    };\n    // Assign bit vectors based on coordinate keys (planes)\n    const assignBitVector = point => {\n      return coordinateKeys.map(key => point[key] >= 0 ? \"1\" : \"0\").join(\"\");\n    };\n    // Parse and process data\n    const clusters = d3.group(jsonData, d => d.Cluster);\n    const beads = d3.group(jsonData, d => `${d.Cluster}-${d.Bead}`);\n\n    // Root centroid\n    const rootCentroid = calculateCentroid(jsonData);\n\n    // Cluster centroids\n    const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n      cluster,\n      centroid: calculateCentroid(points)\n    }));\n\n    // Bead centroids\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      return {\n        cluster,\n        bead,\n        centroid: calculateCentroid(points),\n        points\n      };\n    });\n\n    // Set up container dimensions\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n    const margin = {\n      top: 20,\n      right: 20,\n      bottom: 20,\n      left: 20\n    };\n    const svg = d3.select(graphRef.current).attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n\n    // Build hierarchical links\n    const links = [];\n    const nodes = [];\n\n    // Calculate the number of quadrants based on the number of dimensions\n    const numDimensions = coordinateKeys.length;\n    const numQuadrants = 2 ** numDimensions;\n    // Function to calculate x and y position based on the bit vector\n    const calculateNodePositions = node => {\n      if (node.bitVector) {\n        const quadrantIndex = parseInt(node.bitVector, 2);\n        const numRows = Math.ceil(Math.sqrt(numQuadrants));\n        const numCols = Math.ceil(numQuadrants / numRows);\n        const quadrantWidth = (width - margin.left - margin.right) / numCols;\n        const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n        const row = Math.floor(quadrantIndex / numCols);\n        const col = quadrantIndex % numCols;\n        const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n        const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n        return {\n          x,\n          y\n        };\n      }\n      return null;\n    };\n\n    // Add root node\n    const rootNode = {\n      id: \"root\",\n      ...rootCentroid,\n      bitVector: assignBitVector(rootCentroid)\n    };\n    const rootPos = calculateNodePositions(rootNode);\n    if (rootPos) {\n      rootNode.x = rootPos.x;\n      rootNode.y = rootPos.y;\n    }\n    nodes.push(rootNode);\n\n    // Add cluster nodes and hierarchical links\n    clusterCentroids.forEach(({\n      cluster,\n      centroid\n    }) => {\n      const clusterNode = {\n        id: `cluster-${cluster}`,\n        ...centroid,\n        bitVector: assignBitVector(centroid)\n      };\n      const clusterPos = calculateNodePositions(clusterNode);\n      if (clusterPos) {\n        clusterNode.x = clusterPos.x;\n        clusterNode.y = clusterPos.y;\n      }\n      nodes.push(clusterNode);\n      links.push({\n        source: \"root\",\n        target: `cluster-${cluster}`\n      });\n    });\n\n    // Add bead nodes, hierarchical links and individual data points\n    beadCentroids.forEach(({\n      cluster,\n      bead,\n      centroid,\n      points\n    }) => {\n      const beadNode = {\n        id: `bead-${cluster}-${bead}`,\n        ...centroid,\n        bitVector: assignBitVector(centroid)\n      };\n      const beadPos = calculateNodePositions(beadNode);\n      if (beadPos) {\n        beadNode.x = beadPos.x;\n        beadNode.y = beadPos.y;\n      }\n      nodes.push(beadNode);\n      links.push({\n        source: `cluster-${cluster}`,\n        target: `bead-${cluster}-${bead}`\n      });\n\n      // Add individual data points and intra-quadrant links\n      points.forEach((point, index) => {\n        const pointId = `point-${cluster}-${bead}-${index}`;\n        const pointNode = {\n          id: pointId,\n          ...point,\n          bitVector: assignBitVector(point)\n        };\n        const pointPos = calculateNodePositions(pointNode);\n        if (pointPos) {\n          pointNode.x = pointPos.x;\n          pointNode.y = pointPos.y;\n        }\n        nodes.push(pointNode);\n        links.push({\n          source: `bead-${cluster}-${bead}`,\n          target: pointId\n        });\n        for (let j = 0; j < index; j++) {\n          const otherPointId = `point-${cluster}-${bead}-${j}`;\n          links.push({\n            source: pointId,\n            target: otherPointId\n          });\n        }\n      });\n    });\n\n    // Draw grid lines and text\n    const numRows = Math.ceil(Math.sqrt(numQuadrants));\n    const numCols = Math.ceil(numQuadrants / numRows);\n    const quadrantWidth = (width - margin.left - margin.right) / numCols;\n    const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n    const grid = svg.append(\"g\").attr(\"class\", \"grid\");\n\n    // Draw vertical lines\n    for (let i = 0; i <= numCols; i++) {\n      grid.append(\"line\").attr(\"x1\", margin.left + i * quadrantWidth).attr(\"y1\", margin.top).attr(\"x2\", margin.left + i * quadrantWidth).attr(\"y2\", height - margin.bottom).attr(\"stroke\", \"#ddd\").attr(\"stroke-width\", 1);\n    }\n\n    // Draw horizontal lines\n    for (let i = 0; i <= numRows; i++) {\n      grid.append(\"line\").attr(\"x1\", margin.left).attr(\"y1\", margin.top + i * quadrantHeight).attr(\"x2\", width - margin.right).attr(\"y2\", margin.top + i * quadrantHeight).attr(\"stroke\", \"#ddd\").attr(\"stroke-width\", 1);\n    }\n    // Add bit vector text\n    for (let i = 0; i < numQuadrants; i++) {\n      const row = Math.floor(i / numCols);\n      const col = i % numCols;\n      const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n      const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n      const bitVector = i.toString(2).padStart(numDimensions, \"0\");\n      grid.append(\"text\").attr(\"x\", x).attr(\"y\", y).attr(\"text-anchor\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"font-size\", \"10px\").text(bitVector);\n    }\n\n    // Draw links\n    const link = svg.append(\"g\").attr(\"class\", \"links\").selectAll(\"line\").data(links).enter().append(\"line\").attr(\"x1\", d => d.source.x).attr(\"y1\", d => d.source.y).attr(\"x2\", d => d.target.x).attr(\"y2\", d => d.target.y).attr(\"stroke\", \"#aaa\").attr(\"stroke-width\", 2);\n\n    // Draw nodes\n    const node = svg.append(\"g\").attr(\"class\", \"nodes\").selectAll(\"circle\").data(nodes).enter().append(\"circle\").attr(\"r\", 5).attr(\"cx\", d => d.x).attr(\"cy\", d => d.y).attr(\"fill\", d => {\n      if (d.id === \"root\") return \"red\";\n      if (d.id.startsWith(\"cluster\")) return \"blue\";\n      if (d.id.startsWith(\"bead\")) return \"green\";\n      return \"gray\";\n    }).on(\"mouseover\", (event, d) => {\n      const coordinates = {};\n      coordinateKeys.forEach(key => {\n        coordinates[key] = d[key];\n      });\n      setHoveredCoordinates({\n        ...coordinates,\n        id: d.id,\n        bitVector: d.bitVector\n      });\n    }).call(d3.drag().on(\"start\", event => {\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    }).on(\"drag\", event => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    }).on(\"end\", event => {\n      event.subject.fx = null;\n      event.subject.fy = null;\n    }));\n\n    // Add tooltips\n    node.append(\"title\").text(d => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n  }, [jsonData, setHoveredCoordinates]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: graphRef,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1311,\n    columnNumber: 10\n  }, this);\n};\n_s(HierarchicalGraph, \"XNG/roOlNWxTF7ymftfdirhS32A=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","setHoveredCoordinates","_s","graphRef","length","coordinateKeys","Object","keys","filter","key","calculateCentroid","points","n","sum","reduce","acc","point","forEach","assignBitVector","map","join","clusters","group","d","Cluster","beads","Bead","rootCentroid","clusterCentroids","Array","from","cluster","centroid","beadCentroids","bead","split","container","select","current","parentNode","width","node","getBoundingClientRect","height","margin","top","right","bottom","left","svg","attr","selectAll","remove","links","nodes","numDimensions","numQuadrants","calculateNodePositions","bitVector","quadrantIndex","parseInt","numRows","Math","ceil","sqrt","numCols","quadrantWidth","quadrantHeight","row","floor","col","x","y","rootNode","id","rootPos","push","clusterNode","clusterPos","source","target","beadNode","beadPos","index","pointId","pointNode","pointPos","j","otherPointId","grid","append","i","toString","padStart","text","link","data","enter","startsWith","on","event","coordinates","call","drag","subject","fx","fy","ref","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || jsonData.length === 0) return;\n\n// // //     // Dynamically extract coordinate keys (dimensions)\n// // //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// // //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// // //     );\n\n// // //     // Helper to calculate centroid\n// // //     const calculateCentroid = (points) => {\n// // //       const n = points.length;\n// // //       const sum = points.reduce((acc, point) => {\n// // //         coordinateKeys.forEach((key) => {\n// // //           acc[key] = (acc[key] || 0) + point[key];\n// // //         });\n// // //         return acc;\n// // //       }, {});\n// // //       // Compute average for each dimension\n// // //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// // //       return sum;\n// // //     };\n// // //     // Assign bit vectors based on coordinate keys (planes)\n// // //     const assignBitVector = (point) => {\n// // //       return coordinateKeys\n// // //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// // //         .join(\"\");\n// // //     };\n// // //     // Parse and process data\n// // //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// // //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// // //     // Root centroid\n// // //     const rootCentroid = calculateCentroid(jsonData);\n\n// // //     // Cluster centroids\n// // //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// // //       cluster,\n// // //       centroid: calculateCentroid(points),\n// // //     }));\n\n// // //     // Bead centroids\n// // //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// // //       const [cluster, bead] = key.split(\"-\");\n// // //       return {\n// // //         cluster,\n// // //         bead,\n// // //         centroid: calculateCentroid(points),\n// // //         points,\n// // //       };\n// // //     });\n\n// // //     // Build hierarchical links\n// // //     const links = [];\n// // //     const nodes = [\n// // //       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n// // //     ];\n\n// // //     // Add cluster nodes and links\n// // //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// // //       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n// // //         bitVector: assignBitVector(centroid), });\n// // //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// // //     });\n\n// // //     // Add bead nodes and links\n// // //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// // //       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n// // //         bitVector: assignBitVector(centroid), });\n// // //       links.push({\n// // //         source: `cluster-${cluster}`,\n// // //         target: `bead-${cluster}-${bead}`,\n// // //       });\n\n// // //       // Add individual points and links\n// // //       points.forEach((point, index) => {\n// // //         const pointId = `point-${cluster}-${bead}-${index}`;\n// // //         nodes.push({ id: pointId, ...point,\n// // //           bitVector: assignBitVector(point), });\n// // //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// // //       });\n// // //     });\n\n// // //     // Set up container dimensions\n// // //     const container = d3.select(graphRef.current.parentNode);\n// // //     const width = container.node().getBoundingClientRect().width;\n// // //     const height = container.node().getBoundingClientRect().height;\n// // //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// // //     const svg = d3\n// // //       .select(graphRef.current)\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// // //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// // //     // Clear previous render\n// // //     svg.selectAll(\"*\").remove();\n\n// // //     // Force simulation\n// // //     const simulation = d3\n// // //       .forceSimulation(nodes)\n// // //       .force(\n// // //         \"link\",\n// // //         d3\n// // //           .forceLink(links)\n// // //           .id((d) => d.id)\n// // //           .distance(-10)\n// // //       )\n// // //       .force(\"charge\", d3.forceManyBody().strength(1))\n// // //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// // //       .force(\n// // //         \"collision\",\n// // //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// // //       )\n\n// // //       .force(\"charge\", d3.forceManyBody().strength( 3))\n// // //       .force(\n// // //         \"center\",\n// // //         d3.forceCenter(\n// // //           (width - margin.left - margin.right) / 2,\n// // //           (height - margin.top - margin.bottom) / 2\n// // //         )\n// // //       )\n// // //       .on(\"tick\", () => {\n// // //         link\n// // //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// // //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// // //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// // //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// // //         node\n// // //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// // //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// // //       });\n\n// // //     // Clamp function to restrict within bounds\n// // //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// // //     // Draw links\n// // //     const link = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"links\")\n// // //       .selectAll(\"line\")\n// // //       .data(links)\n// // //       .enter()\n// // //       .append(\"line\")\n// // //       .attr(\"stroke\", \"#aaa\")\n// // //       .attr(\"stroke-width\", 2);\n\n// // //     // Draw nodes\n// // //     const node = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"nodes\")\n// // //       .selectAll(\"circle\")\n// // //       .data(nodes)\n// // //       .enter()\n// // //       .append(\"circle\")\n// // //       .attr(\"r\", 5)\n// // //       .attr(\"fill\", (d) => {\n// // //         if (d.id === \"root\") return \"red\";\n// // //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// // //         if (d.id.startsWith(\"bead\")) return \"green\";\n// // //         return \"gray\";\n// // //       })\n\n// // //       .on(\"mouseover\", (event, d) => {\n// // //         // Create an object to hold all coordinate values\n// // //         const coordinates = {};\n\n// // //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// // //         coordinateKeys.forEach((key) => {\n// // //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// // //         });\n\n// // //         // Pass the full coordinates to the parent component\n// // //         setHoveredCoordinates({\n// // //           ...coordinates,\n// // //           id: d.id,\n// // //           bitVector: d.bitVector,\n// // //         });\n// // //       })\n\n// // //       .call(\n// // //         d3\n// // //           .drag()\n// // //           .on(\"start\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// // //             event.subject.fx = event.subject.x;\n// // //             event.subject.fy = event.subject.y;\n// // //           })\n// // //           .on(\"drag\", (event) => {\n// // //             event.subject.fx = event.x;\n// // //             event.subject.fy = event.y;\n// // //           })\n// // //           .on(\"end\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0);\n// // //             event.subject.fx = null;\n// // //             event.subject.fy = null;\n// // //           })\n// // //       );\n\n// // //     // Add tooltips\n// // //     // node.append(\"title\").text((d) => d.id);\n// // //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// // //   }, [jsonData, setHoveredCoordinates]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n\n// // // _____________________________________placement acc x and y bit vectors_________________________________\n\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || jsonData.length === 0) return;\n\n// //     // Dynamically extract coordinate keys (dimensions)\n// //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// //     );\n\n// //     // Helper to calculate centroid\n// //     const calculateCentroid = (points) => {\n// //       const n = points.length;\n// //       const sum = points.reduce((acc, point) => {\n// //         coordinateKeys.forEach((key) => {\n// //           acc[key] = (acc[key] || 0) + point[key];\n// //         });\n// //         return acc;\n// //       }, {});\n// //       // Compute average for each dimension\n// //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// //       return sum;\n// //     };\n// //     // Assign bit vectors based on coordinate keys (planes)\n// //     const assignBitVector = (point) => {\n// //       return coordinateKeys\n// //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// //         .join(\"\");\n// //     };\n// //     // Parse and process data\n// //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// //     // Root centroid\n// //     const rootCentroid = calculateCentroid(jsonData);\n\n// //     // Cluster centroids\n// //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// //       cluster,\n// //       centroid: calculateCentroid(points),\n// //     }));\n\n// //     // Bead centroids\n// //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// //       const [cluster, bead] = key.split(\"-\");\n// //       return {\n// //         cluster,\n// //         bead,\n// //         centroid: calculateCentroid(points),\n// //         points,\n// //       };\n// //     });\n\n// //     // Build hierarchical links\n// //     const links = [];\n// //     const nodes = [\n// //       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n// //     ];\n\n// //     // Add cluster nodes and links\n// //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// //       nodes.push({\n// //         id: `cluster-${cluster}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// //     });\n\n// //     // Add bead nodes and links\n// //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// //       nodes.push({\n// //         id: `bead-${cluster}-${bead}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({\n// //         source: `cluster-${cluster}`,\n// //         target: `bead-${cluster}-${bead}`,\n// //       });\n\n// //       // Add individual points and links\n// //       points.forEach((point, index) => {\n// //         const pointId = `point-${cluster}-${bead}-${index}`;\n// //         nodes.push({\n// //           id: pointId,\n// //           ...point,\n// //           bitVector: assignBitVector(point),\n// //         });\n// //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// //       });\n// //     });\n\n// //     // Set up container dimensions\n// //     const container = d3.select(graphRef.current.parentNode);\n// //     const width = container.node().getBoundingClientRect().width;\n// //     const height = container.node().getBoundingClientRect().height;\n// //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// //     const svg = d3\n// //       .select(graphRef.current)\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// //     // Clear previous render\n// //     svg.selectAll(\"*\").remove();\n\n// //     // Calculate initial positions based on bit vectors\n// //     nodes.forEach((node) => {\n// //       if (node.bitVector) {\n// //         // Avoid undefined case\n// //         let x = 0;\n// //         let y = 0;\n\n// //         for (let i = 0; i < coordinateKeys.length; i++) {\n// //           const key = coordinateKeys[i];\n// //           const bit = node.bitVector[i];\n// //           const dimensionMultiplier = 100; // You can increase or decrease this to change spread between clusters\n\n// //           // Use the dimensionMultiplier and add more multiplier if more than one dimension\n// //           x +=\n// //             (bit === \"1\"\n// //               ? dimensionMultiplier * 1.5\n// //               : -dimensionMultiplier * 1.5) *\n// //             (i + 1);\n// //           y +=\n// //             (bit === \"1\"\n// //               ? dimensionMultiplier * 1.5\n// //               : -dimensionMultiplier * 1.5) *\n// //             (i + 1);\n// //         }\n\n// //         node.x = x + width / 2;\n// //         node.y = y + height / 2;\n// //       }\n// //     });\n\n// //     // Force simulation\n// //     const simulation = d3\n// //       .forceSimulation(nodes)\n// //       .force(\n// //         \"link\",\n// //         d3\n// //           .forceLink(links)\n// //           .id((d) => d.id)\n// //           .distance(-10)\n// //       )\n// //       .force(\"charge\", d3.forceManyBody().strength(1))\n// //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// //       .force(\n// //         \"collision\",\n// //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// //       )\n\n// //       .force(\"charge\", d3.forceManyBody().strength(3))\n// //       .force(\n// //         \"center\",\n// //         d3.forceCenter(\n// //           (width - margin.left - margin.right) / 2,\n// //           (height - margin.top - margin.bottom) / 2\n// //         )\n// //       )\n// //       .on(\"tick\", () => {\n// //         link\n// //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// //         node\n// //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// //       });\n\n// //     // Clamp function to restrict within bounds\n// //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// //     // Draw links\n// //     const link = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"links\")\n// //       .selectAll(\"line\")\n// //       .data(links)\n// //       .enter()\n// //       .append(\"line\")\n// //       .attr(\"stroke\", \"#aaa\")\n// //       .attr(\"stroke-width\", 2);\n\n// //     // Draw nodes\n// //     const node = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"nodes\")\n// //       .selectAll(\"circle\")\n// //       .data(nodes)\n// //       .enter()\n// //       .append(\"circle\")\n// //       .attr(\"r\", 5)\n// //       .attr(\"fill\", (d) => {\n// //         if (d.id === \"root\") return \"red\";\n// //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// //         if (d.id.startsWith(\"bead\")) return \"green\";\n// //         return \"gray\";\n// //       })\n\n// //       .on(\"mouseover\", (event, d) => {\n// //         // Create an object to hold all coordinate values\n// //         const coordinates = {};\n\n// //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// //         coordinateKeys.forEach((key) => {\n// //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// //         });\n\n// //         // Pass the full coordinates to the parent component\n// //         setHoveredCoordinates({\n// //           ...coordinates,\n// //           id: d.id,\n// //           bitVector: d.bitVector,\n// //         });\n// //       })\n\n// //       .call(\n// //         d3\n// //           .drag()\n// //           .on(\"start\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// //             event.subject.fx = event.subject.x;\n// //             event.subject.fy = event.subject.y;\n// //           })\n// //           .on(\"drag\", (event) => {\n// //             event.subject.fx = event.x;\n// //             event.subject.fy = event.y;\n// //           })\n// //           .on(\"end\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0);\n// //             event.subject.fx = null;\n// //             event.subject.fy = null;\n// //           })\n// //       );\n\n// //     // Add tooltips\n// //     // node.append(\"title\").text((d) => d.id);\n// //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// //   }, [jsonData, setHoveredCoordinates]);\n\n// //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n\n// // _______________________________________________________QUANDRANT POSITIONING WITH SIMULATION_________________\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({\n//         id: `cluster-${cluster}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//       });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({\n//         id: `bead-${cluster}-${bead}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//       });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({\n//           id: pointId,\n//           ...point,\n//           bitVector: assignBitVector(point),\n//         });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate the number of quadrants based on the number of dimensions\n//     const numDimensions = coordinateKeys.length;\n//     const numQuadrants = 2 ** numDimensions;\n\n//     // Calculate initial positions based on bit vectors\n//     nodes.forEach((node) => {\n//       if (node.bitVector) {\n//         // Convert the bit vector to a decimal number\n//         const quadrantIndex = parseInt(node.bitVector, 2);\n\n//         // Calculate quadrant size and starting position\n//         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//         const numCols = Math.ceil(numQuadrants / numRows);\n//         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//         const row = Math.floor(quadrantIndex / numCols);\n//         const col = quadrantIndex % numCols;\n\n//         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n//         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n//         node.x = x;\n//         node.y = y;\n//       }\n//     });\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(-10)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(1))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15))\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(3))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       {\n//         id: \"root\",\n//         ...rootCentroid,\n//         bitVector: assignBitVector(rootCentroid),\n//         isCentroid: true,\n//       }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({\n//         id: `cluster-${cluster}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({\n//         id: `bead-${cluster}-${bead}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({\n//           id: pointId,\n//           ...point,\n//           bitVector: assignBitVector(point),\n//           isCentroid: false,\n//         });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate the number of quadrants based on the number of dimensions\n//     const numDimensions = coordinateKeys.length;\n//     const numQuadrants = 2 ** numDimensions;\n\n//     // Calculate initial positions based on bit vectors\n//     nodes.forEach((node) => {\n//       if (node.bitVector) {\n//         // Convert the bit vector to a decimal number\n//         const quadrantIndex = parseInt(node.bitVector, 2);\n\n//         // Calculate quadrant size and starting position\n//         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//         const numCols = Math.ceil(numQuadrants / numRows);\n//         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//         const row = Math.floor(quadrantIndex / numCols);\n//         const col = quadrantIndex % numCols;\n\n//         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n//         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n//         node.x = x;\n//         node.y = y;\n//       }\n//     });\n\n//     // Draw grid lines\n//     const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//     const numCols = Math.ceil(numQuadrants / numRows);\n//     const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//     const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//     const grid = svg.append(\"g\").attr(\"class\", \"grid\");\n\n//     // Draw vertical lines\n//     for (let i = 0; i <= numCols; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left + i * quadrantWidth)\n//         .attr(\"y1\", margin.top)\n//         .attr(\"x2\", margin.left + i * quadrantWidth)\n//         .attr(\"y2\", height - margin.bottom)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Draw horizontal lines\n//     for (let i = 0; i <= numRows; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left)\n//         .attr(\"y1\", margin.top + i * quadrantHeight)\n//         .attr(\"x2\", width - margin.right)\n//         .attr(\"y2\", margin.top + i * quadrantHeight)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(-10)\n//       )\n//       .force(\n//         \"charge\",\n//         d3.forceManyBody().strength((d) => (d.isCentroid ? -20 : 1))\n//       )\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.isCentroid ? 10 : 5))\n//       )\n\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) =>\n//             clamp(d.source.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y1\", (d) =>\n//             clamp(d.source.y, margin.top, height - margin.bottom)\n//           )\n//           .attr(\"x2\", (d) =>\n//             clamp(d.target.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y2\", (d) =>\n//             clamp(d.target.y, margin.top, height - margin.bottom)\n//           );\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, margin.left, width - margin.right))\n//           .attr(\"cy\", (d) => clamp(d.y, margin.top, height - margin.bottom));\n//       });\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", (d) => (d.isCentroid ? 10 : 5))\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .on(\"mouseover\", (event, d) => {\n//         const coordinates = {};\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key];\n//         });\n\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n  const graphRef = useRef(null);\n\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(\n      (key) => key !== \"Cluster\" && key !== \"Bead\"\n    );\n\n    // Helper to calculate centroid\n    const calculateCentroid = (points) => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach((key) => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      // Compute average for each dimension\n      Object.keys(sum).forEach((key) => (sum[key] /= n));\n      return sum;\n    };\n    // Assign bit vectors based on coordinate keys (planes)\n    const assignBitVector = (point) => {\n      return coordinateKeys\n        .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n        .join(\"\");\n    };\n    // Parse and process data\n    const clusters = d3.group(jsonData, (d) => d.Cluster);\n    const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n    // Root centroid\n    const rootCentroid = calculateCentroid(jsonData);\n\n    // Cluster centroids\n    const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n      cluster,\n      centroid: calculateCentroid(points),\n    }));\n\n    // Bead centroids\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      return {\n        cluster,\n        bead,\n        centroid: calculateCentroid(points),\n        points,\n      };\n    });\n\n    // Set up container dimensions\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n    const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n    const svg = d3\n      .select(graphRef.current)\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", `0 0 ${width} ${height}`)\n      .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n\n    // Build hierarchical links\n    const links = [];\n    const nodes = [];\n\n    // Calculate the number of quadrants based on the number of dimensions\n    const numDimensions = coordinateKeys.length;\n    const numQuadrants = 2 ** numDimensions;\n    // Function to calculate x and y position based on the bit vector\n    const calculateNodePositions = (node) => {\n      if (node.bitVector) {\n        const quadrantIndex = parseInt(node.bitVector, 2);\n\n        const numRows = Math.ceil(Math.sqrt(numQuadrants));\n        const numCols = Math.ceil(numQuadrants / numRows);\n        const quadrantWidth = (width - margin.left - margin.right) / numCols;\n        const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n        const row = Math.floor(quadrantIndex / numCols);\n        const col = quadrantIndex % numCols;\n\n        const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n        const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n        return { x, y };\n      }\n      return null;\n    };\n\n    // Add root node\n    const rootNode = {\n      id: \"root\",\n      ...rootCentroid,\n      bitVector: assignBitVector(rootCentroid),\n    };\n    const rootPos = calculateNodePositions(rootNode);\n    if (rootPos) {\n      rootNode.x = rootPos.x;\n      rootNode.y = rootPos.y;\n    }\n    nodes.push(rootNode);\n\n    // Add cluster nodes and hierarchical links\n    clusterCentroids.forEach(({ cluster, centroid }) => {\n      const clusterNode = {\n        id: `cluster-${cluster}`,\n        ...centroid,\n        bitVector: assignBitVector(centroid),\n      };\n      const clusterPos = calculateNodePositions(clusterNode);\n      if (clusterPos) {\n        clusterNode.x = clusterPos.x;\n        clusterNode.y = clusterPos.y;\n      }\n      nodes.push(clusterNode);\n      links.push({ source: \"root\", target: `cluster-${cluster}` });\n    });\n\n    // Add bead nodes, hierarchical links and individual data points\n    beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n      const beadNode = {\n        id: `bead-${cluster}-${bead}`,\n        ...centroid,\n        bitVector: assignBitVector(centroid),\n      };\n      const beadPos = calculateNodePositions(beadNode);\n      if (beadPos) {\n        beadNode.x = beadPos.x;\n        beadNode.y = beadPos.y;\n      }\n      nodes.push(beadNode);\n\n      links.push({\n        source: `cluster-${cluster}`,\n        target: `bead-${cluster}-${bead}`,\n      });\n\n      // Add individual data points and intra-quadrant links\n      points.forEach((point, index) => {\n        const pointId = `point-${cluster}-${bead}-${index}`;\n        const pointNode = {\n          id: pointId,\n          ...point,\n          bitVector: assignBitVector(point),\n        };\n        const pointPos = calculateNodePositions(pointNode);\n        if (pointPos) {\n          pointNode.x = pointPos.x;\n          pointNode.y = pointPos.y;\n        }\n        nodes.push(pointNode);\n        links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n\n        for (let j = 0; j < index; j++) {\n          const otherPointId = `point-${cluster}-${bead}-${j}`;\n          links.push({ source: pointId, target: otherPointId });\n        }\n      });\n    });\n\n    // Draw grid lines and text\n    const numRows = Math.ceil(Math.sqrt(numQuadrants));\n    const numCols = Math.ceil(numQuadrants / numRows);\n    const quadrantWidth = (width - margin.left - margin.right) / numCols;\n    const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n    const grid = svg.append(\"g\").attr(\"class\", \"grid\");\n\n    // Draw vertical lines\n    for (let i = 0; i <= numCols; i++) {\n      grid\n        .append(\"line\")\n        .attr(\"x1\", margin.left + i * quadrantWidth)\n        .attr(\"y1\", margin.top)\n        .attr(\"x2\", margin.left + i * quadrantWidth)\n        .attr(\"y2\", height - margin.bottom)\n        .attr(\"stroke\", \"#ddd\")\n        .attr(\"stroke-width\", 1);\n    }\n\n    // Draw horizontal lines\n    for (let i = 0; i <= numRows; i++) {\n      grid\n        .append(\"line\")\n        .attr(\"x1\", margin.left)\n        .attr(\"y1\", margin.top + i * quadrantHeight)\n        .attr(\"x2\", width - margin.right)\n        .attr(\"y2\", margin.top + i * quadrantHeight)\n        .attr(\"stroke\", \"#ddd\")\n        .attr(\"stroke-width\", 1);\n    }\n    // Add bit vector text\n    for (let i = 0; i < numQuadrants; i++) {\n      const row = Math.floor(i / numCols);\n      const col = i % numCols;\n\n      const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n      const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n      const bitVector = i.toString(2).padStart(numDimensions, \"0\");\n\n      grid\n        .append(\"text\")\n        .attr(\"x\", x)\n        .attr(\"y\", y)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .attr(\"font-size\", \"10px\")\n        .text(bitVector);\n    }\n\n    // Draw links\n    const link = svg\n      .append(\"g\")\n      .attr(\"class\", \"links\")\n      .selectAll(\"line\")\n      .data(links)\n      .enter()\n      .append(\"line\")\n      .attr(\"x1\", (d) => d.source.x)\n      .attr(\"y1\", (d) => d.source.y)\n      .attr(\"x2\", (d) => d.target.x)\n      .attr(\"y2\", (d) => d.target.y)\n      .attr(\"stroke\", \"#aaa\")\n      .attr(\"stroke-width\", 2);\n\n    // Draw nodes\n    const node = svg\n      .append(\"g\")\n      .attr(\"class\", \"nodes\")\n      .selectAll(\"circle\")\n      .data(nodes)\n      .enter()\n      .append(\"circle\")\n      .attr(\"r\", 5)\n      .attr(\"cx\", (d) => d.x)\n      .attr(\"cy\", (d) => d.y)\n      .attr(\"fill\", (d) => {\n        if (d.id === \"root\") return \"red\";\n        if (d.id.startsWith(\"cluster\")) return \"blue\";\n        if (d.id.startsWith(\"bead\")) return \"green\";\n        return \"gray\";\n      })\n      .on(\"mouseover\", (event, d) => {\n        const coordinates = {};\n        coordinateKeys.forEach((key) => {\n          coordinates[key] = d[key];\n        });\n\n        setHoveredCoordinates({\n          ...coordinates,\n          id: d.id,\n          bitVector: d.bitVector,\n        });\n      })\n      .call(\n        d3\n          .drag()\n          .on(\"start\", (event) => {\n            event.subject.fx = event.subject.x;\n            event.subject.fy = event.subject.y;\n          })\n          .on(\"drag\", (event) => {\n            event.subject.fx = event.x;\n            event.subject.fy = event.y;\n          })\n          .on(\"end\", (event) => {\n            event.subject.fx = null;\n            event.subject.fy = null;\n          })\n      );\n\n    // Add tooltips\n    node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n  }, [jsonData, setHoveredCoordinates]);\n\n  return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n};\n\nexport default HierarchicalGraph;"],"mappings":";;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAO,KAAKC,EAAE,MAAM,IAAI;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEzB,MAAMC,iBAAiB,GAAGA,CAAC;EAAEC,QAAQ;EAAEC;AAAsB,CAAC,KAAK;EAAAC,EAAA;EACjE,MAAMC,QAAQ,GAAG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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}