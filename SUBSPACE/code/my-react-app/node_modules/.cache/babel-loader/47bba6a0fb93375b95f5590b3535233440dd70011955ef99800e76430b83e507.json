{"ast":null,"code":"// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     console.log(subspaces.length);\n\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, \n//       subspaceId: key, \n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 1200;\n//     const height = 1200;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove(); \n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     pointsData.forEach((subspace, index) => {\n//       const radius = maxRadius * ((index + 1) / subspaces.length);\n//       const sectors = 2 ** (index +1); \n//       console.log(sectors);\n\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); \n\n//       const subspaceColor = colorScale(\n//         subspace.dimensions % colorScale.range().length\n//       );\n\n//       g.append(\"circle\")\n//         .attr(\"r\", radius)\n//         .attr(\"stroke\", \"black\") \n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2) \n//         .attr(\"stroke-width\", 2); \n\n//       if (subspace.dimensions > 0) {\n\n//         for (let i = 0; i < sectors; i++) {\n//           const angle = (2 * Math.PI * i) / sectors;\n//           const x1 = radius * Math.cos(angle);\n//           const y1 = radius * Math.sin(angle);\n//           g.append(\"line\")\n//             .attr(\"x1\", 0)\n//             .attr(\"y1\", 0)\n//             .attr(\"x2\", x1)\n//             .attr(\"y2\", y1)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 1);\n\n//           const labelX = (radius + 10) * Math.cos(angle); \n//           const labelY = (radius + 10) * Math.sin(angle);\n\n//           g.append(\"text\")\n//             .attr(\"x\", labelX)\n//             .attr(\"y\", labelY + 5) \n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"dominant-baseline\", \"middle\")\n//             .style(\"font-size\", \"10px\")\n//             .style(\"fill\", \"black\");\n//         }\n//       }\n\n//       const sectorRadius = radius;\n\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(\n//           subspace.dimensions,\n//           \"0\"\n//         );\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n//         const minRadius = sectorRadius * 0.2;\n//         const randomRadius =\n//           minRadius + Math.random() * (sectorRadius - minRadius);\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         if (Math.sqrt(x * x + y * y) <= radius) {\n//           const circle = g\n//             .append(\"circle\")\n//             .attr(\"cx\", x)\n//             .attr(\"cy\", y)\n//             .attr(\"r\", 4)\n//             .attr(\"fill\", \"black\")\n//             .attr(\"stroke\", \"white\")\n//             .attr(\"stroke-width\", 0.5)\n//             .append(\"title\")\n//             .text(\n//               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n//             );\n\n//           circle\n//             .on(\"mouseover\", function () {\n//               d3.select(this).attr(\"fill\", \"red\");\n//             })\n//             .on(\"mouseout\", function () {\n//               d3.select(this).attr(\"fill\", \"black\");\n//             });\n//         } else {\n//           console.warn(\n//             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n//           ); \n//         }\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"1200px\", height: \"1200px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     console.log(\"Number of subspaces:\", subspaces.length);\n\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     pointsData.forEach((subspace, index) => {\n//       const radius = maxRadius * ((index + 1) / subspaces.length);\n//       const sectors = 2 ** (index + 1);\n\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n\n//       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n//       g.append(\"circle\")\n//         .attr(\"r\", radius)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2)\n//         .attr(\"stroke-width\", 2);\n\n//       if (index + 1 > 0) {\n//         for (let i = 0; i < sectors; i++) {\n//           const angle = (2 * Math.PI * i) / sectors;\n//           const x1 = radius * Math.cos(angle);\n//           const y1 = radius * Math.sin(angle);\n//           g.append(\"line\")\n//             .attr(\"x1\", 0)\n//             .attr(\"y1\", 0)\n//             .attr(\"x2\", x1)\n//             .attr(\"y2\", y1)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 1);\n\n//           const labelX = (radius + 10) * Math.cos(angle);\n//           const labelY = (radius + 10) * Math.sin(angle);\n\n//           g.append(\"text\")\n//             .attr(\"x\", labelX)\n//             .attr(\"y\", labelY + 5)\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"dominant-baseline\", \"middle\")\n//             .style(\"font-size\", \"10px\")\n//             .style(\"fill\", \"black\");\n//         }\n//       }\n\n//       const sectorRadius = radius;\n\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(index + 1, \"0\");\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n//         const minRadius = sectorRadius * 0.2;\n//         const randomRadius =\n//           minRadius + Math.random() * (sectorRadius - minRadius);\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         if (Math.sqrt(x * x + y * y) <= radius) {\n//           const circle = g\n//             .append(\"circle\")\n//             .attr(\"cx\", x)\n//             .attr(\"cy\", y)\n//             .attr(\"r\", 4)\n//             .attr(\"fill\", \"black\")\n//             .attr(\"stroke\", \"white\")\n//             .attr(\"stroke-width\", 0.5);\n\n//           circle\n//             .append(\"title\")\n//             .text(\n//               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n//             );\n\n//           circle\n//             .on(\"mouseover\", function (event) {\n//               d3.select(this).attr(\"fill\", \"red\");\n//               g.append(\"text\")\n//                 .attr(\"id\", \"tooltip\")\n//                 .attr(\"x\", x + 10)\n//                 .attr(\"y\", y - 10)\n//                 .attr(\"text-anchor\", \"middle\")\n//                 .attr(\"dominant-baseline\", \"middle\")\n//                 .style(\"font-size\", \"12px\")\n//                 .style(\"fill\", \"black\")\n//                 .text(bitPattern);\n//             })\n//             .on(\"mouseout\", function () {\n//               d3.select(this).attr(\"fill\", \"black\");\n//               g.select(\"#tooltip\").remove();\n//             });\n//         } else {\n//           console.warn(\n//             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n//           );\n//         }\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;","map":{"version":3,"names":[],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     console.log(subspaces.length);\n    \n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length, \n//       subspaceId: key, \n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 1200;\n//     const height = 1200;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove(); \n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n    \n//     pointsData.forEach((subspace, index) => {\n//       const radius = maxRadius * ((index + 1) / subspaces.length);\n//       const sectors = 2 ** (index +1); \n//       console.log(sectors);\n      \n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]); \n      \n//       const subspaceColor = colorScale(\n//         subspace.dimensions % colorScale.range().length\n//       );\n      \n//       g.append(\"circle\")\n//         .attr(\"r\", radius)\n//         .attr(\"stroke\", \"black\") \n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2) \n//         .attr(\"stroke-width\", 2); \n      \n//       if (subspace.dimensions > 0) {\n        \n//         for (let i = 0; i < sectors; i++) {\n//           const angle = (2 * Math.PI * i) / sectors;\n//           const x1 = radius * Math.cos(angle);\n//           const y1 = radius * Math.sin(angle);\n//           g.append(\"line\")\n//             .attr(\"x1\", 0)\n//             .attr(\"y1\", 0)\n//             .attr(\"x2\", x1)\n//             .attr(\"y2\", y1)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 1);\n          \n//           const labelX = (radius + 10) * Math.cos(angle); \n//           const labelY = (radius + 10) * Math.sin(angle);\n\n//           g.append(\"text\")\n//             .attr(\"x\", labelX)\n//             .attr(\"y\", labelY + 5) \n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"dominant-baseline\", \"middle\")\n//             .style(\"font-size\", \"10px\")\n//             .style(\"fill\", \"black\");\n//         }\n//       }\n\n//       const sectorRadius = radius;\n\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(\n//           subspace.dimensions,\n//           \"0\"\n//         );\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n//         const minRadius = sectorRadius * 0.2;\n//         const randomRadius =\n//           minRadius + Math.random() * (sectorRadius - minRadius);\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         if (Math.sqrt(x * x + y * y) <= radius) {\n//           const circle = g\n//             .append(\"circle\")\n//             .attr(\"cx\", x)\n//             .attr(\"cy\", y)\n//             .attr(\"r\", 4)\n//             .attr(\"fill\", \"black\")\n//             .attr(\"stroke\", \"white\")\n//             .attr(\"stroke-width\", 0.5)\n//             .append(\"title\")\n//             .text(\n//               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n//             );\n\n          \n//           circle\n//             .on(\"mouseover\", function () {\n//               d3.select(this).attr(\"fill\", \"red\");\n//             })\n//             .on(\"mouseout\", function () {\n//               d3.select(this).attr(\"fill\", \"black\");\n//             });\n//         } else {\n//           console.warn(\n//             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n//           ); \n//         }\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"1200px\", height: \"1200px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || Object.keys(jsonData).length === 0) return;\n\n//     const subspaces = Object.keys(jsonData);\n//     console.log(\"Number of subspaces:\", subspaces.length);\n\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 600;\n//     const height = 600;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     pointsData.forEach((subspace, index) => {\n//       const radius = maxRadius * ((index + 1) / subspaces.length);\n//       const sectors = 2 ** (index + 1);\n\n//       const colorScale = d3\n//         .scaleOrdinal()\n//         .range([\"#FFD700\", \"#FF69B4\", \"#33B5E5\"]);\n\n//       const subspaceColor = colorScale((index + 1) % colorScale.range().length);\n\n//       g.append(\"circle\")\n//         .attr(\"r\", radius)\n//         .attr(\"stroke\", \"black\")\n//         .attr(\"fill\", subspaceColor)\n//         .attr(\"fill-opacity\", 0.2)\n//         .attr(\"stroke-width\", 2);\n\n//       if (index + 1 > 0) {\n//         for (let i = 0; i < sectors; i++) {\n//           const angle = (2 * Math.PI * i) / sectors;\n//           const x1 = radius * Math.cos(angle);\n//           const y1 = radius * Math.sin(angle);\n//           g.append(\"line\")\n//             .attr(\"x1\", 0)\n//             .attr(\"y1\", 0)\n//             .attr(\"x2\", x1)\n//             .attr(\"y2\", y1)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 1);\n\n//           const labelX = (radius + 10) * Math.cos(angle);\n//           const labelY = (radius + 10) * Math.sin(angle);\n\n//           g.append(\"text\")\n//             .attr(\"x\", labelX)\n//             .attr(\"y\", labelY + 5)\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"dominant-baseline\", \"middle\")\n//             .style(\"font-size\", \"10px\")\n//             .style(\"fill\", \"black\");\n//         }\n//       }\n\n//       const sectorRadius = radius;\n\n//       subspace.points.forEach((point) => {\n//         const bitPattern = point.Point_ID.toString(2).padStart(index + 1, \"0\");\n//         const sectorIndex = parseInt(bitPattern, 2);\n//         const sectorAngleStart = (2 * Math.PI * sectorIndex) / sectors;\n//         const sectorAngleEnd = (2 * Math.PI * (sectorIndex + 1)) / sectors;\n\n//         const minRadius = sectorRadius * 0.2;\n//         const randomRadius =\n//           minRadius + Math.random() * (sectorRadius - minRadius);\n//         const randomAngle =\n//           sectorAngleStart +\n//           Math.random() * (sectorAngleEnd - sectorAngleStart);\n\n//         const x = randomRadius * Math.cos(randomAngle);\n//         const y = randomRadius * Math.sin(randomAngle);\n\n//         if (Math.sqrt(x * x + y * y) <= radius) {\n//           const circle = g\n//             .append(\"circle\")\n//             .attr(\"cx\", x)\n//             .attr(\"cy\", y)\n//             .attr(\"r\", 4)\n//             .attr(\"fill\", \"black\")\n//             .attr(\"stroke\", \"white\")\n//             .attr(\"stroke-width\", 0.5);\n\n//           circle\n//             .append(\"title\")\n//             .text(\n//               `ID: ${point.Point_ID}, Binary: ${bitPattern}, Subspace: ${subspace.subspaceId}`\n//             );\n\n//           circle\n//             .on(\"mouseover\", function (event) {\n//               d3.select(this).attr(\"fill\", \"red\");\n//               g.append(\"text\")\n//                 .attr(\"id\", \"tooltip\")\n//                 .attr(\"x\", x + 10)\n//                 .attr(\"y\", y - 10)\n//                 .attr(\"text-anchor\", \"middle\")\n//                 .attr(\"dominant-baseline\", \"middle\")\n//                 .style(\"font-size\", \"12px\")\n//                 .style(\"fill\", \"black\")\n//                 .text(bitPattern);\n//             })\n//             .on(\"mouseout\", function () {\n//               d3.select(this).attr(\"fill\", \"black\");\n//               g.select(\"#tooltip\").remove();\n//             });\n//         } else {\n//           console.warn(\n//             `Point ${point.Point_ID} is outside the subspace ${subspace.subspaceId}`\n//           );\n//         }\n//       });\n//     });\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"600px\", height: \"600px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n"],"mappings":"AAAA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}