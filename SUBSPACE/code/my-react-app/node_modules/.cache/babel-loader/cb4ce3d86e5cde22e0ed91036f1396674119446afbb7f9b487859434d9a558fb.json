{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/strip.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HorizontalStrip = ({\n  jsonData,\n  labelsData,\n  setHoveredCoordinates,\n  stripHeight = 100,\n  stripMargin = {\n    top: 20,\n    right: 30,\n    bottom: 30,\n    left: 30\n  }\n}) => {\n  _s();\n  const stripRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || typeof jsonData !== \"object\" || Object.keys(jsonData).length === 0) {\n      console.error(\"Invalid or empty jsonData:\", jsonData);\n      return;\n    }\n    if (!labelsData || typeof labelsData !== \"object\") {\n      console.error(\"Invalid labelsData:\", labelsData);\n      return;\n    }\n\n    // Select SVG and clear it\n    const svg = d3.select(stripRef.current);\n    svg.selectAll(\"*\").remove();\n\n    // Get the last subspace/ring\n    const subspaces = Object.keys(jsonData);\n    subspaces.sort((a, b) => a.length - b.length);\n    const lastSubspace = subspaces[subspaces.length - 1];\n    if (!jsonData[lastSubspace] || !jsonData[lastSubspace].length) {\n      return; // No data for the last ring\n    }\n\n    // Setup dimensions\n    const width = parseInt(svg.style(\"width\")) || 800;\n    const height = stripHeight + stripMargin.top + stripMargin.bottom;\n    svg.attr(\"height\", height);\n    const g = svg.append(\"g\").attr(\"transform\", `translate(${stripMargin.left}, ${stripMargin.top})`);\n\n    // Setup tooltip\n    const tooltip = d3.select(\"body\").append(\"div\").attr(\"class\", \"tooltip\").style(\"position\", \"absolute\").style(\"visibility\", \"hidden\").style(\"background-color\", \"rgba(0, 0, 0, 0.7)\").style(\"color\", \"white\").style(\"padding\", \"5px\").style(\"border-radius\", \"4px\").style(\"font-size\", \"12px\");\n\n    // Color scales\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(Object.keys(labelsData.labels || {}));\n    const getLabelColor = pointId => {\n      if (!labelsData || !labelsData.labels) return \"gray\";\n      for (const label of Object.keys(labelsData.labels)) {\n        const pointList = labelsData.labels[label];\n        if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n          return colorScale(label);\n        }\n      }\n      return \"gray\";\n    };\n\n    // Get points in the last ring\n    const lastRingPoints = jsonData[lastSubspace];\n\n    // Calculate sector distribution\n    const sectors = 2 ** lastSubspace.length;\n    const pointsBySector = {};\n\n    // Initialize sectors\n    for (let i = 0; i < sectors; i++) {\n      pointsBySector[i] = [];\n    }\n\n    // Group points by sector\n    lastRingPoints.forEach(point => {\n      const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n      const bitVector = pointData.map(([_, coord]) => coord >= 0 ? 1 : 0).join(\"\");\n      const sectorIndex = Math.min(parseInt(bitVector, 2), sectors - 1);\n      pointsBySector[sectorIndex].push(point);\n    });\n\n    // Calculate total points for proportions\n    const totalPoints = lastRingPoints.length;\n\n    // Calculate sector widths (proportional to point counts)\n    const stripWidth = width - stripMargin.left - stripMargin.right;\n    const sectorWidths = {};\n    let sectorStarts = {};\n    let currentStart = 0;\n    for (let i = 0; i < sectors; i++) {\n      const sectorPoints = pointsBySector[i].length;\n      const proportion = sectorPoints / totalPoints;\n      sectorWidths[i] = stripWidth * proportion;\n      sectorStarts[i] = currentStart;\n      currentStart += sectorWidths[i];\n    }\n\n    // Draw sector backgrounds\n    for (let i = 0; i < sectors; i++) {\n      const sectorPoints = pointsBySector[i].length;\n      if (sectorPoints === 0) continue;\n      g.append(\"rect\").attr(\"x\", sectorStarts[i]).attr(\"y\", 0).attr(\"width\", sectorWidths[i]).attr(\"height\", stripHeight).attr(\"fill\", i % 2 === 0 ? \"#f0f0f0\" : \"#e0e0e0\").attr(\"stroke\", \"#ccc\").attr(\"stroke-width\", 0.5);\n\n      // Add sector label\n      g.append(\"text\").attr(\"x\", sectorStarts[i] + sectorWidths[i] / 2).attr(\"y\", stripHeight + 20).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"10px\").text(`Sector ${i} (${sectorPoints})`);\n    }\n\n    // Draw dividing lines between sectors\n    for (let i = 1; i < sectors; i++) {\n      if (sectorStarts[i] > 0) {\n        g.append(\"line\").attr(\"x1\", sectorStarts[i]).attr(\"y1\", 0).attr(\"x2\", sectorStarts[i]).attr(\"y2\", stripHeight).attr(\"stroke\", \"#999\").attr(\"stroke-width\", 1);\n      }\n    }\n\n    // Draw points\n    for (let sectorIndex = 0; sectorIndex < sectors; sectorIndex++) {\n      const sectorPoints = pointsBySector[sectorIndex];\n      const sectorWidth = sectorWidths[sectorIndex];\n      const sectorStart = sectorStarts[sectorIndex];\n      if (sectorPoints.length === 0) continue;\n\n      // Create scale for dimension values in this sector\n      const findMinMax = (points, dim) => {\n        const values = points.map(p => {\n          const coords = Object.entries(p).filter(([key]) => key !== \"Point_ID\");\n          return coords[dim][1]; // Get the value for this dimension\n        });\n        return [Math.min(...values), Math.max(...values)];\n      };\n\n      // Set up k equidistant vertical lines within the sector\n      const k = lastSubspace.length; // number of dimensions\n      const lineSpacing = sectorWidth / (k + 1);\n\n      // Draw vertical dimension lines\n      for (let dim = 0; dim < k; dim++) {\n        const lineX = sectorStart + (dim + 1) * lineSpacing;\n        const [minVal, maxVal] = findMinMax(sectorPoints, dim);\n\n        // Draw dimension line\n        g.append(\"line\").attr(\"x1\", lineX).attr(\"y1\", 5).attr(\"x2\", lineX).attr(\"y2\", stripHeight - 5).attr(\"stroke\", \"#ddd\").attr(\"stroke-width\", 1).attr(\"stroke-dasharray\", \"3,3\");\n\n        // Draw dimension label\n        g.append(\"text\").attr(\"x\", lineX).attr(\"y\", 0).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"9px\").text(`D${dim}`);\n\n        // Draw min/max labels\n        g.append(\"text\").attr(\"x\", lineX - 15).attr(\"y\", stripHeight - 5).attr(\"text-anchor\", \"end\").attr(\"font-size\", \"8px\").text(`${minVal.toFixed(1)}`);\n        g.append(\"text\").attr(\"x\", lineX + 15).attr(\"y\", stripHeight - 5).attr(\"text-anchor\", \"start\").attr(\"font-size\", \"8px\").text(`${maxVal.toFixed(1)}`);\n\n        // Create a y-scale for this dimension\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([stripHeight - 10, 10]);\n\n        // Plot points on this dimension line\n        sectorPoints.forEach(point => {\n          const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n          const value = pointData[dim][1];\n          const yPos = yScale(value);\n          g.append(\"circle\").attr(\"cx\", lineX).attr(\"cy\", yPos).attr(\"r\", 3).attr(\"fill\", point.Point_ID.map(id => getLabelColor(id))[0]).attr(\"stroke\", \"white\").attr(\"stroke-width\", 0.5).style(\"cursor\", \"pointer\").on(\"mouseover\", event => {\n            const pointIds = point.Point_ID.join(\", \");\n            let associatedLabels = [];\n            if (labelsData && labelsData.labels) {\n              Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n                if (point.Point_ID.some(id => pointList.includes(Number(id)))) {\n                  associatedLabels.push(label);\n                }\n              });\n            }\n            const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n            tooltip.style(\"visibility\", \"visible\").html(`Point_IDs: ${pointIds}<br>` + `Dimension ${dim}: ${value.toFixed(2)}<br>` + `Sector: ${sectorIndex}<br>` + `Label: ${labelText}`);\n            if (setHoveredCoordinates) {\n              setHoveredCoordinates({\n                ...point,\n                label: labelText\n              });\n            }\n          }).on(\"mousemove\", event => {\n            tooltip.style(\"top\", event.pageY + 10 + \"px\").style(\"left\", event.pageX + 10 + \"px\");\n          }).on(\"mouseout\", () => {\n            tooltip.style(\"visibility\", \"hidden\");\n            if (setHoveredCoordinates) {\n              setHoveredCoordinates(null);\n            }\n          });\n        });\n      }\n\n      // Connect points from the same Point_ID\n      const pointsById = {};\n      sectorPoints.forEach(point => {\n        point.Point_ID.forEach(id => {\n          if (!pointsById[id]) {\n            pointsById[id] = {\n              positions: []\n            };\n          }\n          const positions = [];\n          const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n          for (let dim = 0; dim < k; dim++) {\n            const lineX = sectorStart + (dim + 1) * lineSpacing;\n            const [minVal, maxVal] = findMinMax(sectorPoints, dim);\n            const value = pointData[dim][1];\n            const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([stripHeight - 10, 10]);\n            const yPos = yScale(value);\n            positions.push({\n              x: lineX,\n              y: yPos\n            });\n          }\n          pointsById[id].positions = positions;\n        });\n      });\n\n      // Draw connecting lines for each point\n      Object.entries(pointsById).forEach(([id, data]) => {\n        const positions = data.positions;\n        if (positions.length > 1) {\n          for (let i = 0; i < positions.length - 1; i++) {\n            g.append(\"line\").attr(\"x1\", positions[i].x).attr(\"y1\", positions[i].y).attr(\"x2\", positions[i + 1].x).attr(\"y2\", positions[i + 1].y).attr(\"stroke\", getLabelColor(id)).attr(\"stroke-width\", 0.7).attr(\"stroke-opacity\", 0.9);\n          }\n        }\n      });\n    }\n    return () => {\n      tooltip.remove();\n    };\n  }, [jsonData, labelsData, setHoveredCoordinates, stripHeight, stripMargin]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      style: {\n        marginBottom: \"10px\"\n      },\n      children: \"Horizontal Strip - Last Ring Projection\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 318,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: stripRef,\n      style: {\n        width: \"100%\",\n        height: `${stripHeight + stripMargin.top + stripMargin.bottom}px`\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 319,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 317,\n    columnNumber: 9\n  }, this);\n};\n_s(HorizontalStrip, \"PKFyxZ/Uyry01QNkSa4NbT1CSps=\");\n_c = HorizontalStrip;\nexport default HorizontalStrip;\nvar _c;\n$RefreshReg$(_c, \"HorizontalStrip\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HorizontalStrip","jsonData","labelsData","setHoveredCoordinates","stripHeight","stripMargin","top","right","bottom","left","_s","stripRef","Object","keys","length","console","error","svg","select","current","selectAll","remove","subspaces","sort","a","b","lastSubspace","width","parseInt","style","height","attr","g","append","tooltip","colorScale","scaleOrdinal","schemeCategory10","domain","labels","getLabelColor","pointId","label","pointList","Array","isArray","includes","Number","lastRingPoints","sectors","pointsBySector","i","forEach","point","pointData","entries","filter","key","bitVector","map","_","coord","join","sectorIndex","Math","min","push","totalPoints","stripWidth","sectorWidths","sectorStarts","currentStart","sectorPoints","proportion","text","sectorWidth","sectorStart","findMinMax","points","dim","values","p","coords","max","k","lineSpacing","lineX","minVal","maxVal","toFixed","yScale","scaleLinear","range","value","yPos","Point_ID","id","on","event","pointIds","associatedLabels","some","labelText","html","pageY","pageX","pointsById","positions","x","y","data","children","marginBottom","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/strip.js"],"sourcesContent":["import React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HorizontalStrip = ({\n    jsonData,\n    labelsData,\n    setHoveredCoordinates,\n    stripHeight = 100,\n    stripMargin = { top: 20, right: 30, bottom: 30, left: 30 }\n}) => {\n    const stripRef = useRef(null);\n\n    useEffect(() => {\n        if (!jsonData || typeof jsonData !== \"object\" || Object.keys(jsonData).length === 0) {\n            console.error(\"Invalid or empty jsonData:\", jsonData);\n            return;\n        }\n\n        if (!labelsData || typeof labelsData !== \"object\") {\n            console.error(\"Invalid labelsData:\", labelsData);\n            return;\n        }\n\n        // Select SVG and clear it\n        const svg = d3.select(stripRef.current);\n        svg.selectAll(\"*\").remove();\n\n        // Get the last subspace/ring\n        const subspaces = Object.keys(jsonData);\n        subspaces.sort((a, b) => a.length - b.length);\n        const lastSubspace = subspaces[subspaces.length - 1];\n\n        if (!jsonData[lastSubspace] || !jsonData[lastSubspace].length) {\n            return; // No data for the last ring\n        }\n\n        // Setup dimensions\n        const width = parseInt(svg.style(\"width\")) || 800;\n        const height = stripHeight + stripMargin.top + stripMargin.bottom;\n\n        svg.attr(\"height\", height);\n\n        const g = svg\n            .append(\"g\")\n            .attr(\"transform\", `translate(${stripMargin.left}, ${stripMargin.top})`);\n\n        // Setup tooltip\n        const tooltip = d3\n            .select(\"body\")\n            .append(\"div\")\n            .attr(\"class\", \"tooltip\")\n            .style(\"position\", \"absolute\")\n            .style(\"visibility\", \"hidden\")\n            .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n            .style(\"color\", \"white\")\n            .style(\"padding\", \"5px\")\n            .style(\"border-radius\", \"4px\")\n            .style(\"font-size\", \"12px\");\n\n        // Color scales\n        const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(Object.keys(labelsData.labels || {}));\n\n        const getLabelColor = (pointId) => {\n            if (!labelsData || !labelsData.labels) return \"gray\";\n            for (const label of Object.keys(labelsData.labels)) {\n                const pointList = labelsData.labels[label];\n                if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n                    return colorScale(label);\n                }\n            }\n            return \"gray\";\n        };\n\n        // Get points in the last ring\n        const lastRingPoints = jsonData[lastSubspace];\n\n        // Calculate sector distribution\n        const sectors = 2 ** lastSubspace.length;\n        const pointsBySector = {};\n\n        // Initialize sectors\n        for (let i = 0; i < sectors; i++) {\n            pointsBySector[i] = [];\n        }\n\n        // Group points by sector\n        lastRingPoints.forEach(point => {\n            const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n            const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n            const sectorIndex = Math.min(parseInt(bitVector, 2), sectors - 1);\n\n            pointsBySector[sectorIndex].push(point);\n        });\n\n        // Calculate total points for proportions\n        const totalPoints = lastRingPoints.length;\n\n        // Calculate sector widths (proportional to point counts)\n        const stripWidth = width - stripMargin.left - stripMargin.right;\n        const sectorWidths = {};\n        let sectorStarts = {};\n        let currentStart = 0;\n\n        for (let i = 0; i < sectors; i++) {\n            const sectorPoints = pointsBySector[i].length;\n            const proportion = sectorPoints / totalPoints;\n            sectorWidths[i] = stripWidth * proportion;\n            sectorStarts[i] = currentStart;\n            currentStart += sectorWidths[i];\n        }\n\n        // Draw sector backgrounds\n        for (let i = 0; i < sectors; i++) {\n            const sectorPoints = pointsBySector[i].length;\n            if (sectorPoints === 0) continue;\n\n            g.append(\"rect\")\n                .attr(\"x\", sectorStarts[i])\n                .attr(\"y\", 0)\n                .attr(\"width\", sectorWidths[i])\n                .attr(\"height\", stripHeight)\n                .attr(\"fill\", i % 2 === 0 ? \"#f0f0f0\" : \"#e0e0e0\")\n                .attr(\"stroke\", \"#ccc\")\n                .attr(\"stroke-width\", 0.5);\n\n            // Add sector label\n            g.append(\"text\")\n                .attr(\"x\", sectorStarts[i] + sectorWidths[i] / 2)\n                .attr(\"y\", stripHeight + 20)\n                .attr(\"text-anchor\", \"middle\")\n                .attr(\"font-size\", \"10px\")\n                .text(`Sector ${i} (${sectorPoints})`);\n        }\n\n        // Draw dividing lines between sectors\n        for (let i = 1; i < sectors; i++) {\n            if (sectorStarts[i] > 0) {\n                g.append(\"line\")\n                    .attr(\"x1\", sectorStarts[i])\n                    .attr(\"y1\", 0)\n                    .attr(\"x2\", sectorStarts[i])\n                    .attr(\"y2\", stripHeight)\n                    .attr(\"stroke\", \"#999\")\n                    .attr(\"stroke-width\", 1);\n            }\n        }\n\n        // Draw points\n        for (let sectorIndex = 0; sectorIndex < sectors; sectorIndex++) {\n            const sectorPoints = pointsBySector[sectorIndex];\n            const sectorWidth = sectorWidths[sectorIndex];\n            const sectorStart = sectorStarts[sectorIndex];\n\n            if (sectorPoints.length === 0) continue;\n\n            // Create scale for dimension values in this sector\n            const findMinMax = (points, dim) => {\n                const values = points.map(p => {\n                    const coords = Object.entries(p).filter(([key]) => key !== \"Point_ID\");\n                    return coords[dim][1]; // Get the value for this dimension\n                });\n                return [Math.min(...values), Math.max(...values)];\n            };\n\n            // Set up k equidistant vertical lines within the sector\n            const k = lastSubspace.length; // number of dimensions\n            const lineSpacing = sectorWidth / (k + 1);\n\n            // Draw vertical dimension lines\n            for (let dim = 0; dim < k; dim++) {\n                const lineX = sectorStart + (dim + 1) * lineSpacing;\n                const [minVal, maxVal] = findMinMax(sectorPoints, dim);\n\n                // Draw dimension line\n                g.append(\"line\")\n                    .attr(\"x1\", lineX)\n                    .attr(\"y1\", 5)\n                    .attr(\"x2\", lineX)\n                    .attr(\"y2\", stripHeight - 5)\n                    .attr(\"stroke\", \"#ddd\")\n                    .attr(\"stroke-width\", 1)\n                    .attr(\"stroke-dasharray\", \"3,3\");\n\n                // Draw dimension label\n                g.append(\"text\")\n                    .attr(\"x\", lineX)\n                    .attr(\"y\", 0)\n                    .attr(\"text-anchor\", \"middle\")\n                    .attr(\"font-size\", \"9px\")\n                    .text(`D${dim}`);\n\n                // Draw min/max labels\n                g.append(\"text\")\n                    .attr(\"x\", lineX - 15)\n                    .attr(\"y\", stripHeight - 5)\n                    .attr(\"text-anchor\", \"end\")\n                    .attr(\"font-size\", \"8px\")\n                    .text(`${minVal.toFixed(1)}`);\n\n                g.append(\"text\")\n                    .attr(\"x\", lineX + 15)\n                    .attr(\"y\", stripHeight - 5)\n                    .attr(\"text-anchor\", \"start\")\n                    .attr(\"font-size\", \"8px\")\n                    .text(`${maxVal.toFixed(1)}`);\n\n                // Create a y-scale for this dimension\n                const yScale = d3.scaleLinear()\n                    .domain([minVal, maxVal])\n                    .range([stripHeight - 10, 10]);\n\n                // Plot points on this dimension line\n                sectorPoints.forEach(point => {\n                    const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n                    const value = pointData[dim][1];\n                    const yPos = yScale(value);\n\n                    g.append(\"circle\")\n                        .attr(\"cx\", lineX)\n                        .attr(\"cy\", yPos)\n                        .attr(\"r\", 3)\n                        .attr(\"fill\", point.Point_ID.map(id => getLabelColor(id))[0])\n                        .attr(\"stroke\", \"white\")\n                        .attr(\"stroke-width\", 0.5)\n                        .style(\"cursor\", \"pointer\")\n                        .on(\"mouseover\", (event) => {\n                            const pointIds = point.Point_ID.join(\", \");\n                            let associatedLabels = [];\n                            if (labelsData && labelsData.labels) {\n                                Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n                                    if (point.Point_ID.some(id => pointList.includes(Number(id)))) {\n                                        associatedLabels.push(label);\n                                    }\n                                });\n                            }\n                            const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n\n                            tooltip\n                                .style(\"visibility\", \"visible\")\n                                .html(\n                                    `Point_IDs: ${pointIds}<br>` +\n                                    `Dimension ${dim}: ${value.toFixed(2)}<br>` +\n                                    `Sector: ${sectorIndex}<br>` +\n                                    `Label: ${labelText}`\n                                );\n\n                            if (setHoveredCoordinates) {\n                                setHoveredCoordinates({ ...point, label: labelText });\n                            }\n                        })\n                        .on(\"mousemove\", (event) => {\n                            tooltip\n                                .style(\"top\", event.pageY + 10 + \"px\")\n                                .style(\"left\", event.pageX + 10 + \"px\");\n                        })\n                        .on(\"mouseout\", () => {\n                            tooltip.style(\"visibility\", \"hidden\");\n                            if (setHoveredCoordinates) {\n                                setHoveredCoordinates(null);\n                            }\n                        });\n                });\n            }\n\n            // Connect points from the same Point_ID\n            const pointsById = {};\n            sectorPoints.forEach(point => {\n                point.Point_ID.forEach(id => {\n                    if (!pointsById[id]) {\n                        pointsById[id] = { positions: [] };\n                    }\n\n                    const positions = [];\n                    const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n\n                    for (let dim = 0; dim < k; dim++) {\n                        const lineX = sectorStart + (dim + 1) * lineSpacing;\n                        const [minVal, maxVal] = findMinMax(sectorPoints, dim);\n                        const value = pointData[dim][1];\n\n                        const yScale = d3.scaleLinear()\n                            .domain([minVal, maxVal])\n                            .range([stripHeight - 10, 10]);\n\n                        const yPos = yScale(value);\n                        positions.push({ x: lineX, y: yPos });\n                    }\n\n                    pointsById[id].positions = positions;\n                });\n            });\n\n            // Draw connecting lines for each point\n            Object.entries(pointsById).forEach(([id, data]) => {\n                const positions = data.positions;\n                if (positions.length > 1) {\n                    for (let i = 0; i < positions.length - 1; i++) {\n                        g.append(\"line\")\n                            .attr(\"x1\", positions[i].x)\n                            .attr(\"y1\", positions[i].y)\n                            .attr(\"x2\", positions[i + 1].x)\n                            .attr(\"y2\", positions[i + 1].y)\n                            .attr(\"stroke\", getLabelColor(id))\n                            .attr(\"stroke-width\", 0.7)\n                            .attr(\"stroke-opacity\", 0.9);\n                    }\n                }\n            });\n        }\n\n        return () => {\n            tooltip.remove();\n        };\n    }, [jsonData, labelsData, setHoveredCoordinates, stripHeight, stripMargin]);\n\n    return (\n        <div>\n            <h3 style={{ marginBottom: \"10px\" }}>Horizontal Strip - Last Ring Projection</h3>\n            <svg\n                ref={stripRef}\n                style={{ width: \"100%\", height: `${stripHeight + stripMargin.top + stripMargin.bottom}px` }}\n            ></svg>\n        </div>\n    );\n};\n\nexport default HorizontalStrip;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}