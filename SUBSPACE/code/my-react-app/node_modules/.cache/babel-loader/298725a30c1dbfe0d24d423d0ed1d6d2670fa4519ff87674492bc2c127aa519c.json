{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n//   console.log(labelsData);\n//   useEffect(() => {\n//     if (\n//       !jsonData ||\n//       typeof jsonData !== \"object\" ||\n//       Object.keys(jsonData).length === 0\n//     ) {\n//       console.error(\"Invalid or empty jsonData:\", jsonData);\n//       return;\n//     }\n\n//     if (!labelsData || typeof labelsData !== \"object\") {\n//       console.error(\"Invalid labelsData:\", labelsData);\n//       return;\n//     }\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const pointPositions = {};\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     // Generate unique colors for each label\n//     // Define color scale globally to avoid unnecessary re-renders\n\n//     // Step 1: Extract unique labels dynamically\n//     const labelKeys = Object.keys(labelsData);\n//     console.log(labelsData);\n//     // Step 2: Create a color scale dynamically based on the number of labels\n//     const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(labelKeys);\n\n// const getLabelColor = (pointId) => {\n//   if (!labelsData || !labelsData.labels) return \"gray\"; // Ensure labelsData is properly structured\n\n//   for (const label of Object.keys(labelsData.labels)) {\n//     const pointList = labelsData.labels[label];\n\n//     if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n//       return colorScale(label); // Ensure label is passed correctly\n//     }\n//   }\n\n//   return \"gray\"; // Default color if no match found\n// };\n\n//     const getSectorColor = (index, sectorIndex) => {\n//       return d3.hsl(sectorIndex % 2 === 1 ? 7837 : 0, 1, 0.5);\n//     };\n//     pointsData.forEach((subspace, index) => {\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1);\n\n//       // const rotationOffset = index === 0 ? Math.PI / 2 : 0;\n//       const rotationOffset = Math.PI / 2; // Apply uniform rotation\n\n//       for (let i = 0; i < sectors; i++) {\n//         g.append(\"path\")\n//           .attr(\n//             \"d\",\n//             d3\n//               .arc()\n//               .innerRadius(innerRadius)\n//               .outerRadius(outerRadius)\n//               .startAngle((2 * Math.PI * i) / sectors + rotationOffset)\n//               .endAngle((2 * Math.PI * (i + 1)) / sectors + rotationOffset)\n//           )\n//           .attr(\"fill\", getSectorColor(index, i))\n//           .attr(\"fill-opacity\", 0.3)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.5);\n\n//         g.append(\"text\")\n//           .attr(\"x\", 0)\n//           .attr(\"y\", -outerRadius - 5)\n//           .attr(\"text-anchor\", \"middle\")\n//           .attr(\"font-size\", \"12px\")\n//           .attr(\"font-weight\", \"bold\")\n//           .text(subspace.key);\n//       }\n\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         const x2 = innerRadius * Math.cos(angle);\n//         const y2 = innerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", x2)\n//           .attr(\"y1\", y2)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.25)\n//           .style(\"pointer-events\", \"none\");\n//       }\n\n//       subspace.points.forEach((point, i) => {\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n//           .join(\"\");\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         const bitVectorIndex = parseInt(bitVector, 2);\n//         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n\n//         const centerAngle = (angleStart + angleEnd) / 2;\n\n//         const totalPoints = subspace.points.length;\n//         const clusterFactor = 0.86;\n//         const overlapRadius =\n//           innerRadius +\n//           (clusterFactor * (outerRadius - innerRadius) * (i % totalPoints)) /\n//             totalPoints;\n\n//         const x = overlapRadius * Math.cos(centerAngle);\n//         const y = overlapRadius * Math.sin(centerAngle);\n//         point.Point_ID.forEach((id) => {\n//           if (!pointPositions[id]) {\n//             pointPositions[id] = [];\n//           }\n//           pointPositions[id].push({ x, y, point, subspaceId: subspace.key });\n//         });\n//         const legend = svg.append(\"g\").attr(\"transform\", \"translate(10, 10)\");\n//         const legendData = [\n//           { color: \"yellow\", label: \"Positive Bit\" },\n//           { color: \"pink\", label: \"Negative Bit\" },\n//         ];\n//         legendData.forEach((item, index) => {\n//           legend\n//             .append(\"rect\")\n//             .attr(\"x\", 0)\n//             .attr(\"y\", index * 20)\n//             .attr(\"width\", 15)\n//             .attr(\"height\", 15)\n//             .attr(\"fill\", item.color);\n\n//           legend\n//             .append(\"text\")\n//             .attr(\"x\", 20)\n//             .attr(\"y\", index * 20 + 12)\n//             .text(item.label)\n//             .attr(\"font-size\", \"12px\")\n//             .attr(\"alignment-baseline\", \"middle\");\n//         });\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             const pointIds = point.Point_ID.join(\", \");\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(\n//                 `Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(\n//                   2\n//                 )}, ${y.toFixed(2)})<br>Subspace: ${subspace.key}`\n//               );\n//             setHoveredCoordinates(point);\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//             setHoveredCoordinates(null);\n//           });\n//       });\n//     });\n\n//     Object.entries(pointPositions).forEach(([pointId, positions]) => {\n//       if (positions.length > 1) {\n//         for (let i = 0; i < positions.length - 1; i++) {\n//           g.append(\"line\")\n//             .attr(\"x1\", positions[i].x)\n//             .attr(\"y1\", positions[i].y)\n//             .attr(\"x2\", positions[i + 1].x)\n//             .attr(\"y2\", positions[i + 1].y)\n//             .attr(\"stroke\", getLabelColor(pointId))\n//             .attr(\"stroke-width\", 0.3)\n//             .on(\"mouseover\", (event) => {\n//               tooltip\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`Connection: Point_ID ${pointId}`);\n//             })\n//             .on(\"mousemove\", (event) => {\n//               tooltip\n//                 .style(\"top\", event.pageY + 10 + \"px\")\n//                 .style(\"left\", event.pageX + 10 + \"px\");\n//             })\n//             .on(\"mouseout\", () => {\n//               tooltip.style(\"visibility\", \"hidden\");\n//             });\n//         }\n//       }\n//     });\n\n//     const zoom = d3.zoom().on(\"zoom\", (event) => {\n//       g.attr(\"transform\", event.transform);\n//     });\n\n//     svg.call(zoom);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  labelsData,\n  setHoveredCoordinates\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  const [visibleRings, setVisibleRings] = useState({});\n  const [allCollapsed, setAllCollapsed] = useState(false);\n  useEffect(() => {\n    if (!jsonData || typeof jsonData !== \"object\" || Object.keys(jsonData).length === 0) {\n      console.error(\"Invalid or empty jsonData:\", jsonData);\n      return;\n    }\n    if (!labelsData || typeof labelsData !== \"object\") {\n      console.error(\"Invalid labelsData:\", labelsData);\n      return;\n    }\n    const subspaces = Object.keys(jsonData);\n    subspaces.sort((a, b) => a.length - b.length);\n    const pointsData = subspaces.map(key => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length,\n      subspaceId: key\n    }));\n    if (Object.keys(visibleRings).length === 0) {\n      const initialVisibility = {};\n      subspaces.forEach((_, i) => {\n        initialVisibility[i] = true;\n      });\n      setVisibleRings(initialVisibility);\n    }\n    const svg = d3.select(graphRef.current);\n    const width = 800;\n    const height = 800;\n    const margin = 20;\n    svg.selectAll(\"*\").remove();\n    const maxRadius = Math.min(width, height) / 2 - margin;\n    const g = svg.attr(\"width\", width).attr(\"height\", height).append(\"g\").attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n    const pointPositions = {};\n\n    // Tooltip\n    const tooltip = d3.select(\"body\").append(\"div\").attr(\"class\", \"tooltip\").style(\"position\", \"absolute\").style(\"visibility\", \"hidden\").style(\"background-color\", \"rgba(0, 0, 0, 0.7)\").style(\"color\", \"white\").style(\"padding\", \"5px\").style(\"border-radius\", \"4px\").style(\"font-size\", \"12px\");\n    const getSectorColor = (index, sectorIndex) => d3.hsl(sectorIndex % 2 === 1 ? 7837 : 0, 1, 0.5);\n    pointsData.forEach((subspace, index) => {\n      const innerRadius = index / subspaces.length * maxRadius;\n      const outerRadius = (index + 1) / subspaces.length * maxRadius;\n      const sectors = 2 ** (index + 1);\n      const rotationOffset = Math.PI / 2;\n      if (!visibleRings[index]) return; // Skip rendering if ring is collapsed\n\n      for (let i = 0; i < sectors; i++) {\n        g.append(\"path\").attr(\"d\", d3.arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(2 * Math.PI * i / sectors + rotationOffset).endAngle(2 * Math.PI * (i + 1) / sectors + rotationOffset)).attr(\"fill\", getSectorColor(index, i)).attr(\"fill-opacity\", 0.3).attr(\"stroke\", \"black\").attr(\"stroke-width\", 0.5);\n      }\n\n      // Collapse/Expand button for each ring\n      g.append(\"text\").attr(\"x\", 0).attr(\"y\", -outerRadius - 10).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"14px\").attr(\"font-weight\", \"bold\").attr(\"cursor\", \"pointer\").text(visibleRings[index] ? \"−\" : \"+\").on(\"click\", () => {\n        setVisibleRings(prev => ({\n          ...prev,\n          [index]: !prev[index]\n        }));\n      });\n      subspace.points.forEach((point, i) => {\n        const minRadius = innerRadius;\n        const maxRadius = outerRadius;\n        const bitVector = Object.entries(point).filter(([key]) => key !== \"Point_ID\").map(([_, coord]) => coord >= 0 ? 1 : 0).join(\"\");\n        const bitVectorIndex = parseInt(bitVector, 2);\n        const angleStart = 2 * Math.PI * bitVectorIndex / sectors;\n        const angleEnd = 2 * Math.PI * (bitVectorIndex + 1) / sectors;\n        const centerAngle = (angleStart + angleEnd) / 2;\n        const totalPoints = subspace.points.length;\n        const clusterFactor = 0.86;\n        const overlapRadius = innerRadius + clusterFactor * (outerRadius - innerRadius) * (i % totalPoints) / totalPoints;\n        const x = overlapRadius * Math.cos(centerAngle);\n        const y = overlapRadius * Math.sin(centerAngle);\n        point.Point_ID.forEach(id => {\n          if (!pointPositions[id]) {\n            pointPositions[id] = [];\n          }\n          pointPositions[id].push({\n            x,\n            y,\n            point,\n            subspaceId: subspace.key\n          });\n        });\n        g.append(\"circle\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", 3).attr(\"fill\", \"black\").attr(\"stroke\", \"white\").attr(\"stroke-width\", 0.5).style(\"pointer-events\", \"visible\").on(\"mouseover\", event => {\n          const pointIds = point.Point_ID.join(\", \");\n          tooltip.style(\"visibility\", \"visible\").html(`Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})<br>Subspace: ${subspace.key}`);\n          setHoveredCoordinates(point);\n        }).on(\"mousemove\", event => {\n          tooltip.style(\"top\", event.pageY + 10 + \"px\").style(\"left\", event.pageX + 10 + \"px\");\n        }).on(\"mouseout\", () => {\n          tooltip.style(\"visibility\", \"hidden\");\n          setHoveredCoordinates(null);\n        });\n      });\n    });\n\n    // Global Collapse/Expand button\n    svg.append(\"text\").attr(\"x\", width / 2 - 50).attr(\"y\", 20).attr(\"font-size\", \"16px\").attr(\"font-weight\", \"bold\").attr(\"cursor\", \"pointer\").text(allCollapsed ? \"Expand All\" : \"Collapse All\").on(\"click\", () => {\n      setAllCollapsed(!allCollapsed);\n      setVisibleRings(prev => {\n        const newVisibility = {};\n        Object.keys(prev).forEach(key => {\n          newVisibility[key] = allCollapsed || key == subspaces.length - 1;\n        });\n        return newVisibility;\n      });\n    });\n    const zoom = d3.zoom().on(\"zoom\", event => {\n      g.attr(\"transform\", event.transform);\n    });\n    svg.call(zoom);\n  }, [jsonData, labelsData, visibleRings, allCollapsed, setHoveredCoordinates]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: graphRef,\n    style: {\n      width: \"800px\",\n      height: \"800px\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 458,\n    columnNumber: 10\n  }, this);\n};\n_s(HierarchicalGraph, \"G41E9RgyBscZ+ABsWswbw9u7SI4=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","useState","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","labelsData","setHoveredCoordinates","_s","graphRef","visibleRings","setVisibleRings","allCollapsed","setAllCollapsed","Object","keys","length","console","error","subspaces","sort","a","b","pointsData","map","key","points","dimensions","subspaceId","initialVisibility","forEach","_","i","svg","select","current","width","height","margin","selectAll","remove","maxRadius","Math","min","g","attr","append","pointPositions","tooltip","style","getSectorColor","index","sectorIndex","hsl","subspace","innerRadius","outerRadius","sectors","rotationOffset","PI","arc","startAngle","endAngle","text","on","prev","point","minRadius","bitVector","entries","filter","coord","join","bitVectorIndex","parseInt","angleStart","angleEnd","centerAngle","totalPoints","clusterFactor","overlapRadius","x","cos","y","sin","Point_ID","id","push","event","pointIds","html","toFixed","pageY","pageX","newVisibility","zoom","transform","call","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n//   console.log(labelsData);\n//   useEffect(() => {\n//     if (\n//       !jsonData ||\n//       typeof jsonData !== \"object\" ||\n//       Object.keys(jsonData).length === 0\n//     ) {\n//       console.error(\"Invalid or empty jsonData:\", jsonData);\n//       return;\n//     }\n\n//     if (!labelsData || typeof labelsData !== \"object\") {\n//       console.error(\"Invalid labelsData:\", labelsData);\n//       return;\n//     }\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n\n//     const svg = d3.select(graphRef.current);\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n\n//     svg.selectAll(\"*\").remove();\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const pointPositions = {};\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     // Generate unique colors for each label\n//     // Define color scale globally to avoid unnecessary re-renders\n\n//     // Step 1: Extract unique labels dynamically\n//     const labelKeys = Object.keys(labelsData);\n//     console.log(labelsData);\n//     // Step 2: Create a color scale dynamically based on the number of labels\n//     const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(labelKeys);\n\n// const getLabelColor = (pointId) => {\n//   if (!labelsData || !labelsData.labels) return \"gray\"; // Ensure labelsData is properly structured\n\n//   for (const label of Object.keys(labelsData.labels)) {\n//     const pointList = labelsData.labels[label];\n\n//     if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n//       return colorScale(label); // Ensure label is passed correctly\n//     }\n//   }\n\n//   return \"gray\"; // Default color if no match found\n// };\n\n\n\n//     const getSectorColor = (index, sectorIndex) => {\n//       return d3.hsl(sectorIndex % 2 === 1 ? 7837 : 0, 1, 0.5);\n//     };\n//     pointsData.forEach((subspace, index) => {\n//       const innerRadius = (index / subspaces.length) * maxRadius;\n//       const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//       const sectors = 2 ** (index + 1);\n\n//       // const rotationOffset = index === 0 ? Math.PI / 2 : 0;\n//       const rotationOffset = Math.PI / 2; // Apply uniform rotation\n\n//       for (let i = 0; i < sectors; i++) {\n//         g.append(\"path\")\n//           .attr(\n//             \"d\",\n//             d3\n//               .arc()\n//               .innerRadius(innerRadius)\n//               .outerRadius(outerRadius)\n//               .startAngle((2 * Math.PI * i) / sectors + rotationOffset)\n//               .endAngle((2 * Math.PI * (i + 1)) / sectors + rotationOffset)\n//           )\n//           .attr(\"fill\", getSectorColor(index, i))\n//           .attr(\"fill-opacity\", 0.3)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.5);\n\n//         g.append(\"text\")\n//           .attr(\"x\", 0)\n//           .attr(\"y\", -outerRadius - 5)\n//           .attr(\"text-anchor\", \"middle\")\n//           .attr(\"font-size\", \"12px\")\n//           .attr(\"font-weight\", \"bold\")\n//           .text(subspace.key);\n//       }\n\n//       for (let i = 0; i < sectors; i++) {\n//         const angle = (2 * Math.PI * i) / sectors;\n//         const x1 = outerRadius * Math.cos(angle);\n//         const y1 = outerRadius * Math.sin(angle);\n//         const x2 = innerRadius * Math.cos(angle);\n//         const y2 = innerRadius * Math.sin(angle);\n//         g.append(\"line\")\n//           .attr(\"x1\", x2)\n//           .attr(\"y1\", y2)\n//           .attr(\"x2\", x1)\n//           .attr(\"y2\", y1)\n//           .attr(\"stroke\", \"black\")\n//           .attr(\"stroke-width\", 0.25)\n//           .style(\"pointer-events\", \"none\");\n//       }\n\n//       subspace.points.forEach((point, i) => {\n//         const pointData = Object.entries(point).filter(\n//           ([key]) => key !== \"Point_ID\"\n//         );\n//         const bitVector = pointData\n//           .map(([key, coord]) => (coord >= 0 ? 1 : 0))\n//           .join(\"\");\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius =\n//           minRadius + Math.random() * (maxRadius - minRadius);\n\n//         const bitVectorIndex = parseInt(bitVector, 2);\n//         const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n\n//         const centerAngle = (angleStart + angleEnd) / 2;\n\n//         const totalPoints = subspace.points.length;\n//         const clusterFactor = 0.86;\n//         const overlapRadius =\n//           innerRadius +\n//           (clusterFactor * (outerRadius - innerRadius) * (i % totalPoints)) /\n//             totalPoints;\n\n//         const x = overlapRadius * Math.cos(centerAngle);\n//         const y = overlapRadius * Math.sin(centerAngle);\n//         point.Point_ID.forEach((id) => {\n//           if (!pointPositions[id]) {\n//             pointPositions[id] = [];\n//           }\n//           pointPositions[id].push({ x, y, point, subspaceId: subspace.key });\n//         });\n//         const legend = svg.append(\"g\").attr(\"transform\", \"translate(10, 10)\");\n//         const legendData = [\n//           { color: \"yellow\", label: \"Positive Bit\" },\n//           { color: \"pink\", label: \"Negative Bit\" },\n//         ];\n//         legendData.forEach((item, index) => {\n//           legend\n//             .append(\"rect\")\n//             .attr(\"x\", 0)\n//             .attr(\"y\", index * 20)\n//             .attr(\"width\", 15)\n//             .attr(\"height\", 15)\n//             .attr(\"fill\", item.color);\n\n//           legend\n//             .append(\"text\")\n//             .attr(\"x\", 20)\n//             .attr(\"y\", index * 20 + 12)\n//             .text(item.label)\n//             .attr(\"font-size\", \"12px\")\n//             .attr(\"alignment-baseline\", \"middle\");\n//         });\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             const pointIds = point.Point_ID.join(\", \");\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(\n//                 `Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(\n//                   2\n//                 )}, ${y.toFixed(2)})<br>Subspace: ${subspace.key}`\n//               );\n//             setHoveredCoordinates(point);\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//             setHoveredCoordinates(null);\n//           });\n//       });\n//     });\n\n//     Object.entries(pointPositions).forEach(([pointId, positions]) => {\n//       if (positions.length > 1) {\n//         for (let i = 0; i < positions.length - 1; i++) {\n//           g.append(\"line\")\n//             .attr(\"x1\", positions[i].x)\n//             .attr(\"y1\", positions[i].y)\n//             .attr(\"x2\", positions[i + 1].x)\n//             .attr(\"y2\", positions[i + 1].y)\n//             .attr(\"stroke\", getLabelColor(pointId))\n//             .attr(\"stroke-width\", 0.3)\n//             .on(\"mouseover\", (event) => {\n//               tooltip\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`Connection: Point_ID ${pointId}`);\n//             })\n//             .on(\"mousemove\", (event) => {\n//               tooltip\n//                 .style(\"top\", event.pageY + 10 + \"px\")\n//                 .style(\"left\", event.pageX + 10 + \"px\");\n//             })\n//             .on(\"mouseout\", () => {\n//               tooltip.style(\"visibility\", \"hidden\");\n//             });\n//         }\n//       }\n//     });\n\n//     const zoom = d3.zoom().on(\"zoom\", (event) => {\n//       g.attr(\"transform\", event.transform);\n//     });\n\n//     svg.call(zoom);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates }) => {\n  const graphRef = useRef(null);\n  const [visibleRings, setVisibleRings] = useState({});\n  const [allCollapsed, setAllCollapsed] = useState(false);\n\n  useEffect(() => {\n    if (\n      !jsonData ||\n      typeof jsonData !== \"object\" ||\n      Object.keys(jsonData).length === 0\n    ) {\n      console.error(\"Invalid or empty jsonData:\", jsonData);\n      return;\n    }\n\n    if (!labelsData || typeof labelsData !== \"object\") {\n      console.error(\"Invalid labelsData:\", labelsData);\n      return;\n    }\n\n    const subspaces = Object.keys(jsonData);\n    subspaces.sort((a, b) => a.length - b.length);\n\n    const pointsData = subspaces.map((key) => ({\n      key,\n      points: jsonData[key],\n      dimensions: key.length,\n      subspaceId: key,\n    }));\n\n    if (Object.keys(visibleRings).length === 0) {\n      const initialVisibility = {};\n      subspaces.forEach((_, i) => {\n        initialVisibility[i] = true;\n      });\n      setVisibleRings(initialVisibility);\n    }\n\n    const svg = d3.select(graphRef.current);\n    const width = 800;\n    const height = 800;\n    const margin = 20;\n\n    svg.selectAll(\"*\").remove();\n    const maxRadius = Math.min(width, height) / 2 - margin;\n    const g = svg\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .append(\"g\")\n      .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n    const pointPositions = {};\n\n    // Tooltip\n    const tooltip = d3\n      .select(\"body\")\n      .append(\"div\")\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"visibility\", \"hidden\")\n      .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n      .style(\"color\", \"white\")\n      .style(\"padding\", \"5px\")\n      .style(\"border-radius\", \"4px\")\n      .style(\"font-size\", \"12px\");\n\n    const getSectorColor = (index, sectorIndex) =>\n      d3.hsl(sectorIndex % 2 === 1 ? 7837 : 0, 1, 0.5);\n\n    pointsData.forEach((subspace, index) => {\n      const innerRadius = (index / subspaces.length) * maxRadius;\n      const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n      const sectors = 2 ** (index + 1);\n      const rotationOffset = Math.PI / 2;\n\n      if (!visibleRings[index]) return; // Skip rendering if ring is collapsed\n\n      for (let i = 0; i < sectors; i++) {\n        g.append(\"path\")\n          .attr(\n            \"d\",\n            d3\n              .arc()\n              .innerRadius(innerRadius)\n              .outerRadius(outerRadius)\n              .startAngle((2 * Math.PI * i) / sectors + rotationOffset)\n              .endAngle((2 * Math.PI * (i + 1)) / sectors + rotationOffset)\n          )\n          .attr(\"fill\", getSectorColor(index, i))\n          .attr(\"fill-opacity\", 0.3)\n          .attr(\"stroke\", \"black\")\n          .attr(\"stroke-width\", 0.5);\n      }\n\n      // Collapse/Expand button for each ring\n      g.append(\"text\")\n        .attr(\"x\", 0)\n        .attr(\"y\", -outerRadius - 10)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"14px\")\n        .attr(\"font-weight\", \"bold\")\n        .attr(\"cursor\", \"pointer\")\n        .text(visibleRings[index] ? \"−\" : \"+\")\n        .on(\"click\", () => {\n          setVisibleRings((prev) => ({ ...prev, [index]: !prev[index] }));\n        });\n\n      subspace.points.forEach((point, i) => {\n        const minRadius = innerRadius;\n        const maxRadius = outerRadius;\n        const bitVector = Object.entries(point)\n          .filter(([key]) => key !== \"Point_ID\")\n          .map(([_, coord]) => (coord >= 0 ? 1 : 0))\n          .join(\"\");\n\n        const bitVectorIndex = parseInt(bitVector, 2);\n        const angleStart = (2 * Math.PI * bitVectorIndex) / sectors;\n        const angleEnd = (2 * Math.PI * (bitVectorIndex + 1)) / sectors;\n        const centerAngle = (angleStart + angleEnd) / 2;\n        const totalPoints = subspace.points.length;\n        const clusterFactor = 0.86;\n        const overlapRadius =\n          innerRadius +\n          (clusterFactor * (outerRadius - innerRadius) * (i % totalPoints)) /\n            totalPoints;\n\n        const x = overlapRadius * Math.cos(centerAngle);\n        const y = overlapRadius * Math.sin(centerAngle);\n        point.Point_ID.forEach((id) => {\n          if (!pointPositions[id]) {\n            pointPositions[id] = [];\n          }\n          pointPositions[id].push({ x, y, point, subspaceId: subspace.key });\n        });\n\n        g.append(\"circle\")\n          .attr(\"cx\", x)\n          .attr(\"cy\", y)\n          .attr(\"r\", 3)\n          .attr(\"fill\", \"black\")\n          .attr(\"stroke\", \"white\")\n          .attr(\"stroke-width\", 0.5)\n          .style(\"pointer-events\", \"visible\")\n          .on(\"mouseover\", (event) => {\n            const pointIds = point.Point_ID.join(\", \");\n            tooltip\n              .style(\"visibility\", \"visible\")\n              .html(\n                `Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(\n                  2\n                )}, ${y.toFixed(2)})<br>Subspace: ${subspace.key}`\n              );\n            setHoveredCoordinates(point);\n          })\n          .on(\"mousemove\", (event) => {\n            tooltip\n              .style(\"top\", event.pageY + 10 + \"px\")\n              .style(\"left\", event.pageX + 10 + \"px\");\n          })\n          .on(\"mouseout\", () => {\n            tooltip.style(\"visibility\", \"hidden\");\n            setHoveredCoordinates(null);\n          });\n      });\n    });\n\n    // Global Collapse/Expand button\n    svg\n      .append(\"text\")\n      .attr(\"x\", width / 2 - 50)\n      .attr(\"y\", 20)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"font-weight\", \"bold\")\n      .attr(\"cursor\", \"pointer\")\n      .text(allCollapsed ? \"Expand All\" : \"Collapse All\")\n      .on(\"click\", () => {\n        setAllCollapsed(!allCollapsed);\n        setVisibleRings((prev) => {\n          const newVisibility = {};\n          Object.keys(prev).forEach((key) => {\n            newVisibility[key] = allCollapsed || key == subspaces.length - 1;\n          });\n          return newVisibility;\n        });\n      });\n\n    const zoom = d3.zoom().on(\"zoom\", (event) => {\n      g.attr(\"transform\", event.transform);\n    });\n\n    svg.call(zoom);\n  }, [jsonData, labelsData, visibleRings, allCollapsed, setHoveredCoordinates]);\n\n  return <svg ref={graphRef} style={{ width: \"800px\", height: \"800px\" }}></svg>;\n};\n\nexport default HierarchicalGraph;\n"],"mappings":";;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAE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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}