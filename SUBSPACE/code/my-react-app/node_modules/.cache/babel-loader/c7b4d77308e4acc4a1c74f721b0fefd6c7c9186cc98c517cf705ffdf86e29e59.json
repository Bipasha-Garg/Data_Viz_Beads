{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point,\n//           bitVector: assignBitVector(point), });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(20)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-100))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n//       )\n\n//       .force(\"charge\", d3.forceManyBody().strength(-10))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  setHoveredCoordinates\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(key => key !== \"Cluster\" && key !== \"Bead\");\n\n    // Helper to calculate centroid\n    const calculateCentroid = points => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach(key => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      // Compute average for each dimension\n      Object.keys(sum).forEach(key => sum[key] /= n);\n      return sum;\n    };\n    // Assign bit vectors based on coordinate keys (planes)\n    const assignBitVector = point => {\n      return coordinateKeys.map(key => point[key] >= 0 ? \"1\" : \"0\").join(\"\");\n    };\n\n    // Function to calculate hamming distance of two bit vectors\n    const calculateHammingDistance = (bitVector1, bitVector2) => {\n      let dist = 0;\n      for (let i = 0; i < bitVector1.length; i++) {\n        if (bitVector1[i] !== bitVector2[i]) {\n          dist++;\n        }\n      }\n      return dist;\n    };\n    // Function to calculate a distance metric based on euclidean distance\n    const calculateEuclideanDistance = (point1, point2, coordinateKeys) => {\n      let dist = 0;\n      for (let i = 0; i < coordinateKeys.length; i++) {\n        let key = coordinateKeys[i];\n        dist += (point1[key] - point2[key]) ** 2;\n      }\n      return Math.sqrt(dist);\n    };\n    // Parse and process data\n    const clusters = d3.group(jsonData, d => d.Cluster);\n    const beads = d3.group(jsonData, d => `${d.Cluster}-${d.Bead}`);\n\n    // Root centroid\n    const rootCentroid = calculateCentroid(jsonData);\n    const rootBitVector = assignBitVector(rootCentroid);\n\n    // Cluster centroids\n    const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n      cluster,\n      centroid: calculateCentroid(points),\n      bitVector: assignBitVector(calculateCentroid(points))\n    }));\n\n    // Bead centroids\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      return {\n        cluster,\n        bead,\n        centroid: calculateCentroid(points),\n        points,\n        bitVector: assignBitVector(calculateCentroid(points))\n      };\n    });\n\n    // Build hierarchical links\n    const links = [];\n    const nodes = [{\n      id: \"root\",\n      ...rootCentroid,\n      bitVector: rootBitVector\n    } // Root node\n    ];\n\n    // Add cluster nodes and links\n    clusterCentroids.forEach(({\n      cluster,\n      centroid,\n      bitVector\n    }) => {\n      nodes.push({\n        id: `cluster-${cluster}`,\n        ...centroid,\n        bitVector: bitVector\n      });\n      links.push({\n        source: \"root\",\n        target: `cluster-${cluster}`\n      });\n    });\n\n    // Add bead nodes and links\n    beadCentroids.forEach(({\n      cluster,\n      bead,\n      centroid,\n      points,\n      bitVector\n    }) => {\n      nodes.push({\n        id: `bead-${cluster}-${bead}`,\n        ...centroid,\n        bitVector: bitVector\n      });\n      links.push({\n        source: `cluster-${cluster}`,\n        target: `bead-${cluster}-${bead}`\n      });\n\n      // Add individual points and links\n      points.forEach((point, index) => {\n        const pointId = `point-${cluster}-${bead}-${index}`;\n        nodes.push({\n          id: pointId,\n          ...point,\n          bitVector: assignBitVector(point)\n        });\n        links.push({\n          source: `bead-${cluster}-${bead}`,\n          target: pointId\n        });\n      });\n    });\n\n    // Store distances for color purposes and also the bit vector distances\n    beadCentroids.forEach(beadNode => {\n      beadNode.distances = beadCentroids.map(otherBead => {\n        return {\n          id: otherBead.id,\n          dist: calculateEuclideanDistance(beadNode.centroid, otherBead.centroid, coordinateKeys)\n        };\n      });\n      beadNode.bitDistances = beadCentroids.map(otherBead => {\n        return {\n          id: otherBead.id,\n          dist: calculateHammingDistance(beadNode.bitVector, otherBead.bitVector)\n        };\n      });\n    });\n\n    // Set up container dimensions\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n    const margin = {\n      top: 20,\n      right: 20,\n      bottom: 20,\n      left: 20\n    };\n    const svg = d3.select(graphRef.current).attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n\n    // Force simulation\n    const simulation = d3.forceSimulation(nodes).force(\"link\", d3.forceLink(links).id(d => d.id).distance(20)).force(\"charge\", d3.forceManyBody().strength(-100)).force(\"center\", d3.forceCenter(width / 2, height / 2)).force(\"collision\", d3.forceCollide().radius(d => d.id.startsWith(\"point\") ? 10 : 15) // Adjust radii for different node types\n    ).force(\"charge\", d3.forceManyBody().strength(-10)).force(\"center\", d3.forceCenter((width - margin.left - margin.right) / 2, (height - margin.top - margin.bottom) / 2)).on(\"tick\", () => {\n      link.attr(\"x1\", d => clamp(d.source.x, 0, width)).attr(\"y1\", d => clamp(d.source.y, 0, height)).attr(\"x2\", d => clamp(d.target.x, 0, width)).attr(\"y2\", d => clamp(d.target.y, 0, height));\n      node.attr(\"cx\", d => clamp(d.x, 0, width)).attr(\"cy\", d => clamp(d.y, 0, height));\n    });\n\n    // Clamp function to restrict within bounds\n    const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n    // Draw links\n    const link = svg.append(\"g\").attr(\"class\", \"links\").selectAll(\"line\").data(links).enter().append(\"line\").attr(\"stroke\", \"#aaa\").attr(\"stroke-width\", 2);\n\n    // Define a color scale for bead distances\n    const minDistance = d3.min(beadCentroids, d => d3.min(d.distances, dist => dist.dist));\n    const maxDistance = d3.max(beadCentroids, d => d3.max(d.distances, dist => dist.dist));\n    const colorScale = d3.scaleLinear().domain([minDistance, maxDistance]).range([\"lightblue\", \"darkblue\"]); //  Adjust colors as needed\n    // Draw nodes\n    const node = svg.append(\"g\").attr(\"class\", \"nodes\").selectAll(\"circle\").data(nodes).enter().append(\"circle\").attr(\"r\", 5).attr(\"fill\", d => {\n      if (d.id === \"root\") return \"red\";\n      if (d.id.startsWith(\"cluster\")) return \"blue\";\n      if (d.id.startsWith(\"bead\")) {\n        const centroid = beadCentroids.find(x => x.id === d.id);\n        if (centroid) {\n          let minDist = d3.min(centroid.distances.filter(x => x.id !== d.id), x => x.dist);\n          return colorScale(minDist);\n        }\n        return \"green\";\n      }\n      return \"gray\";\n    }).on(\"mouseover\", (event, d) => {\n      // Create an object to hold all coordinate values\n      const coordinates = {};\n\n      // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n      coordinateKeys.forEach(key => {\n        coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n      });\n      // Additional info to give:\n      let bitVector = d.bitVector;\n      let bitDistances = [];\n      if (d.id.startsWith(\"bead\")) {\n        const beadData = beadCentroids.find(x => x.id === d.id);\n        if (beadData) {\n          bitDistances = beadData.bitDistances;\n        }\n      }\n      // Pass the full coordinates to the parent component\n      setHoveredCoordinates({\n        ...coordinates,\n        id: d.id,\n        bitVector: bitVector,\n        bitDistances: bitDistances\n      });\n      // Highlight nodes that have close bit vectors\n\n      node.attr(\"stroke\", n => {\n        if (n.id === d.id) {\n          return \"black\";\n        }\n        if (d.id.startsWith(\"bead\") && n.id.startsWith(\"bead\")) {\n          const currentBeadData = beadCentroids.find(x => x.id === d.id);\n          const otherBeadData = beadCentroids.find(x => x.id === n.id);\n          if (currentBeadData && otherBeadData) {\n            const hammingDist = calculateHammingDistance(currentBeadData.bitVector, otherBeadData.bitVector);\n            if (hammingDist <= 3) {\n              return \"red\";\n            }\n          }\n        }\n        return null;\n      });\n    }).on(\"mouseout\", (event, d) => {\n      node.attr(\"stroke\", null);\n    }).call(d3.drag().on(\"start\", event => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    }).on(\"drag\", event => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    }).on(\"end\", event => {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    }));\n\n    // Add tooltips\n    node.append(\"title\").text(d => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n  }, [jsonData, setHoveredCoordinates]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: graphRef,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 540,\n    columnNumber: 10\n  }, this);\n};\n_s(HierarchicalGraph, \"XNG/roOlNWxTF7ymftfdirhS32A=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","setHoveredCoordinates","_s","graphRef","length","coordinateKeys","Object","keys","filter","key","calculateCentroid","points","n","sum","reduce","acc","point","forEach","assignBitVector","map","join","calculateHammingDistance","bitVector1","bitVector2","dist","i","calculateEuclideanDistance","point1","point2","Math","sqrt","clusters","group","d","Cluster","beads","Bead","rootCentroid","rootBitVector","clusterCentroids","Array","from","cluster","centroid","bitVector","beadCentroids","bead","split","links","nodes","id","push","source","target","index","pointId","beadNode","distances","otherBead","bitDistances","container","select","current","parentNode","width","node","getBoundingClientRect","height","margin","top","right","bottom","left","svg","attr","selectAll","remove","simulation","forceSimulation","force","forceLink","distance","forceManyBody","strength","forceCenter","forceCollide","radius","startsWith","on","link","clamp","x","y","value","min","max","append","data","enter","minDistance","maxDistance","colorScale","scaleLinear","domain","range","find","minDist","event","coordinates","beadData","currentBeadData","otherBeadData","hammingDist","call","drag","active","alphaTarget","restart","subject","fx","fy","text","ref","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point,\n//           bitVector: assignBitVector(point), });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(20)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-100))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n//       )\n\n//       .force(\"charge\", d3.forceManyBody().strength(-10))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n  const graphRef = useRef(null);\n\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(\n      (key) => key !== \"Cluster\" && key !== \"Bead\"\n    );\n\n    // Helper to calculate centroid\n    const calculateCentroid = (points) => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach((key) => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      // Compute average for each dimension\n      Object.keys(sum).forEach((key) => (sum[key] /= n));\n      return sum;\n    };\n    // Assign bit vectors based on coordinate keys (planes)\n    const assignBitVector = (point) => {\n      return coordinateKeys\n        .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n        .join(\"\");\n    };\n\n    // Function to calculate hamming distance of two bit vectors\n    const calculateHammingDistance = (bitVector1, bitVector2) => {\n      let dist = 0;\n      for (let i = 0; i < bitVector1.length; i++) {\n        if (bitVector1[i] !== bitVector2[i]) {\n          dist++;\n        }\n      }\n      return dist;\n    };\n    // Function to calculate a distance metric based on euclidean distance\n    const calculateEuclideanDistance = (point1, point2, coordinateKeys) => {\n      let dist = 0;\n      for (let i = 0; i < coordinateKeys.length; i++) {\n        let key = coordinateKeys[i];\n        dist += (point1[key] - point2[key]) ** 2;\n      }\n      return Math.sqrt(dist);\n    };\n    // Parse and process data\n    const clusters = d3.group(jsonData, (d) => d.Cluster);\n    const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n    // Root centroid\n    const rootCentroid = calculateCentroid(jsonData);\n    const rootBitVector = assignBitVector(rootCentroid);\n\n    // Cluster centroids\n    const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n      cluster,\n      centroid: calculateCentroid(points),\n      bitVector: assignBitVector(calculateCentroid(points)),\n    }));\n\n    // Bead centroids\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      return {\n        cluster,\n        bead,\n        centroid: calculateCentroid(points),\n        points,\n        bitVector: assignBitVector(calculateCentroid(points)),\n      };\n    });\n\n    // Build hierarchical links\n    const links = [];\n    const nodes = [\n      { id: \"root\", ...rootCentroid, bitVector: rootBitVector }, // Root node\n    ];\n\n    // Add cluster nodes and links\n    clusterCentroids.forEach(({ cluster, centroid, bitVector }) => {\n      nodes.push({\n        id: `cluster-${cluster}`,\n        ...centroid,\n        bitVector: bitVector,\n      });\n      links.push({ source: \"root\", target: `cluster-${cluster}` });\n    });\n\n    // Add bead nodes and links\n    beadCentroids.forEach(({ cluster, bead, centroid, points, bitVector }) => {\n      nodes.push({\n        id: `bead-${cluster}-${bead}`,\n        ...centroid,\n        bitVector: bitVector,\n      });\n      links.push({\n        source: `cluster-${cluster}`,\n        target: `bead-${cluster}-${bead}`,\n      });\n\n      // Add individual points and links\n      points.forEach((point, index) => {\n        const pointId = `point-${cluster}-${bead}-${index}`;\n        nodes.push({\n          id: pointId,\n          ...point,\n          bitVector: assignBitVector(point),\n        });\n        links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n      });\n    });\n\n    // Store distances for color purposes and also the bit vector distances\n    beadCentroids.forEach((beadNode) => {\n      beadNode.distances = beadCentroids.map((otherBead) => {\n        return {\n          id: otherBead.id,\n          dist: calculateEuclideanDistance(\n            beadNode.centroid,\n            otherBead.centroid,\n            coordinateKeys\n          ),\n        };\n      });\n      beadNode.bitDistances = beadCentroids.map((otherBead) => {\n        return {\n          id: otherBead.id,\n          dist: calculateHammingDistance(\n            beadNode.bitVector,\n            otherBead.bitVector\n          ),\n        };\n      });\n    });\n\n    // Set up container dimensions\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n    const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n    const svg = d3\n      .select(graphRef.current)\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", `0 0 ${width} ${height}`)\n      .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n\n    // Force simulation\n    const simulation = d3\n      .forceSimulation(nodes)\n      .force(\n        \"link\",\n        d3\n          .forceLink(links)\n          .id((d) => d.id)\n          .distance(20)\n      )\n      .force(\"charge\", d3.forceManyBody().strength(-100))\n      .force(\"center\", d3.forceCenter(width / 2, height / 2))\n      .force(\n        \"collision\",\n        d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n      )\n\n      .force(\"charge\", d3.forceManyBody().strength(-10))\n      .force(\n        \"center\",\n        d3.forceCenter(\n          (width - margin.left - margin.right) / 2,\n          (height - margin.top - margin.bottom) / 2\n        )\n      )\n      .on(\"tick\", () => {\n        link\n          .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n          .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n          .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n          .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n        node\n          .attr(\"cx\", (d) => clamp(d.x, 0, width))\n          .attr(\"cy\", (d) => clamp(d.y, 0, height));\n      });\n\n    // Clamp function to restrict within bounds\n    const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n    // Draw links\n    const link = svg\n      .append(\"g\")\n      .attr(\"class\", \"links\")\n      .selectAll(\"line\")\n      .data(links)\n      .enter()\n      .append(\"line\")\n      .attr(\"stroke\", \"#aaa\")\n      .attr(\"stroke-width\", 2);\n\n    // Define a color scale for bead distances\n    const minDistance = d3.min(beadCentroids, (d) =>\n      d3.min(d.distances, (dist) => dist.dist)\n    );\n    const maxDistance = d3.max(beadCentroids, (d) =>\n      d3.max(d.distances, (dist) => dist.dist)\n    );\n    const colorScale = d3\n      .scaleLinear()\n      .domain([minDistance, maxDistance])\n      .range([\"lightblue\", \"darkblue\"]); //  Adjust colors as needed\n    // Draw nodes\n    const node = svg\n      .append(\"g\")\n      .attr(\"class\", \"nodes\")\n      .selectAll(\"circle\")\n      .data(nodes)\n      .enter()\n      .append(\"circle\")\n      .attr(\"r\", 5)\n      .attr(\"fill\", (d) => {\n        if (d.id === \"root\") return \"red\";\n        if (d.id.startsWith(\"cluster\")) return \"blue\";\n        if (d.id.startsWith(\"bead\")) {\n          const centroid = beadCentroids.find((x) => x.id === d.id);\n          if (centroid) {\n            let minDist = d3.min(\n              centroid.distances.filter((x) => x.id !== d.id),\n              (x) => x.dist\n            );\n            return colorScale(minDist);\n          }\n          return \"green\";\n        }\n        return \"gray\";\n      })\n      .on(\"mouseover\", (event, d) => {\n        // Create an object to hold all coordinate values\n        const coordinates = {};\n\n        // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n        coordinateKeys.forEach((key) => {\n          coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n        });\n        // Additional info to give:\n        let bitVector = d.bitVector;\n        let bitDistances = [];\n        if (d.id.startsWith(\"bead\")) {\n          const beadData = beadCentroids.find((x) => x.id === d.id);\n          if (beadData) {\n            bitDistances = beadData.bitDistances;\n          }\n        }\n        // Pass the full coordinates to the parent component\n        setHoveredCoordinates({\n          ...coordinates,\n          id: d.id,\n          bitVector: bitVector,\n          bitDistances: bitDistances,\n        });\n        // Highlight nodes that have close bit vectors\n\n        node.attr(\"stroke\", (n) => {\n          if (n.id === d.id) {\n            return \"black\";\n          }\n\n          if (d.id.startsWith(\"bead\") && n.id.startsWith(\"bead\")) {\n            const currentBeadData = beadCentroids.find((x) => x.id === d.id);\n            const otherBeadData = beadCentroids.find((x) => x.id === n.id);\n\n            if (currentBeadData && otherBeadData) {\n              const hammingDist = calculateHammingDistance(\n                currentBeadData.bitVector,\n                otherBeadData.bitVector\n              );\n              if (hammingDist <= 3) {\n                return \"red\";\n              }\n            }\n          }\n          return null;\n        });\n      })\n      .on(\"mouseout\", (event, d) => {\n        node.attr(\"stroke\", null);\n      })\n\n      .call(\n        d3\n          .drag()\n          .on(\"start\", (event) => {\n            if (!event.active) simulation.alphaTarget(0.3).restart();\n            event.subject.fx = event.subject.x;\n            event.subject.fy = event.subject.y;\n          })\n          .on(\"drag\", (event) => {\n            event.subject.fx = event.x;\n            event.subject.fy = event.y;\n          })\n          .on(\"end\", (event) => {\n            if (!event.active) simulation.alphaTarget(0);\n            event.subject.fx = null;\n            event.subject.fy = null;\n          })\n      );\n\n    // Add tooltips\n    node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n  }, [jsonData, setHoveredCoordinates]);\n\n  return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n};\n\nexport default HierarchicalGraph;"],"mappings":";;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAO,KAAKC,EAAE,MAAM,IAAI;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEzB,MAAMC,iBAAiB,GAAGA,CAAC;EAAEC,QAAQ;EAAEC;AAAsB,CAAC,KAAK;EAAAC,EAAA;EACjE,MAAMC,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAAC;E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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}