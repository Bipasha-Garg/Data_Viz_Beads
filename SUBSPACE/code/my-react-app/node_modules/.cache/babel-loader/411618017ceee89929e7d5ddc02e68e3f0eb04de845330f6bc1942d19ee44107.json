{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useState } from \"react\";\n\n// const JsonDisplay = ({ jsonFilename }) => {\n//   const [jsonData, setJsonData] = useState(null);\n//   const [error, setError] = useState(null);\n\n//   useEffect(() => {\n//     if (!jsonFilename) {\n//       setError(\"No JSON filename provided\");\n//       return;\n//     }\n//     console.log(\"i am working\");\n//     fetch(`http://127.0.0.1:5000/public/${jsonFilename}`)\n//       .then((response) => {\n//         if (!response.ok) {\n//           throw new Error(`Failed to fetch ${jsonFilename}`);\n//         }\n//         return response.json();\n//       })\n//       .then((data) => {\n//         setJsonData(data);\n//         setError(null);\n//       })\n//       .catch((err) => {\n//         setError(err.message);\n//         console.error(\"Error fetching JSON:\", err);\n//       });\n//   }, [jsonFilename]);\n\n//   return (\n//     <div>\n//       {jsonData && <pre>{JSON.stringify(jsonData, null, 2)}</pre>}\n//       {error && <p>Error: {error}</p>}\n//     </div>\n//   );\n// };\n\n// export default JsonDisplay;\n\n// import React from \"react\";\n\n// const JsonDisplay = ({ jsonData }) => {\n//   if (!jsonData) return null;\n\n//   return (\n//     <div className=\"mt-6 bg-blue p-4 rounded shadow\">\n//       <pre className=\"whitespace-pre-wrap\">\n//         {JSON.stringify(jsonData, null, 2)}\n//       </pre>\n//     </div>\n//   );\n// };\n\n// export default JsonDisplay;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(30)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-30))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 1.5);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     node.append(\"title\").text((d) => d.id);\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(key => key !== \"Cluster\" && key !== \"Bead\");\n\n    // Helper to calculate centroid\n    const calculateCentroid = points => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach(key => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      // Compute average for each dimension\n      Object.keys(sum).forEach(key => sum[key] /= n);\n      return sum;\n    };\n\n    // Parse and process data\n    const clusters = d3.group(jsonData, d => d.Cluster);\n    const beads = d3.group(jsonData, d => `${d.Cluster}-${d.Bead}`);\n\n    // Root centroid\n    const rootCentroid = calculateCentroid(jsonData);\n\n    // Cluster centroids\n    const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n      cluster,\n      centroid: calculateCentroid(points)\n    }));\n\n    // Bead centroids\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      return {\n        cluster,\n        bead,\n        centroid: calculateCentroid(points),\n        points\n      };\n    });\n\n    // Build hierarchical links\n    const links = [];\n    const nodes = [{\n      id: \"root\",\n      ...rootCentroid\n    } // Root node\n    ];\n\n    // Add cluster nodes and links\n    clusterCentroids.forEach(({\n      cluster,\n      centroid\n    }) => {\n      nodes.push({\n        id: `cluster-${cluster}`,\n        ...centroid\n      });\n      links.push({\n        source: \"root\",\n        target: `cluster-${cluster}`\n      });\n    });\n\n    // Add bead nodes and links\n    beadCentroids.forEach(({\n      cluster,\n      bead,\n      centroid,\n      points\n    }) => {\n      nodes.push({\n        id: `bead-${cluster}-${bead}`,\n        ...centroid\n      });\n      links.push({\n        source: `cluster-${cluster}`,\n        target: `bead-${cluster}-${bead}`\n      });\n\n      // Add individual points and links\n      points.forEach((point, index) => {\n        const pointId = `point-${cluster}-${bead}-${index}`;\n        nodes.push({\n          id: pointId,\n          ...point\n        });\n        links.push({\n          source: `bead-${cluster}-${bead}`,\n          target: pointId\n        });\n      });\n    });\n\n    // Render graph with D3\n    const width = 1800;\n    const height = 1600;\n    const svg = d3.select(graphRef.current).attr(\"width\", width).attr(\"height\", height).style(\"border\", \"1px solid black\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n\n    // Force simulation\n    const simulation = d3.forceSimulation(nodes).force(\"link\", d3.forceLink(links).id(d => d.id).distance(50) // Adjusted for better spacing\n    ).force(\"charge\", d3.forceManyBody().strength(-100)).force(\"center\", d3.forceCenter(width / 2, height / 2)).force(\"collision\", d3.forceCollide().radius(d => d.id.startsWith(\"point\") ? 10 : 15) // Adjust radii for different node types\n    );\n\n    // Draw links\n    const link = svg.append(\"g\").attr(\"class\", \"links\").selectAll(\"line\").data(links).enter().append(\"line\").attr(\"stroke\", \"#aaa\").attr(\"stroke-width\", 1.5);\n\n    // Draw nodes\n    const node = svg.append(\"g\").attr(\"class\", \"nodes\").selectAll(\"circle\").data(nodes).enter().append(\"circle\").attr(\"r\", d => d.id.startsWith(\"point\") ? 5 : d.id.startsWith(\"bead\") ? 7 : 10) // Dynamic radius\n    .attr(\"fill\", d => {\n      if (d.id === \"root\") return \"red\";\n      if (d.id.startsWith(\"cluster\")) return \"blue\";\n      if (d.id.startsWith(\"bead\")) return \"green\";\n      return \"gray\";\n    }).call(d3.drag().on(\"start\", event => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    }).on(\"drag\", event => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    }).on(\"end\", event => {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    }));\n\n    // Add tooltips\n    node.append(\"title\").text(d => d.id);\n\n    // Update simulation\n    simulation.on(\"tick\", () => {\n      link.attr(\"x1\", d => d.source.x).attr(\"y1\", d => d.source.y).attr(\"x2\", d => d.target.x).attr(\"y2\", d => d.target.y);\n      node.attr(\"cx\", d => d.x).attr(\"cy\", d => d.y);\n    });\n  }, [jsonData]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: graphRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 413,\n    columnNumber: 10\n  }, this);\n};\n_s(HierarchicalGraph, \"XNG/roOlNWxTF7ymftfdirhS32A=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","_s","graphRef","length","coordinateKeys","Object","keys","filter","key","calculateCentroid","points","n","sum","reduce","acc","point","forEach","clusters","group","d","Cluster","beads","Bead","rootCentroid","clusterCentroids","Array","from","cluster","centroid","beadCentroids","bead","split","links","nodes","id","push","source","target","index","pointId","width","height","svg","select","current","attr","style","selectAll","remove","simulation","forceSimulation","force","forceLink","distance","forceManyBody","strength","forceCenter","forceCollide","radius","startsWith","link","append","data","enter","node","call","drag","on","event","active","alphaTarget","restart","subject","fx","x","fy","y","text","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// import React, { useEffect, useState } from \"react\";\n\n// const JsonDisplay = ({ jsonFilename }) => {\n//   const [jsonData, setJsonData] = useState(null);\n//   const [error, setError] = useState(null);\n\n//   useEffect(() => {\n//     if (!jsonFilename) {\n//       setError(\"No JSON filename provided\");\n//       return;\n//     }\n//     console.log(\"i am working\");\n//     fetch(`http://127.0.0.1:5000/public/${jsonFilename}`)\n//       .then((response) => {\n//         if (!response.ok) {\n//           throw new Error(`Failed to fetch ${jsonFilename}`);\n//         }\n//         return response.json();\n//       })\n//       .then((data) => {\n//         setJsonData(data);\n//         setError(null);\n//       })\n//       .catch((err) => {\n//         setError(err.message);\n//         console.error(\"Error fetching JSON:\", err);\n//       });\n//   }, [jsonFilename]);\n\n//   return (\n//     <div>\n//       {jsonData && <pre>{JSON.stringify(jsonData, null, 2)}</pre>}\n//       {error && <p>Error: {error}</p>}\n//     </div>\n//   );\n// };\n\n// export default JsonDisplay;\n\n\n// import React from \"react\";\n\n// const JsonDisplay = ({ jsonData }) => {\n//   if (!jsonData) return null;\n\n//   return (\n//     <div className=\"mt-6 bg-blue p-4 rounded shadow\">\n//       <pre className=\"whitespace-pre-wrap\">\n//         {JSON.stringify(jsonData, null, 2)}\n//       </pre>\n//     </div>\n//   );\n// };\n\n// export default JsonDisplay;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(30)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-30))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 1.5);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     node.append(\"title\").text((d) => d.id);\n//   }, [jsonData]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData }) => {\n  const graphRef = useRef(null);\n\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    // Dynamically extract coordinate keys (dimensions)\n    const coordinateKeys = Object.keys(jsonData[0]).filter(\n      (key) => key !== \"Cluster\" && key !== \"Bead\"\n    );\n\n    // Helper to calculate centroid\n    const calculateCentroid = (points) => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach((key) => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      // Compute average for each dimension\n      Object.keys(sum).forEach((key) => (sum[key] /= n));\n      return sum;\n    };\n\n    // Parse and process data\n    const clusters = d3.group(jsonData, (d) => d.Cluster);\n    const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n    // Root centroid\n    const rootCentroid = calculateCentroid(jsonData);\n\n    // Cluster centroids\n    const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n      cluster,\n      centroid: calculateCentroid(points),\n    }));\n\n    // Bead centroids\n    const beadCentroids = Array.from(beads, ([key, points]) => {\n      const [cluster, bead] = key.split(\"-\");\n      return {\n        cluster,\n        bead,\n        centroid: calculateCentroid(points),\n        points,\n      };\n    });\n\n    // Build hierarchical links\n    const links = [];\n    const nodes = [\n      { id: \"root\", ...rootCentroid }, // Root node\n    ];\n\n    // Add cluster nodes and links\n    clusterCentroids.forEach(({ cluster, centroid }) => {\n      nodes.push({ id: `cluster-${cluster}`, ...centroid });\n      links.push({ source: \"root\", target: `cluster-${cluster}` });\n    });\n\n    // Add bead nodes and links\n    beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n      nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid });\n      links.push({\n        source: `cluster-${cluster}`,\n        target: `bead-${cluster}-${bead}`,\n      });\n\n      // Add individual points and links\n      points.forEach((point, index) => {\n        const pointId = `point-${cluster}-${bead}-${index}`;\n        nodes.push({ id: pointId, ...point });\n        links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n      });\n    });\n\n    // Render graph with D3\n    const width = 1800;\n    const height = 1600;\n    const svg = d3\n      .select(graphRef.current)\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .style(\"border\", \"1px solid black\");\n\n    // Clear previous render\n    svg.selectAll(\"*\").remove();\n\n    // Force simulation\n    const simulation = d3\n      .forceSimulation(nodes)\n      .force(\n        \"link\",\n        d3\n          .forceLink(links)\n          .id((d) => d.id)\n          .distance(50) // Adjusted for better spacing\n      )\n      .force(\"charge\", d3.forceManyBody().strength(-100))\n      .force(\"center\", d3.forceCenter(width / 2, height / 2))\n      .force(\n        \"collision\",\n        d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n      );\n\n    // Draw links\n    const link = svg\n      .append(\"g\")\n      .attr(\"class\", \"links\")\n      .selectAll(\"line\")\n      .data(links)\n      .enter()\n      .append(\"line\")\n      .attr(\"stroke\", \"#aaa\")\n      .attr(\"stroke-width\", 1.5);\n\n    // Draw nodes\n    const node = svg\n      .append(\"g\")\n      .attr(\"class\", \"nodes\")\n      .selectAll(\"circle\")\n      .data(nodes)\n      .enter()\n      .append(\"circle\")\n      .attr(\"r\", (d) =>\n        d.id.startsWith(\"point\") ? 5 : d.id.startsWith(\"bead\") ? 7 : 10\n      ) // Dynamic radius\n      .attr(\"fill\", (d) => {\n        if (d.id === \"root\") return \"red\";\n        if (d.id.startsWith(\"cluster\")) return \"blue\";\n        if (d.id.startsWith(\"bead\")) return \"green\";\n        return \"gray\";\n      })\n      .call(\n        d3\n          .drag()\n          .on(\"start\", (event) => {\n            if (!event.active) simulation.alphaTarget(0.3).restart();\n            event.subject.fx = event.subject.x;\n            event.subject.fy = event.subject.y;\n          })\n          .on(\"drag\", (event) => {\n            event.subject.fx = event.x;\n            event.subject.fy = event.y;\n          })\n          .on(\"end\", (event) => {\n            if (!event.active) simulation.alphaTarget(0);\n            event.subject.fx = null;\n            event.subject.fy = null;\n          })\n      );\n\n    // Add tooltips\n    node.append(\"title\").text((d) => d.id);\n\n    // Update simulation\n    simulation.on(\"tick\", () => {\n      link\n        .attr(\"x1\", (d) => d.source.x)\n        .attr(\"y1\", (d) => d.source.y)\n        .attr(\"x2\", (d) => d.target.x)\n        .attr(\"y2\", (d) => d.target.y);\n\n      node.attr(\"cx\", (d) => d.x).attr(\"cy\", (d) => d.y);\n    });\n  }, [jsonData]);\n\n  return <svg ref={graphRef}></svg>;\n};\n\nexport default HierarchicalGraph;\n"],"mappings":";;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAGA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAO,KAAKC,EAAE,MAAM,IAAI;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEzB,MAAMC,iBAAiB,GAAGA,CAAC;EAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}