{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point,\n//           bitVector: assignBitVector(point), });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(20)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-100))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n//       )\n\n//       .force(\"charge\", d3.forceManyBody().strength(-10))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  setHoveredCoordinates\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n    const coordinateKeys = Object.keys(jsonData[0]).filter(key => key !== \"Cluster\" && key !== \"Bead\");\n\n    // Helper to calculate centroid\n    const calculateCentroid = points => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach(key => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      Object.keys(sum).forEach(key => sum[key] /= n);\n      return sum;\n    };\n\n    // Assign bit vector based on coordinate keys\n    const assignBitVector = point => {\n      return coordinateKeys.map(key => point[key] >= 0 ? \"1\" : \"0\").join(\"\");\n    };\n\n    // Recursive Quadtree Positioning\n    const assignQuadtreePosition = (bitVector, bounds, depth = 0) => {\n      const {\n        xMin,\n        xMax,\n        yMin,\n        yMax\n      } = bounds;\n      if (depth >= bitVector.length) {\n        return {\n          x: (xMin + xMax) / 2,\n          y: (yMin + yMax) / 2\n        };\n      }\n      const bit = bitVector[depth];\n      const midX = (xMin + xMax) / 2;\n      const midY = (yMin + yMax) / 2;\n\n      // Divide plane based on the current bit\n      if (depth % 2 === 0) {\n        // Vertical division (even depths)\n        if (bit === \"0\") {\n          return assignQuadtreePosition(bitVector, {\n            xMin,\n            xMax: midX,\n            yMin,\n            yMax\n          }, depth + 1);\n        } else {\n          return assignQuadtreePosition(bitVector, {\n            xMin: midX,\n            xMax,\n            yMin,\n            yMax\n          }, depth + 1);\n        }\n      } else {\n        // Horizontal division (odd depths)\n        if (bit === \"0\") {\n          return assignQuadtreePosition(bitVector, {\n            xMin,\n            xMax,\n            yMin,\n            yMax: midY\n          }, depth + 1);\n        } else {\n          return assignQuadtreePosition(bitVector, {\n            xMin,\n            xMax,\n            yMin: midY,\n            yMax\n          }, depth + 1);\n        }\n      }\n    };\n\n    // Parse data and calculate positions\n    const clusters = d3.group(jsonData, d => d.Cluster);\n    const beads = d3.group(jsonData, d => `${d.Cluster}-${d.Bead}`);\n    const rootCentroid = calculateCentroid(jsonData);\n    const nodes = [];\n    const links = [];\n\n    // Root node\n    nodes.push({\n      id: \"root\",\n      ...rootCentroid,\n      bitVector: assignBitVector(rootCentroid),\n      position: {\n        x: 0,\n        y: 0\n      }\n    });\n\n    // Cluster and Bead Nodes\n    const bounds = {\n      xMin: 0,\n      xMax: 500,\n      yMin: 0,\n      yMax: 500\n    }; // Canvas bounds\n    clusters.forEach((clusterPoints, cluster) => {\n      const clusterCentroid = calculateCentroid(clusterPoints);\n      const clusterBitVector = assignBitVector(clusterCentroid);\n      const clusterPosition = assignQuadtreePosition(clusterBitVector, bounds);\n      nodes.push({\n        id: `cluster-${cluster}`,\n        ...clusterCentroid,\n        bitVector: clusterBitVector,\n        position: clusterPosition\n      });\n      links.push({\n        source: \"root\",\n        target: `cluster-${cluster}`\n      });\n      beads.forEach((beadPoints, beadKey) => {\n        if (!beadKey.startsWith(cluster)) return;\n        const beadCentroid = calculateCentroid(beadPoints);\n        const beadBitVector = assignBitVector(beadCentroid);\n        const beadPosition = assignQuadtreePosition(beadBitVector, bounds);\n        nodes.push({\n          id: `bead-${beadKey}`,\n          ...beadCentroid,\n          bitVector: beadBitVector,\n          position: beadPosition\n        });\n        links.push({\n          source: `cluster-${cluster}`,\n          target: `bead-${beadKey}`\n        });\n        beadPoints.forEach((point, index) => {\n          const pointId = `point-${beadKey}-${index}`;\n          const pointBitVector = assignBitVector(point);\n          const pointPosition = assignQuadtreePosition(pointBitVector, bounds);\n          nodes.push({\n            id: pointId,\n            ...point,\n            bitVector: pointBitVector,\n            position: pointPosition\n          });\n          links.push({\n            source: `bead-${beadKey}`,\n            target: pointId\n          });\n        });\n      });\n    });\n\n    // Set up SVG\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n    const svg = d3.select(graphRef.current).attr(\"width\", width).attr(\"height\", height);\n    svg.selectAll(\"*\").remove();\n\n    // Draw links\n    svg.append(\"g\").attr(\"class\", \"links\").selectAll(\"line\").data(links).enter().append(\"line\").attr(\"x1\", d => nodes.find(n => n.id === d.source).position.x).attr(\"y1\", d => nodes.find(n => n.id === d.source).position.y).attr(\"x2\", d => nodes.find(n => n.id === d.target).position.x).attr(\"y2\", d => nodes.find(n => n.id === d.target).position.y).attr(\"stroke\", \"#aaa\");\n\n    // Draw nodes\n    svg.append(\"g\").attr(\"class\", \"nodes\").selectAll(\"circle\").data(nodes).enter().append(\"circle\").attr(\"cx\", d => d.position.x).attr(\"cy\", d => d.position.y).attr(\"r\", 5).attr(\"fill\", d => d.id.startsWith(\"root\") ? \"red\" : d.id.startsWith(\"cluster\") ? \"blue\" : \"green\").on(\"mouseover\", (event, d) => setHoveredCoordinates(d));\n  }, [jsonData, setHoveredCoordinates]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: graphRef,\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 411,\n    columnNumber: 10\n  }, this);\n};\n_s(HierarchicalGraph, \"XNG/roOlNWxTF7ymftfdirhS32A=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","setHoveredCoordinates","_s","graphRef","length","coordinateKeys","Object","keys","filter","key","calculateCentroid","points","n","sum","reduce","acc","point","forEach","assignBitVector","map","join","assignQuadtreePosition","bitVector","bounds","depth","xMin","xMax","yMin","yMax","x","y","bit","midX","midY","clusters","group","d","Cluster","beads","Bead","rootCentroid","nodes","links","push","id","position","clusterPoints","cluster","clusterCentroid","clusterBitVector","clusterPosition","source","target","beadPoints","beadKey","startsWith","beadCentroid","beadBitVector","beadPosition","index","pointId","pointBitVector","pointPosition","container","select","current","parentNode","width","node","getBoundingClientRect","height","svg","attr","selectAll","remove","append","data","enter","find","on","event","ref","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n//         bitVector: assignBitVector(centroid), });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({ id: pointId, ...point,\n//           bitVector: assignBitVector(point), });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(20)\n//       )\n//       .force(\"charge\", d3.forceManyBody().strength(-100))\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n//       )\n\n//       .force(\"charge\", d3.forceManyBody().strength(-10))\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n//           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n//           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n//           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n//           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n//       });\n\n//     // Clamp function to restrict within bounds\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", 5)\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n\n//       .on(\"mouseover\", (event, d) => {\n//         // Create an object to hold all coordinate values\n//         const coordinates = {};\n\n//         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n//         });\n\n//         // Pass the full coordinates to the parent component\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     // node.append(\"title\").text((d) => d.id);\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;\n\n\n\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n  const graphRef = useRef(null);\n\n  useEffect(() => {\n    if (!jsonData || jsonData.length === 0) return;\n\n    const coordinateKeys = Object.keys(jsonData[0]).filter(\n      (key) => key !== \"Cluster\" && key !== \"Bead\"\n    );\n\n    // Helper to calculate centroid\n    const calculateCentroid = (points) => {\n      const n = points.length;\n      const sum = points.reduce((acc, point) => {\n        coordinateKeys.forEach((key) => {\n          acc[key] = (acc[key] || 0) + point[key];\n        });\n        return acc;\n      }, {});\n      Object.keys(sum).forEach((key) => (sum[key] /= n));\n      return sum;\n    };\n\n    // Assign bit vector based on coordinate keys\n    const assignBitVector = (point) => {\n      return coordinateKeys\n        .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n        .join(\"\");\n    };\n\n    // Recursive Quadtree Positioning\n    const assignQuadtreePosition = (bitVector, bounds, depth = 0) => {\n      const { xMin, xMax, yMin, yMax } = bounds;\n      if (depth >= bitVector.length) {\n        return {\n          x: (xMin + xMax) / 2,\n          y: (yMin + yMax) / 2,\n        };\n      }\n\n      const bit = bitVector[depth];\n      const midX = (xMin + xMax) / 2;\n      const midY = (yMin + yMax) / 2;\n\n      // Divide plane based on the current bit\n      if (depth % 2 === 0) {\n        // Vertical division (even depths)\n        if (bit === \"0\") {\n          return assignQuadtreePosition(\n            bitVector,\n            { xMin, xMax: midX, yMin, yMax },\n            depth + 1\n          );\n        } else {\n          return assignQuadtreePosition(\n            bitVector,\n            { xMin: midX, xMax, yMin, yMax },\n            depth + 1\n          );\n        }\n      } else {\n        // Horizontal division (odd depths)\n        if (bit === \"0\") {\n          return assignQuadtreePosition(\n            bitVector,\n            { xMin, xMax, yMin, yMax: midY },\n            depth + 1\n          );\n        } else {\n          return assignQuadtreePosition(\n            bitVector,\n            { xMin, xMax, yMin: midY, yMax },\n            depth + 1\n          );\n        }\n      }\n    };\n\n    // Parse data and calculate positions\n    const clusters = d3.group(jsonData, (d) => d.Cluster);\n    const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n    const rootCentroid = calculateCentroid(jsonData);\n    const nodes = [];\n    const links = [];\n\n    // Root node\n    nodes.push({\n      id: \"root\",\n      ...rootCentroid,\n      bitVector: assignBitVector(rootCentroid),\n      position: { x: 0, y: 0 },\n    });\n\n    // Cluster and Bead Nodes\n    const bounds = { xMin: 0, xMax: 500, yMin: 0, yMax: 500 }; // Canvas bounds\n    clusters.forEach((clusterPoints, cluster) => {\n      const clusterCentroid = calculateCentroid(clusterPoints);\n      const clusterBitVector = assignBitVector(clusterCentroid);\n      const clusterPosition = assignQuadtreePosition(clusterBitVector, bounds);\n\n      nodes.push({\n        id: `cluster-${cluster}`,\n        ...clusterCentroid,\n        bitVector: clusterBitVector,\n        position: clusterPosition,\n      });\n      links.push({ source: \"root\", target: `cluster-${cluster}` });\n\n      beads.forEach((beadPoints, beadKey) => {\n        if (!beadKey.startsWith(cluster)) return;\n\n        const beadCentroid = calculateCentroid(beadPoints);\n        const beadBitVector = assignBitVector(beadCentroid);\n        const beadPosition = assignQuadtreePosition(beadBitVector, bounds);\n\n        nodes.push({\n          id: `bead-${beadKey}`,\n          ...beadCentroid,\n          bitVector: beadBitVector,\n          position: beadPosition,\n        });\n        links.push({ source: `cluster-${cluster}`, target: `bead-${beadKey}` });\n\n        beadPoints.forEach((point, index) => {\n          const pointId = `point-${beadKey}-${index}`;\n          const pointBitVector = assignBitVector(point);\n          const pointPosition = assignQuadtreePosition(pointBitVector, bounds);\n\n          nodes.push({\n            id: pointId,\n            ...point,\n            bitVector: pointBitVector,\n            position: pointPosition,\n          });\n          links.push({ source: `bead-${beadKey}`, target: pointId });\n        });\n      });\n    });\n\n    // Set up SVG\n    const container = d3.select(graphRef.current.parentNode);\n    const width = container.node().getBoundingClientRect().width;\n    const height = container.node().getBoundingClientRect().height;\n\n    const svg = d3\n      .select(graphRef.current)\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    svg.selectAll(\"*\").remove();\n\n    // Draw links\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"links\")\n      .selectAll(\"line\")\n      .data(links)\n      .enter()\n      .append(\"line\")\n      .attr(\"x1\", (d) => nodes.find((n) => n.id === d.source).position.x)\n      .attr(\"y1\", (d) => nodes.find((n) => n.id === d.source).position.y)\n      .attr(\"x2\", (d) => nodes.find((n) => n.id === d.target).position.x)\n      .attr(\"y2\", (d) => nodes.find((n) => n.id === d.target).position.y)\n      .attr(\"stroke\", \"#aaa\");\n\n    // Draw nodes\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"nodes\")\n      .selectAll(\"circle\")\n      .data(nodes)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => d.position.x)\n      .attr(\"cy\", (d) => d.position.y)\n      .attr(\"r\", 5)\n      .attr(\"fill\", (d) =>\n        d.id.startsWith(\"root\")\n          ? \"red\"\n          : d.id.startsWith(\"cluster\")\n          ? \"blue\"\n          : \"green\"\n      )\n      .on(\"mouseover\", (event, d) => setHoveredCoordinates(d));\n  }, [jsonData, setHoveredCoordinates]);\n\n  return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n};\n\nexport default HierarchicalGraph;\n"],"mappings":";;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAIA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAO,KAAKC,EAAE,MAAM,IAAI;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEzB,MAAMC,iBAAiB,GAAGA,CAAC;EAAEC,QAAQ;EAAEC;AAAsB,CAAC,KAAK;EAAAC,EAAA;EACjE,MAAMC,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAAC;E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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}