{"ast":null,"code":"\n// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || jsonData.length === 0) return;\n\n// // // //     // Dynamically extract coordinate keys (dimensions)\n// // // //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// // // //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// // // //     );\n\n// // // //     // Helper to calculate centroid\n// // // //     const calculateCentroid = (points) => {\n// // // //       const n = points.length;\n// // // //       const sum = points.reduce((acc, point) => {\n// // // //         coordinateKeys.forEach((key) => {\n// // // //           acc[key] = (acc[key] || 0) + point[key];\n// // // //         });\n// // // //         return acc;\n// // // //       }, {});\n// // // //       // Compute average for each dimension\n// // // //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// // // //       return sum;\n// // // //     };\n// // // //     // Assign bit vectors based on coordinate keys (planes)\n// // // //     const assignBitVector = (point) => {\n// // // //       return coordinateKeys\n// // // //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// // // //         .join(\"\");\n// // // //     };\n// // // //     // Parse and process data\n// // // //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// // // //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// // // //     // Root centroid\n// // // //     const rootCentroid = calculateCentroid(jsonData);\n\n// // // //     // Cluster centroids\n// // // //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// // // //       cluster,\n// // // //       centroid: calculateCentroid(points),\n// // // //     }));\n\n// // // //     // Bead centroids\n// // // //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// // // //       const [cluster, bead] = key.split(\"-\");\n// // // //       return {\n// // // //         cluster,\n// // // //         bead,\n// // // //         centroid: calculateCentroid(points),\n// // // //         points,\n// // // //       };\n// // // //     });\n\n// // // //     // Build hierarchical links\n// // // //     const links = [];\n// // // //     const nodes = [\n// // // //       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n// // // //     ];\n\n// // // //     // Add cluster nodes and links\n// // // //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// // // //       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n// // // //         bitVector: assignBitVector(centroid), });\n// // // //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// // // //     });\n\n// // // //     // Add bead nodes and links\n// // // //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// // // //       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n// // // //         bitVector: assignBitVector(centroid), });\n// // // //       links.push({\n// // // //         source: `cluster-${cluster}`,\n// // // //         target: `bead-${cluster}-${bead}`,\n// // // //       });\n\n// // // //       // Add individual points and links\n// // // //       points.forEach((point, index) => {\n// // // //         const pointId = `point-${cluster}-${bead}-${index}`;\n// // // //         nodes.push({ id: pointId, ...point,\n// // // //           bitVector: assignBitVector(point), });\n// // // //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// // // //       });\n// // // //     });\n\n// // // //     // Set up container dimensions\n// // // //     const container = d3.select(graphRef.current.parentNode);\n// // // //     const width = container.node().getBoundingClientRect().width;\n// // // //     const height = container.node().getBoundingClientRect().height;\n// // // //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// // // //     const svg = d3\n// // // //       .select(graphRef.current)\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// // // //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// // // //     // Clear previous render\n// // // //     svg.selectAll(\"*\").remove();\n\n// // // //     // Force simulation\n// // // //     const simulation = d3\n// // // //       .forceSimulation(nodes)\n// // // //       .force(\n// // // //         \"link\",\n// // // //         d3\n// // // //           .forceLink(links)\n// // // //           .id((d) => d.id)\n// // // //           .distance(-10)\n// // // //       )\n// // // //       .force(\"charge\", d3.forceManyBody().strength(1))\n// // // //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// // // //       .force(\n// // // //         \"collision\",\n// // // //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// // // //       )\n\n// // // //       .force(\"charge\", d3.forceManyBody().strength( 3))\n// // // //       .force(\n// // // //         \"center\",\n// // // //         d3.forceCenter(\n// // // //           (width - margin.left - margin.right) / 2,\n// // // //           (height - margin.top - margin.bottom) / 2\n// // // //         )\n// // // //       )\n// // // //       .on(\"tick\", () => {\n// // // //         link\n// // // //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// // // //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// // // //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// // // //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// // // //         node\n// // // //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// // // //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// // // //       });\n\n// // // //     // Clamp function to restrict within bounds\n// // // //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// // // //     // Draw links\n// // // //     const link = svg\n// // // //       .append(\"g\")\n// // // //       .attr(\"class\", \"links\")\n// // // //       .selectAll(\"line\")\n// // // //       .data(links)\n// // // //       .enter()\n// // // //       .append(\"line\")\n// // // //       .attr(\"stroke\", \"#aaa\")\n// // // //       .attr(\"stroke-width\", 2);\n\n// // // //     // Draw nodes\n// // // //     const node = svg\n// // // //       .append(\"g\")\n// // // //       .attr(\"class\", \"nodes\")\n// // // //       .selectAll(\"circle\")\n// // // //       .data(nodes)\n// // // //       .enter()\n// // // //       .append(\"circle\")\n// // // //       .attr(\"r\", 5)\n// // // //       .attr(\"fill\", (d) => {\n// // // //         if (d.id === \"root\") return \"red\";\n// // // //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// // // //         if (d.id.startsWith(\"bead\")) return \"green\";\n// // // //         return \"gray\";\n// // // //       })\n\n// // // //       .on(\"mouseover\", (event, d) => {\n// // // //         // Create an object to hold all coordinate values\n// // // //         const coordinates = {};\n\n// // // //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// // // //         coordinateKeys.forEach((key) => {\n// // // //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// // // //         });\n\n// // // //         // Pass the full coordinates to the parent component\n// // // //         setHoveredCoordinates({\n// // // //           ...coordinates,\n// // // //           id: d.id,\n// // // //           bitVector: d.bitVector,\n// // // //         });\n// // // //       })\n\n// // // //       .call(\n// // // //         d3\n// // // //           .drag()\n// // // //           .on(\"start\", (event) => {\n// // // //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// // // //             event.subject.fx = event.subject.x;\n// // // //             event.subject.fy = event.subject.y;\n// // // //           })\n// // // //           .on(\"drag\", (event) => {\n// // // //             event.subject.fx = event.x;\n// // // //             event.subject.fy = event.y;\n// // // //           })\n// // // //           .on(\"end\", (event) => {\n// // // //             if (!event.active) simulation.alphaTarget(0);\n// // // //             event.subject.fx = null;\n// // // //             event.subject.fy = null;\n// // // //           })\n// // // //       );\n\n// // // //     // Add tooltips\n// // // //     // node.append(\"title\").text((d) => d.id);\n// // // //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// // // //   }, [jsonData, setHoveredCoordinates]);\n\n// // // //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // // _____________________________________placement acc x and y bit vectors_________________________________\n\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || jsonData.length === 0) return;\n\n// // //     // Dynamically extract coordinate keys (dimensions)\n// // //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// // //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// // //     );\n\n// // //     // Helper to calculate centroid\n// // //     const calculateCentroid = (points) => {\n// // //       const n = points.length;\n// // //       const sum = points.reduce((acc, point) => {\n// // //         coordinateKeys.forEach((key) => {\n// // //           acc[key] = (acc[key] || 0) + point[key];\n// // //         });\n// // //         return acc;\n// // //       }, {});\n// // //       // Compute average for each dimension\n// // //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// // //       return sum;\n// // //     };\n// // //     // Assign bit vectors based on coordinate keys (planes)\n// // //     const assignBitVector = (point) => {\n// // //       return coordinateKeys\n// // //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// // //         .join(\"\");\n// // //     };\n// // //     // Parse and process data\n// // //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// // //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// // //     // Root centroid\n// // //     const rootCentroid = calculateCentroid(jsonData);\n\n// // //     // Cluster centroids\n// // //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// // //       cluster,\n// // //       centroid: calculateCentroid(points),\n// // //     }));\n\n// // //     // Bead centroids\n// // //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// // //       const [cluster, bead] = key.split(\"-\");\n// // //       return {\n// // //         cluster,\n// // //         bead,\n// // //         centroid: calculateCentroid(points),\n// // //         points,\n// // //       };\n// // //     });\n\n// // //     // Build hierarchical links\n// // //     const links = [];\n// // //     const nodes = [\n// // //       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n// // //     ];\n\n// // //     // Add cluster nodes and links\n// // //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// // //       nodes.push({\n// // //         id: `cluster-${cluster}`,\n// // //         ...centroid,\n// // //         bitVector: assignBitVector(centroid),\n// // //       });\n// // //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// // //     });\n\n// // //     // Add bead nodes and links\n// // //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// // //       nodes.push({\n// // //         id: `bead-${cluster}-${bead}`,\n// // //         ...centroid,\n// // //         bitVector: assignBitVector(centroid),\n// // //       });\n// // //       links.push({\n// // //         source: `cluster-${cluster}`,\n// // //         target: `bead-${cluster}-${bead}`,\n// // //       });\n\n// // //       // Add individual points and links\n// // //       points.forEach((point, index) => {\n// // //         const pointId = `point-${cluster}-${bead}-${index}`;\n// // //         nodes.push({\n// // //           id: pointId,\n// // //           ...point,\n// // //           bitVector: assignBitVector(point),\n// // //         });\n// // //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// // //       });\n// // //     });\n\n// // //     // Set up container dimensions\n// // //     const container = d3.select(graphRef.current.parentNode);\n// // //     const width = container.node().getBoundingClientRect().width;\n// // //     const height = container.node().getBoundingClientRect().height;\n// // //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// // //     const svg = d3\n// // //       .select(graphRef.current)\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// // //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// // //     // Clear previous render\n// // //     svg.selectAll(\"*\").remove();\n\n// // //     // Calculate initial positions based on bit vectors\n// // //     nodes.forEach((node) => {\n// // //       if (node.bitVector) {\n// // //         // Avoid undefined case\n// // //         let x = 0;\n// // //         let y = 0;\n\n// // //         for (let i = 0; i < coordinateKeys.length; i++) {\n// // //           const key = coordinateKeys[i];\n// // //           const bit = node.bitVector[i];\n// // //           const dimensionMultiplier = 100; // You can increase or decrease this to change spread between clusters\n\n// // //           // Use the dimensionMultiplier and add more multiplier if more than one dimension\n// // //           x +=\n// // //             (bit === \"1\"\n// // //               ? dimensionMultiplier * 1.5\n// // //               : -dimensionMultiplier * 1.5) *\n// // //             (i + 1);\n// // //           y +=\n// // //             (bit === \"1\"\n// // //               ? dimensionMultiplier * 1.5\n// // //               : -dimensionMultiplier * 1.5) *\n// // //             (i + 1);\n// // //         }\n\n// // //         node.x = x + width / 2;\n// // //         node.y = y + height / 2;\n// // //       }\n// // //     });\n\n// // //     // Force simulation\n// // //     const simulation = d3\n// // //       .forceSimulation(nodes)\n// // //       .force(\n// // //         \"link\",\n// // //         d3\n// // //           .forceLink(links)\n// // //           .id((d) => d.id)\n// // //           .distance(-10)\n// // //       )\n// // //       .force(\"charge\", d3.forceManyBody().strength(1))\n// // //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// // //       .force(\n// // //         \"collision\",\n// // //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// // //       )\n\n// // //       .force(\"charge\", d3.forceManyBody().strength(3))\n// // //       .force(\n// // //         \"center\",\n// // //         d3.forceCenter(\n// // //           (width - margin.left - margin.right) / 2,\n// // //           (height - margin.top - margin.bottom) / 2\n// // //         )\n// // //       )\n// // //       .on(\"tick\", () => {\n// // //         link\n// // //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// // //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// // //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// // //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// // //         node\n// // //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// // //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// // //       });\n\n// // //     // Clamp function to restrict within bounds\n// // //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// // //     // Draw links\n// // //     const link = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"links\")\n// // //       .selectAll(\"line\")\n// // //       .data(links)\n// // //       .enter()\n// // //       .append(\"line\")\n// // //       .attr(\"stroke\", \"#aaa\")\n// // //       .attr(\"stroke-width\", 2);\n\n// // //     // Draw nodes\n// // //     const node = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"nodes\")\n// // //       .selectAll(\"circle\")\n// // //       .data(nodes)\n// // //       .enter()\n// // //       .append(\"circle\")\n// // //       .attr(\"r\", 5)\n// // //       .attr(\"fill\", (d) => {\n// // //         if (d.id === \"root\") return \"red\";\n// // //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// // //         if (d.id.startsWith(\"bead\")) return \"green\";\n// // //         return \"gray\";\n// // //       })\n\n// // //       .on(\"mouseover\", (event, d) => {\n// // //         // Create an object to hold all coordinate values\n// // //         const coordinates = {};\n\n// // //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// // //         coordinateKeys.forEach((key) => {\n// // //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// // //         });\n\n// // //         // Pass the full coordinates to the parent component\n// // //         setHoveredCoordinates({\n// // //           ...coordinates,\n// // //           id: d.id,\n// // //           bitVector: d.bitVector,\n// // //         });\n// // //       })\n\n// // //       .call(\n// // //         d3\n// // //           .drag()\n// // //           .on(\"start\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// // //             event.subject.fx = event.subject.x;\n// // //             event.subject.fy = event.subject.y;\n// // //           })\n// // //           .on(\"drag\", (event) => {\n// // //             event.subject.fx = event.x;\n// // //             event.subject.fy = event.y;\n// // //           })\n// // //           .on(\"end\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0);\n// // //             event.subject.fx = null;\n// // //             event.subject.fy = null;\n// // //           })\n// // //       );\n\n// // //     // Add tooltips\n// // //     // node.append(\"title\").text((d) => d.id);\n// // //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// // //   }, [jsonData, setHoveredCoordinates]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n\n// // // _______________________________________________________QUANDRANT POSITIONING WITH SIMULATION_________________\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || jsonData.length === 0) return;\n\n// //     // Dynamically extract coordinate keys (dimensions)\n// //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// //     );\n\n// //     // Helper to calculate centroid\n// //     const calculateCentroid = (points) => {\n// //       const n = points.length;\n// //       const sum = points.reduce((acc, point) => {\n// //         coordinateKeys.forEach((key) => {\n// //           acc[key] = (acc[key] || 0) + point[key];\n// //         });\n// //         return acc;\n// //       }, {});\n// //       // Compute average for each dimension\n// //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// //       return sum;\n// //     };\n// //     // Assign bit vectors based on coordinate keys (planes)\n// //     const assignBitVector = (point) => {\n// //       return coordinateKeys\n// //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// //         .join(\"\");\n// //     };\n// //     // Parse and process data\n// //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// //     // Root centroid\n// //     const rootCentroid = calculateCentroid(jsonData);\n\n// //     // Cluster centroids\n// //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// //       cluster,\n// //       centroid: calculateCentroid(points),\n// //     }));\n\n// //     // Bead centroids\n// //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// //       const [cluster, bead] = key.split(\"-\");\n// //       return {\n// //         cluster,\n// //         bead,\n// //         centroid: calculateCentroid(points),\n// //         points,\n// //       };\n// //     });\n\n// //     // Build hierarchical links\n// //     const links = [];\n// //     const nodes = [\n// //       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n// //     ];\n\n// //     // Add cluster nodes and links\n// //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// //       nodes.push({\n// //         id: `cluster-${cluster}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// //     });\n\n// //     // Add bead nodes and links\n// //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// //       nodes.push({\n// //         id: `bead-${cluster}-${bead}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({\n// //         source: `cluster-${cluster}`,\n// //         target: `bead-${cluster}-${bead}`,\n// //       });\n\n// //       // Add individual points and links\n// //       points.forEach((point, index) => {\n// //         const pointId = `point-${cluster}-${bead}-${index}`;\n// //         nodes.push({\n// //           id: pointId,\n// //           ...point,\n// //           bitVector: assignBitVector(point),\n// //         });\n// //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// //       });\n// //     });\n\n// //     // Set up container dimensions\n// //     const container = d3.select(graphRef.current.parentNode);\n// //     const width = container.node().getBoundingClientRect().width;\n// //     const height = container.node().getBoundingClientRect().height;\n// //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// //     const svg = d3\n// //       .select(graphRef.current)\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// //     // Clear previous render\n// //     svg.selectAll(\"*\").remove();\n\n// //     // Calculate the number of quadrants based on the number of dimensions\n// //     const numDimensions = coordinateKeys.length;\n// //     const numQuadrants = 2 ** numDimensions;\n\n// //     // Calculate initial positions based on bit vectors\n// //     nodes.forEach((node) => {\n// //       if (node.bitVector) {\n// //         // Convert the bit vector to a decimal number\n// //         const quadrantIndex = parseInt(node.bitVector, 2);\n\n// //         // Calculate quadrant size and starting position\n// //         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n// //         const numCols = Math.ceil(numQuadrants / numRows);\n// //         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n// //         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n// //         const row = Math.floor(quadrantIndex / numCols);\n// //         const col = quadrantIndex % numCols;\n\n// //         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n// //         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n// //         node.x = x;\n// //         node.y = y;\n// //       }\n// //     });\n\n// //     // Force simulation\n// //     const simulation = d3\n// //       .forceSimulation(nodes)\n// //       .force(\n// //         \"link\",\n// //         d3\n// //           .forceLink(links)\n// //           .id((d) => d.id)\n// //           .distance(-10)\n// //       )\n// //       .force(\"charge\", d3.forceManyBody().strength(1))\n// //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// //       .force(\n// //         \"collision\",\n// //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15))\n// //       )\n// //       .force(\"charge\", d3.forceManyBody().strength(3))\n// //       .force(\n// //         \"center\",\n// //         d3.forceCenter(\n// //           (width - margin.left - margin.right) / 2,\n// //           (height - margin.top - margin.bottom) / 2\n// //         )\n// //       )\n// //       .on(\"tick\", () => {\n// //         link\n// //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// //         node\n// //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// //       });\n\n// //     // Clamp function to restrict within bounds\n// //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// //     // Draw links\n// //     const link = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"links\")\n// //       .selectAll(\"line\")\n// //       .data(links)\n// //       .enter()\n// //       .append(\"line\")\n// //       .attr(\"stroke\", \"#aaa\")\n// //       .attr(\"stroke-width\", 2);\n\n// //     // Draw nodes\n// //     const node = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"nodes\")\n// //       .selectAll(\"circle\")\n// //       .data(nodes)\n// //       .enter()\n// //       .append(\"circle\")\n// //       .attr(\"r\", 5)\n// //       .attr(\"fill\", (d) => {\n// //         if (d.id === \"root\") return \"red\";\n// //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// //         if (d.id.startsWith(\"bead\")) return \"green\";\n// //         return \"gray\";\n// //       })\n// //       .on(\"mouseover\", (event, d) => {\n// //         // Create an object to hold all coordinate values\n// //         const coordinates = {};\n\n// //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// //         coordinateKeys.forEach((key) => {\n// //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// //         });\n\n// //         // Pass the full coordinates to the parent component\n// //         setHoveredCoordinates({\n// //           ...coordinates,\n// //           id: d.id,\n// //           bitVector: d.bitVector,\n// //         });\n// //       })\n// //       .call(\n// //         d3\n// //           .drag()\n// //           .on(\"start\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// //             event.subject.fx = event.subject.x;\n// //             event.subject.fy = event.subject.y;\n// //           })\n// //           .on(\"drag\", (event) => {\n// //             event.subject.fx = event.x;\n// //             event.subject.fy = event.y;\n// //           })\n// //           .on(\"end\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0);\n// //             event.subject.fx = null;\n// //             event.subject.fy = null;\n// //           })\n// //       );\n\n// //     // Add tooltips\n// //     // node.append(\"title\").text((d) => d.id);\n// //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// //   }, [jsonData, setHoveredCoordinates]);\n\n// //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       {\n//         id: \"root\",\n//         ...rootCentroid,\n//         bitVector: assignBitVector(rootCentroid),\n//         isCentroid: true,\n//       }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({\n//         id: `cluster-${cluster}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({\n//         id: `bead-${cluster}-${bead}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({\n//           id: pointId,\n//           ...point,\n//           bitVector: assignBitVector(point),\n//           isCentroid: false,\n//         });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate the number of quadrants based on the number of dimensions\n//     const numDimensions = coordinateKeys.length;\n//     const numQuadrants = 2 ** numDimensions;\n\n//     // Calculate initial positions based on bit vectors\n//     nodes.forEach((node) => {\n//       if (node.bitVector) {\n//         // Convert the bit vector to a decimal number\n//         const quadrantIndex = parseInt(node.bitVector, 2);\n\n//         // Calculate quadrant size and starting position\n//         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//         const numCols = Math.ceil(numQuadrants / numRows);\n//         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//         const row = Math.floor(quadrantIndex / numCols);\n//         const col = quadrantIndex % numCols;\n\n//         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n//         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n//         node.x = x;\n//         node.y = y;\n//       }\n//     });\n\n//     // Draw grid lines\n//     const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//     const numCols = Math.ceil(numQuadrants / numRows);\n//     const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//     const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//     const grid = svg.append(\"g\").attr(\"class\", \"grid\");\n\n//     // Draw vertical lines\n//     for (let i = 0; i <= numCols; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left + i * quadrantWidth)\n//         .attr(\"y1\", margin.top)\n//         .attr(\"x2\", margin.left + i * quadrantWidth)\n//         .attr(\"y2\", height - margin.bottom)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Draw horizontal lines\n//     for (let i = 0; i <= numRows; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left)\n//         .attr(\"y1\", margin.top + i * quadrantHeight)\n//         .attr(\"x2\", width - margin.right)\n//         .attr(\"y2\", margin.top + i * quadrantHeight)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(-10)\n//       )\n//       .force(\n//         \"charge\",\n//         d3.forceManyBody().strength((d) => (d.isCentroid ? -20 : 1))\n//       )\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.isCentroid ? 10 : 5))\n//       )\n\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) =>\n//             clamp(d.source.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y1\", (d) =>\n//             clamp(d.source.y, margin.top, height - margin.bottom)\n//           )\n//           .attr(\"x2\", (d) =>\n//             clamp(d.target.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y2\", (d) =>\n//             clamp(d.target.y, margin.top, height - margin.bottom)\n//           );\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, margin.left, width - margin.right))\n//           .attr(\"cy\", (d) => clamp(d.y, margin.top, height - margin.bottom));\n//       });\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", (d) => (d.isCentroid ? 10 : 5))\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .on(\"mouseover\", (event, d) => {\n//         const coordinates = {};\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key];\n//         });\n\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;","map":{"version":3,"names":[],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/GRAPH/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["\n// // // // import React, { useEffect, useRef } from \"react\";\n// // // // import * as d3 from \"d3\";\n\n// // // // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// // // //   const graphRef = useRef(null);\n\n// // // //   useEffect(() => {\n// // // //     if (!jsonData || jsonData.length === 0) return;\n\n// // // //     // Dynamically extract coordinate keys (dimensions)\n// // // //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// // // //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// // // //     );\n\n// // // //     // Helper to calculate centroid\n// // // //     const calculateCentroid = (points) => {\n// // // //       const n = points.length;\n// // // //       const sum = points.reduce((acc, point) => {\n// // // //         coordinateKeys.forEach((key) => {\n// // // //           acc[key] = (acc[key] || 0) + point[key];\n// // // //         });\n// // // //         return acc;\n// // // //       }, {});\n// // // //       // Compute average for each dimension\n// // // //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// // // //       return sum;\n// // // //     };\n// // // //     // Assign bit vectors based on coordinate keys (planes)\n// // // //     const assignBitVector = (point) => {\n// // // //       return coordinateKeys\n// // // //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// // // //         .join(\"\");\n// // // //     };\n// // // //     // Parse and process data\n// // // //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// // // //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// // // //     // Root centroid\n// // // //     const rootCentroid = calculateCentroid(jsonData);\n\n// // // //     // Cluster centroids\n// // // //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// // // //       cluster,\n// // // //       centroid: calculateCentroid(points),\n// // // //     }));\n\n// // // //     // Bead centroids\n// // // //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// // // //       const [cluster, bead] = key.split(\"-\");\n// // // //       return {\n// // // //         cluster,\n// // // //         bead,\n// // // //         centroid: calculateCentroid(points),\n// // // //         points,\n// // // //       };\n// // // //     });\n\n// // // //     // Build hierarchical links\n// // // //     const links = [];\n// // // //     const nodes = [\n// // // //       { id: \"root\", ...rootCentroid , bitVector: assignBitVector(rootCentroid)}, // Root node\n// // // //     ];\n\n// // // //     // Add cluster nodes and links\n// // // //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// // // //       nodes.push({ id: `cluster-${cluster}`, ...centroid,\n// // // //         bitVector: assignBitVector(centroid), });\n// // // //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// // // //     });\n\n// // // //     // Add bead nodes and links\n// // // //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// // // //       nodes.push({ id: `bead-${cluster}-${bead}`, ...centroid,\n// // // //         bitVector: assignBitVector(centroid), });\n// // // //       links.push({\n// // // //         source: `cluster-${cluster}`,\n// // // //         target: `bead-${cluster}-${bead}`,\n// // // //       });\n\n// // // //       // Add individual points and links\n// // // //       points.forEach((point, index) => {\n// // // //         const pointId = `point-${cluster}-${bead}-${index}`;\n// // // //         nodes.push({ id: pointId, ...point,\n// // // //           bitVector: assignBitVector(point), });\n// // // //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// // // //       });\n// // // //     });\n\n// // // //     // Set up container dimensions\n// // // //     const container = d3.select(graphRef.current.parentNode);\n// // // //     const width = container.node().getBoundingClientRect().width;\n// // // //     const height = container.node().getBoundingClientRect().height;\n// // // //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// // // //     const svg = d3\n// // // //       .select(graphRef.current)\n// // // //       .attr(\"width\", width)\n// // // //       .attr(\"height\", height)\n// // // //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// // // //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// // // //     // Clear previous render\n// // // //     svg.selectAll(\"*\").remove();\n\n// // // //     // Force simulation\n// // // //     const simulation = d3\n// // // //       .forceSimulation(nodes)\n// // // //       .force(\n// // // //         \"link\",\n// // // //         d3\n// // // //           .forceLink(links)\n// // // //           .id((d) => d.id)\n// // // //           .distance(-10)\n// // // //       )\n// // // //       .force(\"charge\", d3.forceManyBody().strength(1))\n// // // //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// // // //       .force(\n// // // //         \"collision\",\n// // // //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// // // //       )\n\n// // // //       .force(\"charge\", d3.forceManyBody().strength( 3))\n// // // //       .force(\n// // // //         \"center\",\n// // // //         d3.forceCenter(\n// // // //           (width - margin.left - margin.right) / 2,\n// // // //           (height - margin.top - margin.bottom) / 2\n// // // //         )\n// // // //       )\n// // // //       .on(\"tick\", () => {\n// // // //         link\n// // // //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// // // //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// // // //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// // // //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// // // //         node\n// // // //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// // // //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// // // //       });\n\n// // // //     // Clamp function to restrict within bounds\n// // // //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// // // //     // Draw links\n// // // //     const link = svg\n// // // //       .append(\"g\")\n// // // //       .attr(\"class\", \"links\")\n// // // //       .selectAll(\"line\")\n// // // //       .data(links)\n// // // //       .enter()\n// // // //       .append(\"line\")\n// // // //       .attr(\"stroke\", \"#aaa\")\n// // // //       .attr(\"stroke-width\", 2);\n\n// // // //     // Draw nodes\n// // // //     const node = svg\n// // // //       .append(\"g\")\n// // // //       .attr(\"class\", \"nodes\")\n// // // //       .selectAll(\"circle\")\n// // // //       .data(nodes)\n// // // //       .enter()\n// // // //       .append(\"circle\")\n// // // //       .attr(\"r\", 5)\n// // // //       .attr(\"fill\", (d) => {\n// // // //         if (d.id === \"root\") return \"red\";\n// // // //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// // // //         if (d.id.startsWith(\"bead\")) return \"green\";\n// // // //         return \"gray\";\n// // // //       })\n\n// // // //       .on(\"mouseover\", (event, d) => {\n// // // //         // Create an object to hold all coordinate values\n// // // //         const coordinates = {};\n\n// // // //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// // // //         coordinateKeys.forEach((key) => {\n// // // //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// // // //         });\n\n// // // //         // Pass the full coordinates to the parent component\n// // // //         setHoveredCoordinates({\n// // // //           ...coordinates,\n// // // //           id: d.id,\n// // // //           bitVector: d.bitVector,\n// // // //         });\n// // // //       })\n\n// // // //       .call(\n// // // //         d3\n// // // //           .drag()\n// // // //           .on(\"start\", (event) => {\n// // // //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// // // //             event.subject.fx = event.subject.x;\n// // // //             event.subject.fy = event.subject.y;\n// // // //           })\n// // // //           .on(\"drag\", (event) => {\n// // // //             event.subject.fx = event.x;\n// // // //             event.subject.fy = event.y;\n// // // //           })\n// // // //           .on(\"end\", (event) => {\n// // // //             if (!event.active) simulation.alphaTarget(0);\n// // // //             event.subject.fx = null;\n// // // //             event.subject.fy = null;\n// // // //           })\n// // // //       );\n\n// // // //     // Add tooltips\n// // // //     // node.append(\"title\").text((d) => d.id);\n// // // //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// // // //   }, [jsonData, setHoveredCoordinates]);\n\n// // // //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // // // };\n\n// // // // export default HierarchicalGraph;\n\n// // // // _____________________________________placement acc x and y bit vectors_________________________________\n\n// // // import React, { useEffect, useRef } from \"react\";\n// // // import * as d3 from \"d3\";\n\n// // // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// // //   const graphRef = useRef(null);\n\n// // //   useEffect(() => {\n// // //     if (!jsonData || jsonData.length === 0) return;\n\n// // //     // Dynamically extract coordinate keys (dimensions)\n// // //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// // //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// // //     );\n\n// // //     // Helper to calculate centroid\n// // //     const calculateCentroid = (points) => {\n// // //       const n = points.length;\n// // //       const sum = points.reduce((acc, point) => {\n// // //         coordinateKeys.forEach((key) => {\n// // //           acc[key] = (acc[key] || 0) + point[key];\n// // //         });\n// // //         return acc;\n// // //       }, {});\n// // //       // Compute average for each dimension\n// // //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// // //       return sum;\n// // //     };\n// // //     // Assign bit vectors based on coordinate keys (planes)\n// // //     const assignBitVector = (point) => {\n// // //       return coordinateKeys\n// // //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// // //         .join(\"\");\n// // //     };\n// // //     // Parse and process data\n// // //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// // //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// // //     // Root centroid\n// // //     const rootCentroid = calculateCentroid(jsonData);\n\n// // //     // Cluster centroids\n// // //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// // //       cluster,\n// // //       centroid: calculateCentroid(points),\n// // //     }));\n\n// // //     // Bead centroids\n// // //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// // //       const [cluster, bead] = key.split(\"-\");\n// // //       return {\n// // //         cluster,\n// // //         bead,\n// // //         centroid: calculateCentroid(points),\n// // //         points,\n// // //       };\n// // //     });\n\n// // //     // Build hierarchical links\n// // //     const links = [];\n// // //     const nodes = [\n// // //       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n// // //     ];\n\n// // //     // Add cluster nodes and links\n// // //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// // //       nodes.push({\n// // //         id: `cluster-${cluster}`,\n// // //         ...centroid,\n// // //         bitVector: assignBitVector(centroid),\n// // //       });\n// // //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// // //     });\n\n// // //     // Add bead nodes and links\n// // //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// // //       nodes.push({\n// // //         id: `bead-${cluster}-${bead}`,\n// // //         ...centroid,\n// // //         bitVector: assignBitVector(centroid),\n// // //       });\n// // //       links.push({\n// // //         source: `cluster-${cluster}`,\n// // //         target: `bead-${cluster}-${bead}`,\n// // //       });\n\n// // //       // Add individual points and links\n// // //       points.forEach((point, index) => {\n// // //         const pointId = `point-${cluster}-${bead}-${index}`;\n// // //         nodes.push({\n// // //           id: pointId,\n// // //           ...point,\n// // //           bitVector: assignBitVector(point),\n// // //         });\n// // //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// // //       });\n// // //     });\n\n// // //     // Set up container dimensions\n// // //     const container = d3.select(graphRef.current.parentNode);\n// // //     const width = container.node().getBoundingClientRect().width;\n// // //     const height = container.node().getBoundingClientRect().height;\n// // //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// // //     const svg = d3\n// // //       .select(graphRef.current)\n// // //       .attr(\"width\", width)\n// // //       .attr(\"height\", height)\n// // //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// // //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// // //     // Clear previous render\n// // //     svg.selectAll(\"*\").remove();\n\n// // //     // Calculate initial positions based on bit vectors\n// // //     nodes.forEach((node) => {\n// // //       if (node.bitVector) {\n// // //         // Avoid undefined case\n// // //         let x = 0;\n// // //         let y = 0;\n\n// // //         for (let i = 0; i < coordinateKeys.length; i++) {\n// // //           const key = coordinateKeys[i];\n// // //           const bit = node.bitVector[i];\n// // //           const dimensionMultiplier = 100; // You can increase or decrease this to change spread between clusters\n\n// // //           // Use the dimensionMultiplier and add more multiplier if more than one dimension\n// // //           x +=\n// // //             (bit === \"1\"\n// // //               ? dimensionMultiplier * 1.5\n// // //               : -dimensionMultiplier * 1.5) *\n// // //             (i + 1);\n// // //           y +=\n// // //             (bit === \"1\"\n// // //               ? dimensionMultiplier * 1.5\n// // //               : -dimensionMultiplier * 1.5) *\n// // //             (i + 1);\n// // //         }\n\n// // //         node.x = x + width / 2;\n// // //         node.y = y + height / 2;\n// // //       }\n// // //     });\n\n// // //     // Force simulation\n// // //     const simulation = d3\n// // //       .forceSimulation(nodes)\n// // //       .force(\n// // //         \"link\",\n// // //         d3\n// // //           .forceLink(links)\n// // //           .id((d) => d.id)\n// // //           .distance(-10)\n// // //       )\n// // //       .force(\"charge\", d3.forceManyBody().strength(1))\n// // //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// // //       .force(\n// // //         \"collision\",\n// // //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15)) // Adjust radii for different node types\n// // //       )\n\n// // //       .force(\"charge\", d3.forceManyBody().strength(3))\n// // //       .force(\n// // //         \"center\",\n// // //         d3.forceCenter(\n// // //           (width - margin.left - margin.right) / 2,\n// // //           (height - margin.top - margin.bottom) / 2\n// // //         )\n// // //       )\n// // //       .on(\"tick\", () => {\n// // //         link\n// // //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// // //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// // //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// // //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// // //         node\n// // //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// // //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// // //       });\n\n// // //     // Clamp function to restrict within bounds\n// // //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// // //     // Draw links\n// // //     const link = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"links\")\n// // //       .selectAll(\"line\")\n// // //       .data(links)\n// // //       .enter()\n// // //       .append(\"line\")\n// // //       .attr(\"stroke\", \"#aaa\")\n// // //       .attr(\"stroke-width\", 2);\n\n// // //     // Draw nodes\n// // //     const node = svg\n// // //       .append(\"g\")\n// // //       .attr(\"class\", \"nodes\")\n// // //       .selectAll(\"circle\")\n// // //       .data(nodes)\n// // //       .enter()\n// // //       .append(\"circle\")\n// // //       .attr(\"r\", 5)\n// // //       .attr(\"fill\", (d) => {\n// // //         if (d.id === \"root\") return \"red\";\n// // //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// // //         if (d.id.startsWith(\"bead\")) return \"green\";\n// // //         return \"gray\";\n// // //       })\n\n// // //       .on(\"mouseover\", (event, d) => {\n// // //         // Create an object to hold all coordinate values\n// // //         const coordinates = {};\n\n// // //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// // //         coordinateKeys.forEach((key) => {\n// // //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// // //         });\n\n// // //         // Pass the full coordinates to the parent component\n// // //         setHoveredCoordinates({\n// // //           ...coordinates,\n// // //           id: d.id,\n// // //           bitVector: d.bitVector,\n// // //         });\n// // //       })\n\n// // //       .call(\n// // //         d3\n// // //           .drag()\n// // //           .on(\"start\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// // //             event.subject.fx = event.subject.x;\n// // //             event.subject.fy = event.subject.y;\n// // //           })\n// // //           .on(\"drag\", (event) => {\n// // //             event.subject.fx = event.x;\n// // //             event.subject.fy = event.y;\n// // //           })\n// // //           .on(\"end\", (event) => {\n// // //             if (!event.active) simulation.alphaTarget(0);\n// // //             event.subject.fx = null;\n// // //             event.subject.fy = null;\n// // //           })\n// // //       );\n\n// // //     // Add tooltips\n// // //     // node.append(\"title\").text((d) => d.id);\n// // //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// // //   }, [jsonData, setHoveredCoordinates]);\n\n// // //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // // };\n\n// // // export default HierarchicalGraph;\n\n// // // _______________________________________________________QUANDRANT POSITIONING WITH SIMULATION_________________\n// // import React, { useEffect, useRef } from \"react\";\n// // import * as d3 from \"d3\";\n\n// // const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n// //   const graphRef = useRef(null);\n\n// //   useEffect(() => {\n// //     if (!jsonData || jsonData.length === 0) return;\n\n// //     // Dynamically extract coordinate keys (dimensions)\n// //     const coordinateKeys = Object.keys(jsonData[0]).filter(\n// //       (key) => key !== \"Cluster\" && key !== \"Bead\"\n// //     );\n\n// //     // Helper to calculate centroid\n// //     const calculateCentroid = (points) => {\n// //       const n = points.length;\n// //       const sum = points.reduce((acc, point) => {\n// //         coordinateKeys.forEach((key) => {\n// //           acc[key] = (acc[key] || 0) + point[key];\n// //         });\n// //         return acc;\n// //       }, {});\n// //       // Compute average for each dimension\n// //       Object.keys(sum).forEach((key) => (sum[key] /= n));\n// //       return sum;\n// //     };\n// //     // Assign bit vectors based on coordinate keys (planes)\n// //     const assignBitVector = (point) => {\n// //       return coordinateKeys\n// //         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n// //         .join(\"\");\n// //     };\n// //     // Parse and process data\n// //     const clusters = d3.group(jsonData, (d) => d.Cluster);\n// //     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n// //     // Root centroid\n// //     const rootCentroid = calculateCentroid(jsonData);\n\n// //     // Cluster centroids\n// //     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n// //       cluster,\n// //       centroid: calculateCentroid(points),\n// //     }));\n\n// //     // Bead centroids\n// //     const beadCentroids = Array.from(beads, ([key, points]) => {\n// //       const [cluster, bead] = key.split(\"-\");\n// //       return {\n// //         cluster,\n// //         bead,\n// //         centroid: calculateCentroid(points),\n// //         points,\n// //       };\n// //     });\n\n// //     // Build hierarchical links\n// //     const links = [];\n// //     const nodes = [\n// //       { id: \"root\", ...rootCentroid, bitVector: assignBitVector(rootCentroid) }, // Root node\n// //     ];\n\n// //     // Add cluster nodes and links\n// //     clusterCentroids.forEach(({ cluster, centroid }) => {\n// //       nodes.push({\n// //         id: `cluster-${cluster}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({ source: \"root\", target: `cluster-${cluster}` });\n// //     });\n\n// //     // Add bead nodes and links\n// //     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n// //       nodes.push({\n// //         id: `bead-${cluster}-${bead}`,\n// //         ...centroid,\n// //         bitVector: assignBitVector(centroid),\n// //       });\n// //       links.push({\n// //         source: `cluster-${cluster}`,\n// //         target: `bead-${cluster}-${bead}`,\n// //       });\n\n// //       // Add individual points and links\n// //       points.forEach((point, index) => {\n// //         const pointId = `point-${cluster}-${bead}-${index}`;\n// //         nodes.push({\n// //           id: pointId,\n// //           ...point,\n// //           bitVector: assignBitVector(point),\n// //         });\n// //         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n// //       });\n// //     });\n\n// //     // Set up container dimensions\n// //     const container = d3.select(graphRef.current.parentNode);\n// //     const width = container.node().getBoundingClientRect().width;\n// //     const height = container.node().getBoundingClientRect().height;\n// //     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n// //     const svg = d3\n// //       .select(graphRef.current)\n// //       .attr(\"width\", width)\n// //       .attr(\"height\", height)\n// //       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n// //       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n// //     // Clear previous render\n// //     svg.selectAll(\"*\").remove();\n\n// //     // Calculate the number of quadrants based on the number of dimensions\n// //     const numDimensions = coordinateKeys.length;\n// //     const numQuadrants = 2 ** numDimensions;\n\n// //     // Calculate initial positions based on bit vectors\n// //     nodes.forEach((node) => {\n// //       if (node.bitVector) {\n// //         // Convert the bit vector to a decimal number\n// //         const quadrantIndex = parseInt(node.bitVector, 2);\n\n// //         // Calculate quadrant size and starting position\n// //         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n// //         const numCols = Math.ceil(numQuadrants / numRows);\n// //         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n// //         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n// //         const row = Math.floor(quadrantIndex / numCols);\n// //         const col = quadrantIndex % numCols;\n\n// //         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n// //         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n// //         node.x = x;\n// //         node.y = y;\n// //       }\n// //     });\n\n// //     // Force simulation\n// //     const simulation = d3\n// //       .forceSimulation(nodes)\n// //       .force(\n// //         \"link\",\n// //         d3\n// //           .forceLink(links)\n// //           .id((d) => d.id)\n// //           .distance(-10)\n// //       )\n// //       .force(\"charge\", d3.forceManyBody().strength(1))\n// //       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n// //       .force(\n// //         \"collision\",\n// //         d3.forceCollide().radius((d) => (d.id.startsWith(\"point\") ? 10 : 15))\n// //       )\n// //       .force(\"charge\", d3.forceManyBody().strength(3))\n// //       .force(\n// //         \"center\",\n// //         d3.forceCenter(\n// //           (width - margin.left - margin.right) / 2,\n// //           (height - margin.top - margin.bottom) / 2\n// //         )\n// //       )\n// //       .on(\"tick\", () => {\n// //         link\n// //           .attr(\"x1\", (d) => clamp(d.source.x, 0, width))\n// //           .attr(\"y1\", (d) => clamp(d.source.y, 0, height))\n// //           .attr(\"x2\", (d) => clamp(d.target.x, 0, width))\n// //           .attr(\"y2\", (d) => clamp(d.target.y, 0, height));\n\n// //         node\n// //           .attr(\"cx\", (d) => clamp(d.x, 0, width))\n// //           .attr(\"cy\", (d) => clamp(d.y, 0, height));\n// //       });\n\n// //     // Clamp function to restrict within bounds\n// //     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n// //     // Draw links\n// //     const link = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"links\")\n// //       .selectAll(\"line\")\n// //       .data(links)\n// //       .enter()\n// //       .append(\"line\")\n// //       .attr(\"stroke\", \"#aaa\")\n// //       .attr(\"stroke-width\", 2);\n\n// //     // Draw nodes\n// //     const node = svg\n// //       .append(\"g\")\n// //       .attr(\"class\", \"nodes\")\n// //       .selectAll(\"circle\")\n// //       .data(nodes)\n// //       .enter()\n// //       .append(\"circle\")\n// //       .attr(\"r\", 5)\n// //       .attr(\"fill\", (d) => {\n// //         if (d.id === \"root\") return \"red\";\n// //         if (d.id.startsWith(\"cluster\")) return \"blue\";\n// //         if (d.id.startsWith(\"bead\")) return \"green\";\n// //         return \"gray\";\n// //       })\n// //       .on(\"mouseover\", (event, d) => {\n// //         // Create an object to hold all coordinate values\n// //         const coordinates = {};\n\n// //         // Add all coordinate dimensions to the object (excluding non-coordinate dimensions like cluster and bead)\n// //         coordinateKeys.forEach((key) => {\n// //           coordinates[key] = d[key]; // Assuming each node has the corresponding dimension in d\n// //         });\n\n// //         // Pass the full coordinates to the parent component\n// //         setHoveredCoordinates({\n// //           ...coordinates,\n// //           id: d.id,\n// //           bitVector: d.bitVector,\n// //         });\n// //       })\n// //       .call(\n// //         d3\n// //           .drag()\n// //           .on(\"start\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0.3).restart();\n// //             event.subject.fx = event.subject.x;\n// //             event.subject.fy = event.subject.y;\n// //           })\n// //           .on(\"drag\", (event) => {\n// //             event.subject.fx = event.x;\n// //             event.subject.fy = event.y;\n// //           })\n// //           .on(\"end\", (event) => {\n// //             if (!event.active) simulation.alphaTarget(0);\n// //             event.subject.fx = null;\n// //             event.subject.fy = null;\n// //           })\n// //       );\n\n// //     // Add tooltips\n// //     // node.append(\"title\").text((d) => d.id);\n// //     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n// //   }, [jsonData, setHoveredCoordinates]);\n\n// //   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// // };\n\n// // export default HierarchicalGraph;\n\n\n// import React, { useEffect, useRef } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, setHoveredCoordinates }) => {\n//   const graphRef = useRef(null);\n\n//   useEffect(() => {\n//     if (!jsonData || jsonData.length === 0) return;\n\n//     // Dynamically extract coordinate keys (dimensions)\n//     const coordinateKeys = Object.keys(jsonData[0]).filter(\n//       (key) => key !== \"Cluster\" && key !== \"Bead\"\n//     );\n\n//     // Helper to calculate centroid\n//     const calculateCentroid = (points) => {\n//       const n = points.length;\n//       const sum = points.reduce((acc, point) => {\n//         coordinateKeys.forEach((key) => {\n//           acc[key] = (acc[key] || 0) + point[key];\n//         });\n//         return acc;\n//       }, {});\n//       // Compute average for each dimension\n//       Object.keys(sum).forEach((key) => (sum[key] /= n));\n//       return sum;\n//     };\n//     // Assign bit vectors based on coordinate keys (planes)\n//     const assignBitVector = (point) => {\n//       return coordinateKeys\n//         .map((key) => (point[key] >= 0 ? \"1\" : \"0\"))\n//         .join(\"\");\n//     };\n//     // Parse and process data\n//     const clusters = d3.group(jsonData, (d) => d.Cluster);\n//     const beads = d3.group(jsonData, (d) => `${d.Cluster}-${d.Bead}`);\n\n//     // Root centroid\n//     const rootCentroid = calculateCentroid(jsonData);\n\n//     // Cluster centroids\n//     const clusterCentroids = Array.from(clusters, ([cluster, points]) => ({\n//       cluster,\n//       centroid: calculateCentroid(points),\n//     }));\n\n//     // Bead centroids\n//     const beadCentroids = Array.from(beads, ([key, points]) => {\n//       const [cluster, bead] = key.split(\"-\");\n//       return {\n//         cluster,\n//         bead,\n//         centroid: calculateCentroid(points),\n//         points,\n//       };\n//     });\n\n//     // Build hierarchical links\n//     const links = [];\n//     const nodes = [\n//       {\n//         id: \"root\",\n//         ...rootCentroid,\n//         bitVector: assignBitVector(rootCentroid),\n//         isCentroid: true,\n//       }, // Root node\n//     ];\n\n//     // Add cluster nodes and links\n//     clusterCentroids.forEach(({ cluster, centroid }) => {\n//       nodes.push({\n//         id: `cluster-${cluster}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({ source: \"root\", target: `cluster-${cluster}` });\n//     });\n\n//     // Add bead nodes and links\n//     beadCentroids.forEach(({ cluster, bead, centroid, points }) => {\n//       nodes.push({\n//         id: `bead-${cluster}-${bead}`,\n//         ...centroid,\n//         bitVector: assignBitVector(centroid),\n//         isCentroid: true,\n//       });\n//       links.push({\n//         source: `cluster-${cluster}`,\n//         target: `bead-${cluster}-${bead}`,\n//       });\n\n//       // Add individual points and links\n//       points.forEach((point, index) => {\n//         const pointId = `point-${cluster}-${bead}-${index}`;\n//         nodes.push({\n//           id: pointId,\n//           ...point,\n//           bitVector: assignBitVector(point),\n//           isCentroid: false,\n//         });\n//         links.push({ source: `bead-${cluster}-${bead}`, target: pointId });\n//       });\n//     });\n\n//     // Set up container dimensions\n//     const container = d3.select(graphRef.current.parentNode);\n//     const width = container.node().getBoundingClientRect().width;\n//     const height = container.node().getBoundingClientRect().height;\n//     const margin = { top: 20, right: 20, bottom: 20, left: 20 };\n\n//     const svg = d3\n//       .select(graphRef.current)\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .attr(\"viewBox\", `0 0 ${width} ${height}`)\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\");\n\n//     // Clear previous render\n//     svg.selectAll(\"*\").remove();\n\n//     // Calculate the number of quadrants based on the number of dimensions\n//     const numDimensions = coordinateKeys.length;\n//     const numQuadrants = 2 ** numDimensions;\n\n//     // Calculate initial positions based on bit vectors\n//     nodes.forEach((node) => {\n//       if (node.bitVector) {\n//         // Convert the bit vector to a decimal number\n//         const quadrantIndex = parseInt(node.bitVector, 2);\n\n//         // Calculate quadrant size and starting position\n//         const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//         const numCols = Math.ceil(numQuadrants / numRows);\n//         const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//         const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//         const row = Math.floor(quadrantIndex / numCols);\n//         const col = quadrantIndex % numCols;\n\n//         const x = col * quadrantWidth + quadrantWidth / 2 + margin.left;\n//         const y = row * quadrantHeight + quadrantHeight / 2 + margin.top;\n\n//         node.x = x;\n//         node.y = y;\n//       }\n//     });\n\n//     // Draw grid lines\n//     const numRows = Math.ceil(Math.sqrt(numQuadrants));\n//     const numCols = Math.ceil(numQuadrants / numRows);\n//     const quadrantWidth = (width - margin.left - margin.right) / numCols;\n//     const quadrantHeight = (height - margin.top - margin.bottom) / numRows;\n\n//     const grid = svg.append(\"g\").attr(\"class\", \"grid\");\n\n//     // Draw vertical lines\n//     for (let i = 0; i <= numCols; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left + i * quadrantWidth)\n//         .attr(\"y1\", margin.top)\n//         .attr(\"x2\", margin.left + i * quadrantWidth)\n//         .attr(\"y2\", height - margin.bottom)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Draw horizontal lines\n//     for (let i = 0; i <= numRows; i++) {\n//       grid\n//         .append(\"line\")\n//         .attr(\"x1\", margin.left)\n//         .attr(\"y1\", margin.top + i * quadrantHeight)\n//         .attr(\"x2\", width - margin.right)\n//         .attr(\"y2\", margin.top + i * quadrantHeight)\n//         .attr(\"stroke\", \"#ddd\")\n//         .attr(\"stroke-width\", 1);\n//     }\n\n//     // Force simulation\n//     const simulation = d3\n//       .forceSimulation(nodes)\n//       .force(\n//         \"link\",\n//         d3\n//           .forceLink(links)\n//           .id((d) => d.id)\n//           .distance(-10)\n//       )\n//       .force(\n//         \"charge\",\n//         d3.forceManyBody().strength((d) => (d.isCentroid ? -20 : 1))\n//       )\n//       .force(\"center\", d3.forceCenter(width / 2, height / 2))\n//       .force(\n//         \"collision\",\n//         d3.forceCollide().radius((d) => (d.isCentroid ? 10 : 5))\n//       )\n\n//       .force(\n//         \"center\",\n//         d3.forceCenter(\n//           (width - margin.left - margin.right) / 2,\n//           (height - margin.top - margin.bottom) / 2\n//         )\n//       )\n//       .on(\"tick\", () => {\n//         link\n//           .attr(\"x1\", (d) =>\n//             clamp(d.source.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y1\", (d) =>\n//             clamp(d.source.y, margin.top, height - margin.bottom)\n//           )\n//           .attr(\"x2\", (d) =>\n//             clamp(d.target.x, margin.left, width - margin.right)\n//           )\n//           .attr(\"y2\", (d) =>\n//             clamp(d.target.y, margin.top, height - margin.bottom)\n//           );\n\n//         node\n//           .attr(\"cx\", (d) => clamp(d.x, margin.left, width - margin.right))\n//           .attr(\"cy\", (d) => clamp(d.y, margin.top, height - margin.bottom));\n//       });\n//     const clamp = (value, min, max) => Math.max(min, Math.min(value, max));\n\n//     // Draw links\n//     const link = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"links\")\n//       .selectAll(\"line\")\n//       .data(links)\n//       .enter()\n//       .append(\"line\")\n//       .attr(\"stroke\", \"#aaa\")\n//       .attr(\"stroke-width\", 2);\n\n//     // Draw nodes\n//     const node = svg\n//       .append(\"g\")\n//       .attr(\"class\", \"nodes\")\n//       .selectAll(\"circle\")\n//       .data(nodes)\n//       .enter()\n//       .append(\"circle\")\n//       .attr(\"r\", (d) => (d.isCentroid ? 10 : 5))\n//       .attr(\"fill\", (d) => {\n//         if (d.id === \"root\") return \"red\";\n//         if (d.id.startsWith(\"cluster\")) return \"blue\";\n//         if (d.id.startsWith(\"bead\")) return \"green\";\n//         return \"gray\";\n//       })\n//       .on(\"mouseover\", (event, d) => {\n//         const coordinates = {};\n//         coordinateKeys.forEach((key) => {\n//           coordinates[key] = d[key];\n//         });\n\n//         setHoveredCoordinates({\n//           ...coordinates,\n//           id: d.id,\n//           bitVector: d.bitVector,\n//         });\n//       })\n//       .call(\n//         d3\n//           .drag()\n//           .on(\"start\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0.3).restart();\n//             event.subject.fx = event.subject.x;\n//             event.subject.fy = event.subject.y;\n//           })\n//           .on(\"drag\", (event) => {\n//             event.subject.fx = event.x;\n//             event.subject.fy = event.y;\n//           })\n//           .on(\"end\", (event) => {\n//             if (!event.active) simulation.alphaTarget(0);\n//             event.subject.fx = null;\n//             event.subject.fy = null;\n//           })\n//       );\n\n//     // Add tooltips\n//     node.append(\"title\").text((d) => `ID: ${d.id}\\nBit Vector: ${d.bitVector}`);\n//   }, [jsonData, setHoveredCoordinates]);\n\n//   return <svg ref={graphRef} style={{ width: \"100%\", height: \"100%\" }}></svg>;\n// };\n\n// export default HierarchicalGraph;"],"mappings":";AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}