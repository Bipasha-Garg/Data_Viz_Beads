{"ast":null,"code":"var _jsxFileName = \"/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef, useState } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates, ringVisibility }) => {\n//   const graphRef = useRef(null);\n//   const [viewMode, setViewMode] = useState(\"normal\");\n\n//   useEffect(() => {\n//     if (!jsonData || typeof jsonData !== \"object\" || Object.keys(jsonData).length === 0) {\n//       console.error(\"Invalid or empty jsonData:\", jsonData);\n//       return;\n//     }\n\n//     if (!labelsData || typeof labelsData !== \"object\") {\n//       console.error(\"Invalid labelsData:\", labelsData);\n//       return;\n//     }\n\n//     const svg = d3.select(graphRef.current);\n//     svg.selectAll(\"*\").remove();\n\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     const getLabelColor = (pointId) => {\n//       if (!labelsData || !labelsData.labels) return \"gray\";\n//       for (const label of Object.keys(labelsData.labels)) {\n//         const pointList = labelsData.labels[label];\n//         if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n//           return colorScale(label);\n//         }\n//       }\n//       return \"gray\";\n//     };\n\n//     const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(Object.keys(labelsData.labels || {}));\n//     const getRingColor = (index) => {\n//       const totalRings = Object.keys(jsonData).length;\n//       const colorScaleInd = d3.scaleSequential(d3.interpolatePlasma).domain([totalRings, 0]);\n//       return d3.color(colorScaleInd(index));\n//     };\n//     const getSectorColor = (index, sectorIndex) => {\n//       const baseColor = d3.hsl(getRingColor(index));\n//       const isPositive = sectorIndex % 2 === 0;\n//       return d3.hsl(baseColor.h, baseColor.s, isPositive ? 0.75 : 0.35).toString();\n//     };\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key] || [],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n//     console.log(\"Points data:\", pointsData.dimensions);\n//     const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i));\n//     const pointPositions = {};\n\n//     const calculateProportionalAngles = () => {\n//       console.log(\"Starting calculateProportionalAngles...\");\n//       console.log(\"pointsData:\", pointsData);\n\n//       if (pointsData.length === 0) {\n//         console.error(\"No points data available\");\n//         return [];\n//       }\n\n//       const lastRing = pointsData[pointsData.length - 1];\n//       const lastRingPoints = lastRing.points || [];\n//       const sectorsCount = Math.max(1, 2 ** pointsData.dimensions);\n\n//       console.log(\"Last ring:\", lastRing);\n//       console.log(\"Last ring points length:\", lastRingPoints.length);\n//       console.log(\"Sectors count:\", sectorsCount);\n\n//       // Fallback for empty or invalid last ring\n//       if (lastRingPoints.length === 0 || !Number.isFinite(sectorsCount)) {\n//         console.warn(\"Invalid last ring data, using equal angles\");\n//         return pointsData.map((_, i) => {\n//           const sectorCount = Math.max(1, 2 ** (i + 1));\n//           console.log(`Ring ${i} sector count: ${sectorCount}`);\n//           return Array(sectorCount).fill(2 * Math.PI / sectorCount);\n//         });\n//       }\n\n//       const pointCounts = new Array(sectorsCount).fill(0);\n//       console.log(\"Initialized pointCounts:\", pointCounts);\n\n//       lastRingPoints.forEach((point, idx) => {\n//         const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n//         const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n//         const sectorIndex = parseInt(bitVector, 2);\n//         if (sectorIndex >= 0 && sectorIndex < sectorsCount) {\n//           pointCounts[sectorIndex]++;\n//         } else {\n//           console.warn(`Point ${idx}: Invalid sector index ${sectorIndex} for bitVector ${bitVector}`);\n//         }\n//       });\n\n//       console.log(\"Point counts per sector:\", pointCounts);\n\n//       const minAngle = Math.PI / 180; // 1 degree minimum\n//       const totalAngle = 2 * Math.PI;\n//       const totalNonEmptyPoints = Math.max(0, pointCounts.reduce((sum, count) => sum + count, 0));\n//       const remainingAngle = totalAngle - (sectorsCount * minAngle);\n\n//       console.log(\"Total non-empty points:\", totalNonEmptyPoints);\n//       console.log(\"Remaining angle:\", remainingAngle);\n\n//       const sectorAngles = pointCounts.map((count, idx) => {\n//         const angle = count > 0\n//           ? (count / totalNonEmptyPoints) * remainingAngle\n//           : minAngle;\n//         console.log(`Sector ${idx} angle: ${angle}`);\n//         return angle;\n//       });\n\n//       console.log(\"Sector angles:\", sectorAngles);\n\n//       // Propagate angles to inner rings\n//       const ringAngles = [sectorAngles];\n//       for (let i = pointsData.length - 2; i >= 0; i--) {\n//         const prevAngles = ringAngles[0];\n//         const sectorCount = Math.max(1, 2 ** (i + 1));\n//         if (!Number.isFinite(sectorCount)) {\n//           console.error(`Invalid sectorCount for ring ${i}: ${sectorCount}`);\n//           return []; \n//         }\n//         console.log(`Ring ${i}, sectorCount: ${sectorCount}, isFinite: ${Number.isFinite(sectorCount)}`);\n\n//         const currAngles = new Array(sectorCount);\n//         console.log(`Propagating to ring ${i}, expected sectors: ${sectorCount}`);\n\n//         for (let j = 0; j < sectorCount; j++) {\n//           const angle1 = prevAngles[j * 2] || 0;\n//           const angle2 = prevAngles[j * 2 + 1] || 0;\n//           currAngles[j] = angle1 + angle2;\n//           console.log(`Ring ${i}, sector ${j}: ${currAngles[j]} (from ${angle1} + ${angle2})`);\n//         }\n//         ringAngles.unshift(currAngles);\n//       }\n\n//       console.log(\"Final ring angles:\", ringAngles);\n//       return ringAngles;\n//     };\n\n//     const renderNormalView = () => {\n//       subspaces.forEach((key, index) => {\n//         if (!ringVisibility[key]) return;\n//         const innerRadius = (index / subspaces.length) * maxRadius;\n//         const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//         const sectors = 2 ** (index + 1);\n//         const rotationOffset = Math.PI / 2;\n\n//         for (let i = 0; i < sectors; i++) {\n//           const startAngle = (2 * Math.PI * i) / sectors + rotationOffset;\n//           const endAngle = (2 * Math.PI * (i + 1)) / sectors + rotationOffset;\n\n//           g.append(\"path\")\n//             .attr(\"d\", d3.arc()\n//               .innerRadius(innerRadius)\n//               .outerRadius(outerRadius)\n//               .startAngle(startAngle)\n//               .endAngle(endAngle)\n//             )\n//             .attr(\"fill\", getSectorColor(index, i))\n//             .attr(\"fill-opacity\", 0.3)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 0.5)\n//             .style(\"cursor\", \"pointer\");\n\n//           g.append(\"text\")\n//             .attr(\"x\", 0)\n//             .attr(\"y\", -outerRadius - 5)\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"font-size\", \"16px\")\n//             .attr(\"fill\", \"red\")\n//             .attr(\"font-weight\", \"bold\")\n//             .text(ringLabels[index]);\n//         }\n//         renderPoints(index, innerRadius, outerRadius, sectors);\n//       });\n//     };\n\n//     const renderProportionalView = () => {\n//       const ringAngles = calculateProportionalAngles();\n//       console.log(\"Rendering proportional view with ringAngles:\", ringAngles);\n\n//       if (!ringAngles || ringAngles.length !== pointsData.length || ringAngles.some(arr => !arr || !Array.isArray(arr))) {\n//         console.error(\"Invalid ring angles, falling back to normal view:\", ringAngles);\n//         renderNormalView();\n//         return;\n//       }\n\n//       subspaces.forEach((key, index) => {\n//         if (!ringVisibility[key]) return;\n//         const innerRadius = (index / subspaces.length) * maxRadius;\n//         const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//         let currentAngle = Math.PI / 2 - 90;\n\n//         ringAngles[index].forEach((angle, i) => {\n//           const startAngle = currentAngle;\n//           const endAngle = currentAngle + angle;\n\n//           g.append(\"path\")\n//             .attr(\"d\", d3.arc()\n//               .innerRadius(innerRadius)\n//               .outerRadius(outerRadius)\n//               .startAngle(startAngle)\n//               .endAngle(endAngle)\n//             )\n//             .attr(\"fill\", getSectorColor(index, i))\n//             .attr(\"fill-opacity\", 0.3)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 0.5)\n//             .style(\"cursor\", \"pointer\");\n\n//           currentAngle = endAngle;\n//         });\n\n//         g.append(\"text\")\n//           .attr(\"x\", 0)\n//           .attr(\"y\", -outerRadius - 5)\n//           .attr(\"text-anchor\", \"middle\")\n//           .attr(\"font-size\", \"16px\")\n//           .attr(\"fill\", \"red\")\n//           .attr(\"font-weight\", \"bold\")\n//           .text(ringLabels[index]);\n\n//         renderPoints(index, innerRadius, outerRadius, ringAngles[index]);\n//       });\n//     };\n\n//     const renderPoints = (index, innerRadius, outerRadius, anglesOrSectors) => {\n//       const isProportional = viewMode === \"proportional\";\n//       const sectors = isProportional ? anglesOrSectors.length : anglesOrSectors;\n//       const angles = isProportional ? anglesOrSectors : Array(sectors).fill(2 * Math.PI / sectors);\n\n//       let currentAngle = Math.PI / 2;\n//       pointsData[index].points.forEach((point, i) => {\n//         const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n//         const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n//         const bitVectorIndex = Math.min(parseInt(bitVector, 2), sectors - 1);\n\n//         const startAngle = isProportional ?\n//           currentAngle + angles.slice(0, bitVectorIndex).reduce((a, b) => a + b, 0) :\n//           (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleWidth = isProportional ? angles[bitVectorIndex] : (2 * Math.PI / sectors);\n//         const centerAngle = startAngle + angleWidth / 2;\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius = minRadius + Math.random() * (maxRadius - minRadius);\n//         const totalPoints = pointsData[index].points.length;\n//         const clusterFactor = 0.9;\n//         const overlapRadius =\n//           innerRadius +\n//           (clusterFactor * (outerRadius - innerRadius) * (i % totalPoints)) /\n//           totalPoints;\n//         const x = overlapRadius * Math.cos(centerAngle);\n//         const y = overlapRadius * Math.sin(centerAngle);\n\n//         point.Point_ID.forEach((id) => {\n//           if (!pointPositions[id]) {\n//             pointPositions[id] = [];\n//           }\n//           pointPositions[id].push({ x, y, point, subspaceId: pointsData[index].key });\n//         });\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             const pointIds = point.Point_ID.join(\", \");\n//             let associatedLabels = [];\n//             if (labelsData && labelsData.labels) {\n//               Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n//                 if (point.Point_ID.some(id => pointList.includes(Number(id)))) {\n//                   associatedLabels.push(label);\n//                 }\n//               });\n//             }\n//             const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(\n//                 `Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})<br>Subspace: ${pointsData[index].key}<br>Label: ${labelText}`\n//               );\n//             setHoveredCoordinates({ ...point, label: labelText });\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//             setHoveredCoordinates(null);\n//           });\n//       });\n//     };\n\n//     if (viewMode === \"normal\") {\n//       renderNormalView();\n//     } else {\n//       renderProportionalView();\n//     }\n\n//     Object.entries(pointPositions).forEach(([pointId, positions]) => {\n//       if (positions.length > 1) {\n//         for (let i = 0; i < positions.length - 1; i++) {\n//           const line = g.append(\"line\")\n//             .attr(\"x1\", positions[i].x)\n//             .attr(\"y1\", positions[i].y)\n//             .attr(\"x2\", positions[i + 1].x)\n//             .attr(\"y2\", positions[i + 1].y)\n//             .attr(\"stroke\", getLabelColor(pointId))\n//             .attr(\"stroke-width\", 1.5)\n//             .attr(\"stroke-opacity\", 0.9)\n//             .style(\"cursor\", \"pointer\")\n//             .on(\"mouseover\", (event) => {\n//               tooltip\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`Connection: Point_ID ${pointId}`);\n//             })\n//             .on(\"mousemove\", (event) => {\n//               tooltip\n//                 .style(\"top\", event.pageY + 10 + \"px\")\n//                 .style(\"left\", event.pageX + 10 + \"px\");\n//             })\n//             .on(\"mouseout\", () => {\n//               tooltip.style(\"visibility\", \"hidden\");\n//             });\n//         }\n//       }\n//     });\n\n//     const zoom = d3.zoom().on(\"zoom\", (event) => {\n//       g.attr(\"transform\", event.transform);\n//     });\n//     svg.call(zoom);\n\n//     return () => {\n//       tooltip.remove();\n//     };\n//   }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates, viewMode]);\n\n//   return (\n//     <div style={{ width: \"100%\", height: \"100%\" }}>\n//       <div style={{ marginBottom: \"10px\" }}>\n//         <button\n//           onClick={() => setViewMode(\"normal\")}\n//           style={{\n//             marginRight: \"10px\",\n//             padding: \"5px 10px\",\n//             backgroundColor: viewMode === \"normal\" ? \"#4CAF50\" : \"#f0f0f0\",\n//             color: viewMode === \"normal\" ? \"white\" : \"black\",\n//           }}\n//         >\n//           Normal View\n//         </button>\n//         <button\n//           onClick={() => setViewMode(\"proportional\")}\n//           style={{\n//             padding: \"5px 10px\",\n//             backgroundColor: viewMode === \"proportional\" ? \"#4CAF50\" : \"#f0f0f0\",\n//             color: viewMode === \"proportional\" ? \"white\" : \"black\",\n//           }}\n//         >\n//           Proportional View\n//         </button>\n//       </div>\n//       <svg ref={graphRef} style={{ width: \"100%\", height: \"800px\" }}></svg>\n//     </div>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HierarchicalGraph = ({\n  jsonData,\n  labelsData,\n  setHoveredCoordinates,\n  ringVisibility\n}) => {\n  _s();\n  const graphRef = useRef(null);\n  const [viewMode, setViewMode] = useState(\"normal\");\n  useEffect(() => {\n    if (!jsonData || typeof jsonData !== \"object\" || Object.keys(jsonData).length === 0) {\n      console.error(\"Invalid or empty jsonData:\", jsonData);\n      return;\n    }\n    if (!labelsData || typeof labelsData !== \"object\") {\n      console.error(\"Invalid labelsData:\", labelsData);\n      return;\n    }\n    const svg = d3.select(graphRef.current);\n    svg.selectAll(\"*\").remove();\n    const width = 800;\n    const height = 800;\n    const margin = 20;\n    const maxRadius = Math.min(width, height) / 2 - margin;\n\n    // Create a single group element for all content\n    const g = svg.attr(\"width\", width).attr(\"height\", height).append(\"g\").attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n    // Create tooltip only once and reuse it\n    let tooltip = d3.select(\"body\").select(\".hierarchical-graph-tooltip\");\n    if (tooltip.empty()) {\n      tooltip = d3.select(\"body\").append(\"div\").attr(\"class\", \"hierarchical-graph-tooltip\").style(\"position\", \"absolute\").style(\"visibility\", \"hidden\").style(\"background-color\", \"rgba(0, 0, 0, 0.7)\").style(\"color\", \"white\").style(\"padding\", \"5px\").style(\"border-radius\", \"4px\").style(\"font-size\", \"12px\");\n    }\n\n    // Use memoized color functions to avoid recalculating\n    const colorCache = new Map();\n    const getLabelColor = pointId => {\n      if (colorCache.has(`label-${pointId}`)) {\n        return colorCache.get(`label-${pointId}`);\n      }\n      if (!labelsData || !labelsData.labels) {\n        colorCache.set(`label-${pointId}`, \"gray\");\n        return \"gray\";\n      }\n      for (const label of Object.keys(labelsData.labels)) {\n        const pointList = labelsData.labels[label];\n        if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n          const color = colorScale(label);\n          colorCache.set(`label-${pointId}`, color);\n          return color;\n        }\n      }\n      colorCache.set(`label-${pointId}`, \"gray\");\n      return \"gray\";\n    };\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(Object.keys(labelsData.labels || {}));\n    const ringColorCache = new Map();\n    const getRingColor = index => {\n      if (ringColorCache.has(index)) {\n        return ringColorCache.get(index);\n      }\n      const totalRings = Object.keys(jsonData).length;\n      const colorScaleInd = d3.scaleSequential(d3.interpolatePlasma).domain([totalRings, 0]);\n      const color = d3.color(colorScaleInd(index));\n      ringColorCache.set(index, color);\n      return color;\n    };\n    const sectorColorCache = new Map();\n    const getSectorColor = (index, sectorIndex) => {\n      const key = `${index}-${sectorIndex}`;\n      if (sectorColorCache.has(key)) {\n        return sectorColorCache.get(key);\n      }\n      const baseColor = d3.hsl(getRingColor(index));\n      const isPositive = sectorIndex % 2 === 0;\n      const color = d3.hsl(baseColor.h, baseColor.s, isPositive ? 0.75 : 0.35).toString();\n      sectorColorCache.set(key, color);\n      return color;\n    };\n    const subspaces = Object.keys(jsonData);\n    subspaces.sort((a, b) => a.length - b.length);\n\n    // Preprocess data once\n    const pointsData = subspaces.map(key => {\n      const points = jsonData[key] || [];\n      const dimensions = key.length;\n\n      // Pre-calculate sector indices for each point\n      const pointsWithSectors = points.map(point => {\n        const pointData = Object.entries(point).filter(([k]) => k !== \"Point_ID\");\n        const bitVector = pointData.map(([_, coord]) => coord >= 0 ? 1 : 0).join(\"\");\n        const sectorIndex = parseInt(bitVector, 2);\n        return {\n          ...point,\n          sectorIndex\n        };\n      });\n      return {\n        key,\n        points: pointsWithSectors,\n        dimensions,\n        subspaceId: key\n      };\n    });\n    const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i));\n    const pointPositions = {};\n    const calculateProportionalAngles = () => {\n      // Count points in each sector for each ring (optimize calculation)\n      const sectorCounts = pointsData.map(ring => {\n        const sectors = 2 ** ring.dimensions;\n        const counts = new Array(sectors).fill(0);\n\n        // Use pre-calculated sector indices\n        ring.points.forEach(point => {\n          if (point.sectorIndex >= 0 && point.sectorIndex < sectors) {\n            counts[point.sectorIndex]++;\n          }\n        });\n        return counts;\n      });\n\n      // Calculate initial angles based on point counts\n      const angles = sectorCounts.map(counts => {\n        const totalPoints = Math.max(1, counts.reduce((sum, count) => sum + count, 0));\n        const totalAngle = 2 * Math.PI;\n        const minAngle = Math.PI / 180;\n        const sectors = counts.length;\n        const remainingAngle = totalAngle - sectors * minAngle;\n        return counts.map(count => count > 0 ? minAngle + count / totalPoints * remainingAngle : minAngle);\n      });\n\n      // Adjust angles to maintain hierarchy (work with a copy to avoid modifying original)\n      const adjustedAngles = angles.map(ring => [...ring]);\n\n      // From inner to outer rings\n      for (let i = 0; i < adjustedAngles.length - 1; i++) {\n        const currentRing = adjustedAngles[i];\n        const nextRing = adjustedAngles[i + 1];\n\n        // Process each parent sector\n        for (let j = 0; j < currentRing.length; j++) {\n          const childIndex1 = j * 2;\n          const childIndex2 = j * 2 + 1;\n          if (childIndex1 < nextRing.length && childIndex2 < nextRing.length) {\n            const childSum = nextRing[childIndex1] + nextRing[childIndex2];\n            if (childSum > 0) {\n              // Calculate ratios while avoiding division by zero\n              const ratio1 = nextRing[childIndex1] / childSum;\n              const ratio2 = nextRing[childIndex2] / childSum;\n\n              // Distribute parent angle to children\n              nextRing[childIndex1] = currentRing[j] * ratio1;\n              nextRing[childIndex2] = currentRing[j] * ratio2;\n            }\n          }\n        }\n      }\n      return adjustedAngles;\n    };\n\n    // Create sector paths and cache them for reuse\n    const createSectorPath = (innerRadius, outerRadius, startAngle, endAngle) => {\n      return d3.arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(startAngle).endAngle(endAngle)();\n    };\n    const renderNormalView = () => {\n      // Create container groups for each ring to reduce DOM nodes\n      const ringGroups = subspaces.map((key, index) => {\n        if (!ringVisibility[key]) return null;\n        return g.append(\"g\").attr(\"class\", `ring-${index}`);\n      });\n      subspaces.forEach((key, index) => {\n        if (!ringVisibility[key] || !ringGroups[index]) return;\n        const ringGroup = ringGroups[index];\n        const innerRadius = index / subspaces.length * maxRadius;\n        const outerRadius = (index + 1) / subspaces.length * maxRadius;\n        const sectors = 2 ** pointsData[index].dimensions;\n        const rotationOffset = Math.PI / 2;\n\n        // Create all sectors in a single pass\n        const sectorsData = Array.from({\n          length: sectors\n        }, (_, i) => {\n          const startAngle = 2 * Math.PI * i / sectors + rotationOffset;\n          const endAngle = 2 * Math.PI * (i + 1) / sectors + rotationOffset;\n          return {\n            index: i,\n            startAngle,\n            endAngle\n          };\n        });\n\n        // Batch append sectors\n        sectorsData.forEach(({\n          index: i,\n          startAngle,\n          endAngle\n        }) => {\n          ringGroup.append(\"path\").attr(\"d\", createSectorPath(innerRadius, outerRadius, startAngle, endAngle)).attr(\"fill\", getSectorColor(index, i)).attr(\"fill-opacity\", 0.3).attr(\"stroke\", \"black\").attr(\"stroke-width\", 0.5);\n        });\n\n        // Add ring label\n        ringGroup.append(\"text\").attr(\"x\", 0).attr(\"y\", -outerRadius - 5).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"16px\").attr(\"fill\", \"red\").attr(\"font-weight\", \"bold\").text(ringLabels[index]);\n\n        // Render points using the normal view settings\n        renderPoints(ringGroup, index, innerRadius, outerRadius, sectors);\n      });\n    };\n    const renderProportionalView = () => {\n      const ringAngles = calculateProportionalAngles();\n      if (!ringAngles || ringAngles.length !== pointsData.length) {\n        console.error(\"Invalid ring angles, falling back to normal view\");\n        renderNormalView();\n        return;\n      }\n\n      // Create container groups for each ring\n      const ringGroups = subspaces.map((key, index) => {\n        if (!ringVisibility[key]) return null;\n        return g.append(\"g\").attr(\"class\", `ring-${index}`);\n      });\n      subspaces.forEach((key, index) => {\n        if (!ringVisibility[key] || !ringGroups[index]) return;\n        const ringGroup = ringGroups[index];\n        const innerRadius = index / subspaces.length * maxRadius;\n        const outerRadius = (index + 1) / subspaces.length * maxRadius;\n        const rotationOffset = Math.PI / 2;\n\n        // Create sectors based on calculated angles\n        let currentAngle = rotationOffset;\n        ringAngles[index].forEach((angle, i) => {\n          const startAngle = currentAngle;\n          const endAngle = currentAngle + angle;\n          ringGroup.append(\"path\").attr(\"d\", createSectorPath(innerRadius, outerRadius, startAngle, endAngle)).attr(\"fill\", getSectorColor(index, i)).attr(\"fill-opacity\", 0.3).attr(\"stroke\", \"black\").attr(\"stroke-width\", 0.5);\n          currentAngle = endAngle;\n        });\n\n        // Add ring label\n        ringGroup.append(\"text\").attr(\"x\", 0).attr(\"y\", -outerRadius - 5).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"16px\").attr(\"fill\", \"red\").attr(\"font-weight\", \"bold\").text(ringLabels[index]);\n\n        // Render points using the proportional view settings\n        renderPoints(ringGroup, index, innerRadius, outerRadius, ringAngles[index], true);\n      });\n    };\n\n    // Optimized point rendering with batching\n    const renderPoints = (ringGroup, ringIndex, innerRadius, outerRadius, anglesOrSectors, isProportional = false) => {\n      const points = pointsData[ringIndex].points;\n      const sectors = isProportional ? anglesOrSectors.length : anglesOrSectors;\n      const rotationOffset = Math.PI / 2;\n\n      // Pre-calculate angles for all sectors to avoid repeated calculations\n      const sectorAngleMap = new Map();\n      if (isProportional) {\n        let currentAngle = rotationOffset;\n        anglesOrSectors.forEach((angle, i) => {\n          sectorAngleMap.set(i, {\n            startAngle: currentAngle,\n            width: angle\n          });\n          currentAngle += angle;\n        });\n      } else {\n        const equalAngle = 2 * Math.PI / sectors;\n        for (let i = 0; i < sectors; i++) {\n          sectorAngleMap.set(i, {\n            startAngle: rotationOffset + equalAngle * i,\n            width: equalAngle\n          });\n        }\n      }\n\n      // Use object pooling for point data\n      const pointElements = [];\n      points.forEach((point, i) => {\n        const sectorIndex = point.sectorIndex;\n        if (!sectorAngleMap.has(sectorIndex)) return;\n        const {\n          startAngle,\n          width\n        } = sectorAngleMap.get(sectorIndex);\n        const centerAngle = startAngle + width / 2;\n\n        // Distribute points within sector to avoid overlapping\n        const jitter = 0.7 * (Math.random() - 0.5) * width;\n        const jitteredAngle = centerAngle + jitter;\n\n        // Use deterministic radius calculation based on point index\n        const radiusSpan = outerRadius - innerRadius;\n        const radiusOffset = i % 5 * (radiusSpan / 5);\n        const radius = innerRadius + radiusOffset + radiusSpan * 0.1;\n        const x = radius * Math.cos(jitteredAngle);\n        const y = radius * Math.sin(jitteredAngle);\n\n        // Store position for connection lines\n        if (point.Point_ID) {\n          point.Point_ID.forEach(id => {\n            if (!pointPositions[id]) {\n              pointPositions[id] = [];\n            }\n            pointPositions[id].push({\n              x,\n              y,\n              point,\n              subspaceId: pointsData[ringIndex].key\n            });\n          });\n        }\n\n        // Create point element data\n        pointElements.push({\n          x,\n          y,\n          point\n        });\n      });\n\n      // Batch append all points\n      const pointsGroup = ringGroup.append(\"g\").attr(\"class\", \"points\");\n      pointsGroup.selectAll(\"circle\").data(pointElements).enter().append(\"circle\").attr(\"cx\", d => d.x).attr(\"cy\", d => d.y).attr(\"r\", 3).attr(\"fill\", \"black\").attr(\"stroke\", \"white\").attr(\"stroke-width\", 0.5).style(\"pointer-events\", \"visible\").on(\"mouseover\", function (event, d) {\n        const pointIds = d.point.Point_ID ? d.point.Point_ID.join(\", \") : \"\";\n        let associatedLabels = [];\n        if (labelsData && labelsData.labels && d.point.Point_ID) {\n          Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n            if (d.point.Point_ID.some(id => pointList.includes(Number(id)))) {\n              associatedLabels.push(label);\n            }\n          });\n        }\n        const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n        tooltip.style(\"visibility\", \"visible\").html(`Point_IDs: ${pointIds}<br>Coordinates: (${d.x.toFixed(2)}, ${d.y.toFixed(2)})<br>Subspace: ${pointsData[ringIndex].key}<br>Label: ${labelText}`);\n        if (setHoveredCoordinates) {\n          setHoveredCoordinates({\n            ...d.point,\n            label: labelText\n          });\n        }\n      }).on(\"mousemove\", event => {\n        tooltip.style(\"top\", event.pageY + 10 + \"px\").style(\"left\", event.pageX + 10 + \"px\");\n      }).on(\"mouseout\", () => {\n        tooltip.style(\"visibility\", \"hidden\");\n        if (setHoveredCoordinates) {\n          setHoveredCoordinates(null);\n        }\n      });\n    };\n\n    // Render the appropriate view\n    if (viewMode === \"normal\") {\n      renderNormalView();\n    } else {\n      renderProportionalView();\n    }\n\n    // Batch process connections (lines between related points)\n    const batchConnections = () => {\n      const connections = [];\n\n      // Build connection data first\n      Object.entries(pointPositions).forEach(([pointId, positions]) => {\n        if (positions.length > 1) {\n          for (let i = 0; i < positions.length - 1; i++) {\n            connections.push({\n              x1: positions[i].x,\n              y1: positions[i].y,\n              x2: positions[i + 1].x,\n              y2: positions[i + 1].y,\n              pointId,\n              color: getLabelColor(pointId)\n            });\n          }\n        }\n      });\n\n      // Batch append all connections\n      const linesGroup = g.append(\"g\").attr(\"class\", \"connections\");\n      linesGroup.selectAll(\"line\").data(connections).enter().append(\"line\").attr(\"x1\", d => d.x1).attr(\"y1\", d => d.y1).attr(\"x2\", d => d.x2).attr(\"y2\", d => d.y2).attr(\"stroke\", d => d.color).attr(\"stroke-width\", 1).attr(\"stroke-opacity\", 0.7).on(\"mouseover\", function (event, d) {\n        tooltip.style(\"visibility\", \"visible\").html(`Connection: Point_ID ${d.pointId}`);\n      }).on(\"mousemove\", event => {\n        tooltip.style(\"top\", event.pageY + 10 + \"px\").style(\"left\", event.pageX + 10 + \"px\");\n      }).on(\"mouseout\", () => {\n        tooltip.style(\"visibility\", \"hidden\");\n      });\n    };\n\n    // Draw connections\n    batchConnections();\n\n    // Add zoom behavior\n    const zoom = d3.zoom().scaleExtent([0.5, 5]).on(\"zoom\", event => {\n      g.attr(\"transform\", event.transform);\n    });\n    svg.call(zoom);\n\n    // Only remove tooltip on component unmount\n    return () => {\n      // Don't remove tooltip, it will be reused\n    };\n  }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates, viewMode]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginBottom: \"10px\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setViewMode(\"normal\"),\n        style: {\n          marginRight: \"10px\",\n          padding: \"5px 10px\",\n          backgroundColor: viewMode === \"normal\" ? \"#4CAF50\" : \"#f0f0f0\",\n          color: viewMode === \"normal\" ? \"white\" : \"black\"\n        },\n        children: \"Normal View\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 899,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setViewMode(\"proportional\"),\n        style: {\n          padding: \"5px 10px\",\n          backgroundColor: viewMode === \"proportional\" ? \"#4CAF50\" : \"#f0f0f0\",\n          color: viewMode === \"proportional\" ? \"white\" : \"black\"\n        },\n        children: \"Proportional View\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 910,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 898,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: graphRef,\n      style: {\n        width: \"100%\",\n        height: \"800px\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 921,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 897,\n    columnNumber: 5\n  }, this);\n};\n_s(HierarchicalGraph, \"CVuPsSNXbeMAdW5BbQwuQu7RE7g=\");\n_c = HierarchicalGraph;\nexport default HierarchicalGraph;\nvar _c;\n$RefreshReg$(_c, \"HierarchicalGraph\");","map":{"version":3,"names":["React","useEffect","useRef","useState","d3","jsxDEV","_jsxDEV","HierarchicalGraph","jsonData","labelsData","setHoveredCoordinates","ringVisibility","_s","graphRef","viewMode","setViewMode","Object","keys","length","console","error","svg","select","current","selectAll","remove","width","height","margin","maxRadius","Math","min","g","attr","append","tooltip","empty","style","colorCache","Map","getLabelColor","pointId","has","get","labels","set","label","pointList","Array","isArray","includes","Number","color","colorScale","scaleOrdinal","schemeCategory10","domain","ringColorCache","getRingColor","index","totalRings","colorScaleInd","scaleSequential","interpolatePlasma","sectorColorCache","getSectorColor","sectorIndex","key","baseColor","hsl","isPositive","h","s","toString","subspaces","sort","a","b","pointsData","map","points","dimensions","pointsWithSectors","point","pointData","entries","filter","k","bitVector","_","coord","join","parseInt","subspaceId","ringLabels","i","String","fromCharCode","pointPositions","calculateProportionalAngles","sectorCounts","ring","sectors","counts","fill","forEach","angles","totalPoints","max","reduce","sum","count","totalAngle","PI","minAngle","remainingAngle","adjustedAngles","currentRing","nextRing","j","childIndex1","childIndex2","childSum","ratio1","ratio2","createSectorPath","innerRadius","outerRadius","startAngle","endAngle","arc","renderNormalView","ringGroups","ringGroup","rotationOffset","sectorsData","from","text","renderPoints","renderProportionalView","ringAngles","currentAngle","angle","ringIndex","anglesOrSectors","isProportional","sectorAngleMap","equalAngle","pointElements","centerAngle","jitter","random","jitteredAngle","radiusSpan","radiusOffset","radius","x","cos","y","sin","Point_ID","id","push","pointsGroup","data","enter","d","on","event","pointIds","associatedLabels","some","labelText","html","toFixed","pageY","pageX","batchConnections","connections","positions","x1","y1","x2","y2","linesGroup","zoom","scaleExtent","transform","call","children","marginBottom","onClick","marginRight","padding","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["/home/bipasha/Desktop/research/Data_Viz_Beads/Subspace/code/my-react-app/src/JsonDisplay.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from \"react\";\n// import * as d3 from \"d3\";\n\n// const HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates, ringVisibility }) => {\n//   const graphRef = useRef(null);\n//   const [viewMode, setViewMode] = useState(\"normal\");\n\n//   useEffect(() => {\n//     if (!jsonData || typeof jsonData !== \"object\" || Object.keys(jsonData).length === 0) {\n//       console.error(\"Invalid or empty jsonData:\", jsonData);\n//       return;\n//     }\n\n//     if (!labelsData || typeof labelsData !== \"object\") {\n//       console.error(\"Invalid labelsData:\", labelsData);\n//       return;\n//     }\n\n//     const svg = d3.select(graphRef.current);\n//     svg.selectAll(\"*\").remove();\n\n//     const width = 800;\n//     const height = 800;\n//     const margin = 20;\n//     const maxRadius = Math.min(width, height) / 2 - margin;\n\n//     const g = svg\n//       .attr(\"width\", width)\n//       .attr(\"height\", height)\n//       .append(\"g\")\n//       .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n//     const tooltip = d3\n//       .select(\"body\")\n//       .append(\"div\")\n//       .attr(\"class\", \"tooltip\")\n//       .style(\"position\", \"absolute\")\n//       .style(\"visibility\", \"hidden\")\n//       .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n//       .style(\"color\", \"white\")\n//       .style(\"padding\", \"5px\")\n//       .style(\"border-radius\", \"4px\")\n//       .style(\"font-size\", \"12px\");\n\n//     const getLabelColor = (pointId) => {\n//       if (!labelsData || !labelsData.labels) return \"gray\";\n//       for (const label of Object.keys(labelsData.labels)) {\n//         const pointList = labelsData.labels[label];\n//         if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n//           return colorScale(label);\n//         }\n//       }\n//       return \"gray\";\n//     };\n\n//     const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(Object.keys(labelsData.labels || {}));\n//     const getRingColor = (index) => {\n//       const totalRings = Object.keys(jsonData).length;\n//       const colorScaleInd = d3.scaleSequential(d3.interpolatePlasma).domain([totalRings, 0]);\n//       return d3.color(colorScaleInd(index));\n//     };\n//     const getSectorColor = (index, sectorIndex) => {\n//       const baseColor = d3.hsl(getRingColor(index));\n//       const isPositive = sectorIndex % 2 === 0;\n//       return d3.hsl(baseColor.h, baseColor.s, isPositive ? 0.75 : 0.35).toString();\n//     };\n\n//     const subspaces = Object.keys(jsonData);\n//     subspaces.sort((a, b) => a.length - b.length);\n//     const pointsData = subspaces.map((key) => ({\n//       key,\n//       points: jsonData[key] || [],\n//       dimensions: key.length,\n//       subspaceId: key,\n//     }));\n//     console.log(\"Points data:\", pointsData.dimensions);\n//     const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i));\n//     const pointPositions = {};\n\n\n//     const calculateProportionalAngles = () => {\n//       console.log(\"Starting calculateProportionalAngles...\");\n//       console.log(\"pointsData:\", pointsData);\n\n//       if (pointsData.length === 0) {\n//         console.error(\"No points data available\");\n//         return [];\n//       }\n\n//       const lastRing = pointsData[pointsData.length - 1];\n//       const lastRingPoints = lastRing.points || [];\n//       const sectorsCount = Math.max(1, 2 ** pointsData.dimensions);\n\n//       console.log(\"Last ring:\", lastRing);\n//       console.log(\"Last ring points length:\", lastRingPoints.length);\n//       console.log(\"Sectors count:\", sectorsCount);\n\n//       // Fallback for empty or invalid last ring\n//       if (lastRingPoints.length === 0 || !Number.isFinite(sectorsCount)) {\n//         console.warn(\"Invalid last ring data, using equal angles\");\n//         return pointsData.map((_, i) => {\n//           const sectorCount = Math.max(1, 2 ** (i + 1));\n//           console.log(`Ring ${i} sector count: ${sectorCount}`);\n//           return Array(sectorCount).fill(2 * Math.PI / sectorCount);\n//         });\n//       }\n\n//       const pointCounts = new Array(sectorsCount).fill(0);\n//       console.log(\"Initialized pointCounts:\", pointCounts);\n\n//       lastRingPoints.forEach((point, idx) => {\n//         const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n//         const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n//         const sectorIndex = parseInt(bitVector, 2);\n//         if (sectorIndex >= 0 && sectorIndex < sectorsCount) {\n//           pointCounts[sectorIndex]++;\n//         } else {\n//           console.warn(`Point ${idx}: Invalid sector index ${sectorIndex} for bitVector ${bitVector}`);\n//         }\n//       });\n\n//       console.log(\"Point counts per sector:\", pointCounts);\n\n//       const minAngle = Math.PI / 180; // 1 degree minimum\n//       const totalAngle = 2 * Math.PI;\n//       const totalNonEmptyPoints = Math.max(0, pointCounts.reduce((sum, count) => sum + count, 0));\n//       const remainingAngle = totalAngle - (sectorsCount * minAngle);\n\n//       console.log(\"Total non-empty points:\", totalNonEmptyPoints);\n//       console.log(\"Remaining angle:\", remainingAngle);\n\n//       const sectorAngles = pointCounts.map((count, idx) => {\n//         const angle = count > 0\n//           ? (count / totalNonEmptyPoints) * remainingAngle\n//           : minAngle;\n//         console.log(`Sector ${idx} angle: ${angle}`);\n//         return angle;\n//       });\n\n//       console.log(\"Sector angles:\", sectorAngles);\n\n//       // Propagate angles to inner rings\n//       const ringAngles = [sectorAngles];\n//       for (let i = pointsData.length - 2; i >= 0; i--) {\n//         const prevAngles = ringAngles[0];\n//         const sectorCount = Math.max(1, 2 ** (i + 1));\n//         if (!Number.isFinite(sectorCount)) {\n//           console.error(`Invalid sectorCount for ring ${i}: ${sectorCount}`);\n//           return []; \n//         }\n//         console.log(`Ring ${i}, sectorCount: ${sectorCount}, isFinite: ${Number.isFinite(sectorCount)}`);\n       \n//         const currAngles = new Array(sectorCount);\n//         console.log(`Propagating to ring ${i}, expected sectors: ${sectorCount}`);\n\n//         for (let j = 0; j < sectorCount; j++) {\n//           const angle1 = prevAngles[j * 2] || 0;\n//           const angle2 = prevAngles[j * 2 + 1] || 0;\n//           currAngles[j] = angle1 + angle2;\n//           console.log(`Ring ${i}, sector ${j}: ${currAngles[j]} (from ${angle1} + ${angle2})`);\n//         }\n//         ringAngles.unshift(currAngles);\n//       }\n\n//       console.log(\"Final ring angles:\", ringAngles);\n//       return ringAngles;\n//     };\n\n//     const renderNormalView = () => {\n//       subspaces.forEach((key, index) => {\n//         if (!ringVisibility[key]) return;\n//         const innerRadius = (index / subspaces.length) * maxRadius;\n//         const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//         const sectors = 2 ** (index + 1);\n//         const rotationOffset = Math.PI / 2;\n\n//         for (let i = 0; i < sectors; i++) {\n//           const startAngle = (2 * Math.PI * i) / sectors + rotationOffset;\n//           const endAngle = (2 * Math.PI * (i + 1)) / sectors + rotationOffset;\n\n//           g.append(\"path\")\n//             .attr(\"d\", d3.arc()\n//               .innerRadius(innerRadius)\n//               .outerRadius(outerRadius)\n//               .startAngle(startAngle)\n//               .endAngle(endAngle)\n//             )\n//             .attr(\"fill\", getSectorColor(index, i))\n//             .attr(\"fill-opacity\", 0.3)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 0.5)\n//             .style(\"cursor\", \"pointer\");\n\n//           g.append(\"text\")\n//             .attr(\"x\", 0)\n//             .attr(\"y\", -outerRadius - 5)\n//             .attr(\"text-anchor\", \"middle\")\n//             .attr(\"font-size\", \"16px\")\n//             .attr(\"fill\", \"red\")\n//             .attr(\"font-weight\", \"bold\")\n//             .text(ringLabels[index]);\n//         }\n//         renderPoints(index, innerRadius, outerRadius, sectors);\n//       });\n//     };\n\n//     const renderProportionalView = () => {\n//       const ringAngles = calculateProportionalAngles();\n//       console.log(\"Rendering proportional view with ringAngles:\", ringAngles);\n\n//       if (!ringAngles || ringAngles.length !== pointsData.length || ringAngles.some(arr => !arr || !Array.isArray(arr))) {\n//         console.error(\"Invalid ring angles, falling back to normal view:\", ringAngles);\n//         renderNormalView();\n//         return;\n//       }\n\n//       subspaces.forEach((key, index) => {\n//         if (!ringVisibility[key]) return;\n//         const innerRadius = (index / subspaces.length) * maxRadius;\n//         const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n//         let currentAngle = Math.PI / 2 - 90;\n\n//         ringAngles[index].forEach((angle, i) => {\n//           const startAngle = currentAngle;\n//           const endAngle = currentAngle + angle;\n\n//           g.append(\"path\")\n//             .attr(\"d\", d3.arc()\n//               .innerRadius(innerRadius)\n//               .outerRadius(outerRadius)\n//               .startAngle(startAngle)\n//               .endAngle(endAngle)\n//             )\n//             .attr(\"fill\", getSectorColor(index, i))\n//             .attr(\"fill-opacity\", 0.3)\n//             .attr(\"stroke\", \"black\")\n//             .attr(\"stroke-width\", 0.5)\n//             .style(\"cursor\", \"pointer\");\n\n//           currentAngle = endAngle;\n//         });\n\n//         g.append(\"text\")\n//           .attr(\"x\", 0)\n//           .attr(\"y\", -outerRadius - 5)\n//           .attr(\"text-anchor\", \"middle\")\n//           .attr(\"font-size\", \"16px\")\n//           .attr(\"fill\", \"red\")\n//           .attr(\"font-weight\", \"bold\")\n//           .text(ringLabels[index]);\n\n//         renderPoints(index, innerRadius, outerRadius, ringAngles[index]);\n//       });\n//     };\n\n//     const renderPoints = (index, innerRadius, outerRadius, anglesOrSectors) => {\n//       const isProportional = viewMode === \"proportional\";\n//       const sectors = isProportional ? anglesOrSectors.length : anglesOrSectors;\n//       const angles = isProportional ? anglesOrSectors : Array(sectors).fill(2 * Math.PI / sectors);\n\n//       let currentAngle = Math.PI / 2;\n//       pointsData[index].points.forEach((point, i) => {\n//         const pointData = Object.entries(point).filter(([key]) => key !== \"Point_ID\");\n//         const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n//         const bitVectorIndex = Math.min(parseInt(bitVector, 2), sectors - 1);\n\n//         const startAngle = isProportional ?\n//           currentAngle + angles.slice(0, bitVectorIndex).reduce((a, b) => a + b, 0) :\n//           (2 * Math.PI * bitVectorIndex) / sectors;\n//         const angleWidth = isProportional ? angles[bitVectorIndex] : (2 * Math.PI / sectors);\n//         const centerAngle = startAngle + angleWidth / 2;\n\n//         const minRadius = innerRadius;\n//         const maxRadius = outerRadius;\n//         const randomRadius = minRadius + Math.random() * (maxRadius - minRadius);\n//         const totalPoints = pointsData[index].points.length;\n//         const clusterFactor = 0.9;\n//         const overlapRadius =\n//           innerRadius +\n//           (clusterFactor * (outerRadius - innerRadius) * (i % totalPoints)) /\n//           totalPoints;\n//         const x = overlapRadius * Math.cos(centerAngle);\n//         const y = overlapRadius * Math.sin(centerAngle);\n\n//         point.Point_ID.forEach((id) => {\n//           if (!pointPositions[id]) {\n//             pointPositions[id] = [];\n//           }\n//           pointPositions[id].push({ x, y, point, subspaceId: pointsData[index].key });\n//         });\n\n//         g.append(\"circle\")\n//           .attr(\"cx\", x)\n//           .attr(\"cy\", y)\n//           .attr(\"r\", 3)\n//           .attr(\"fill\", \"black\")\n//           .attr(\"stroke\", \"white\")\n//           .attr(\"stroke-width\", 0.5)\n//           .style(\"pointer-events\", \"visible\")\n//           .on(\"mouseover\", (event) => {\n//             const pointIds = point.Point_ID.join(\", \");\n//             let associatedLabels = [];\n//             if (labelsData && labelsData.labels) {\n//               Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n//                 if (point.Point_ID.some(id => pointList.includes(Number(id)))) {\n//                   associatedLabels.push(label);\n//                 }\n//               });\n//             }\n//             const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n\n//             tooltip\n//               .style(\"visibility\", \"visible\")\n//               .html(\n//                 `Point_IDs: ${pointIds}<br>Coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})<br>Subspace: ${pointsData[index].key}<br>Label: ${labelText}`\n//               );\n//             setHoveredCoordinates({ ...point, label: labelText });\n//           })\n//           .on(\"mousemove\", (event) => {\n//             tooltip\n//               .style(\"top\", event.pageY + 10 + \"px\")\n//               .style(\"left\", event.pageX + 10 + \"px\");\n//           })\n//           .on(\"mouseout\", () => {\n//             tooltip.style(\"visibility\", \"hidden\");\n//             setHoveredCoordinates(null);\n//           });\n//       });\n//     };\n\n//     if (viewMode === \"normal\") {\n//       renderNormalView();\n//     } else {\n//       renderProportionalView();\n//     }\n\n//     Object.entries(pointPositions).forEach(([pointId, positions]) => {\n//       if (positions.length > 1) {\n//         for (let i = 0; i < positions.length - 1; i++) {\n//           const line = g.append(\"line\")\n//             .attr(\"x1\", positions[i].x)\n//             .attr(\"y1\", positions[i].y)\n//             .attr(\"x2\", positions[i + 1].x)\n//             .attr(\"y2\", positions[i + 1].y)\n//             .attr(\"stroke\", getLabelColor(pointId))\n//             .attr(\"stroke-width\", 1.5)\n//             .attr(\"stroke-opacity\", 0.9)\n//             .style(\"cursor\", \"pointer\")\n//             .on(\"mouseover\", (event) => {\n//               tooltip\n//                 .style(\"visibility\", \"visible\")\n//                 .html(`Connection: Point_ID ${pointId}`);\n//             })\n//             .on(\"mousemove\", (event) => {\n//               tooltip\n//                 .style(\"top\", event.pageY + 10 + \"px\")\n//                 .style(\"left\", event.pageX + 10 + \"px\");\n//             })\n//             .on(\"mouseout\", () => {\n//               tooltip.style(\"visibility\", \"hidden\");\n//             });\n//         }\n//       }\n//     });\n\n//     const zoom = d3.zoom().on(\"zoom\", (event) => {\n//       g.attr(\"transform\", event.transform);\n//     });\n//     svg.call(zoom);\n\n//     return () => {\n//       tooltip.remove();\n//     };\n//   }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates, viewMode]);\n\n//   return (\n//     <div style={{ width: \"100%\", height: \"100%\" }}>\n//       <div style={{ marginBottom: \"10px\" }}>\n//         <button\n//           onClick={() => setViewMode(\"normal\")}\n//           style={{\n//             marginRight: \"10px\",\n//             padding: \"5px 10px\",\n//             backgroundColor: viewMode === \"normal\" ? \"#4CAF50\" : \"#f0f0f0\",\n//             color: viewMode === \"normal\" ? \"white\" : \"black\",\n//           }}\n//         >\n//           Normal View\n//         </button>\n//         <button\n//           onClick={() => setViewMode(\"proportional\")}\n//           style={{\n//             padding: \"5px 10px\",\n//             backgroundColor: viewMode === \"proportional\" ? \"#4CAF50\" : \"#f0f0f0\",\n//             color: viewMode === \"proportional\" ? \"white\" : \"black\",\n//           }}\n//         >\n//           Proportional View\n//         </button>\n//       </div>\n//       <svg ref={graphRef} style={{ width: \"100%\", height: \"800px\" }}></svg>\n//     </div>\n//   );\n// };\n\n// export default HierarchicalGraph;\n\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\n\nconst HierarchicalGraph = ({ jsonData, labelsData, setHoveredCoordinates, ringVisibility }) => {\n  const graphRef = useRef(null);\n  const [viewMode, setViewMode] = useState(\"normal\");\n\n  useEffect(() => {\n    if (!jsonData || typeof jsonData !== \"object\" || Object.keys(jsonData).length === 0) {\n      console.error(\"Invalid or empty jsonData:\", jsonData);\n      return;\n    }\n\n    if (!labelsData || typeof labelsData !== \"object\") {\n      console.error(\"Invalid labelsData:\", labelsData);\n      return;\n    }\n\n    const svg = d3.select(graphRef.current);\n    svg.selectAll(\"*\").remove();\n\n    const width = 800;\n    const height = 800;\n    const margin = 20;\n    const maxRadius = Math.min(width, height) / 2 - margin;\n\n    // Create a single group element for all content\n    const g = svg\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .append(\"g\")\n      .attr(\"transform\", `translate(${width / 2}, ${height / 2})`);\n\n    // Create tooltip only once and reuse it\n    let tooltip = d3.select(\"body\").select(\".hierarchical-graph-tooltip\");\n    if (tooltip.empty()) {\n      tooltip = d3\n        .select(\"body\")\n        .append(\"div\")\n        .attr(\"class\", \"hierarchical-graph-tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"visibility\", \"hidden\")\n        .style(\"background-color\", \"rgba(0, 0, 0, 0.7)\")\n        .style(\"color\", \"white\")\n        .style(\"padding\", \"5px\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"12px\");\n    }\n\n    // Use memoized color functions to avoid recalculating\n    const colorCache = new Map();\n    const getLabelColor = (pointId) => {\n      if (colorCache.has(`label-${pointId}`)) {\n        return colorCache.get(`label-${pointId}`);\n      }\n\n      if (!labelsData || !labelsData.labels) {\n        colorCache.set(`label-${pointId}`, \"gray\");\n        return \"gray\";\n      }\n\n      for (const label of Object.keys(labelsData.labels)) {\n        const pointList = labelsData.labels[label];\n        if (Array.isArray(pointList) && pointList.includes(Number(pointId))) {\n          const color = colorScale(label);\n          colorCache.set(`label-${pointId}`, color);\n          return color;\n        }\n      }\n\n      colorCache.set(`label-${pointId}`, \"gray\");\n      return \"gray\";\n    };\n\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(Object.keys(labelsData.labels || {}));\n\n    const ringColorCache = new Map();\n    const getRingColor = (index) => {\n      if (ringColorCache.has(index)) {\n        return ringColorCache.get(index);\n      }\n\n      const totalRings = Object.keys(jsonData).length;\n      const colorScaleInd = d3.scaleSequential(d3.interpolatePlasma).domain([totalRings, 0]);\n      const color = d3.color(colorScaleInd(index));\n      ringColorCache.set(index, color);\n      return color;\n    };\n\n    const sectorColorCache = new Map();\n    const getSectorColor = (index, sectorIndex) => {\n      const key = `${index}-${sectorIndex}`;\n      if (sectorColorCache.has(key)) {\n        return sectorColorCache.get(key);\n      }\n\n      const baseColor = d3.hsl(getRingColor(index));\n      const isPositive = sectorIndex % 2 === 0;\n      const color = d3.hsl(baseColor.h, baseColor.s, isPositive ? 0.75 : 0.35).toString();\n      sectorColorCache.set(key, color);\n      return color;\n    };\n\n    const subspaces = Object.keys(jsonData);\n    subspaces.sort((a, b) => a.length - b.length);\n\n    // Preprocess data once\n    const pointsData = subspaces.map((key) => {\n      const points = jsonData[key] || [];\n      const dimensions = key.length;\n\n      // Pre-calculate sector indices for each point\n      const pointsWithSectors = points.map(point => {\n        const pointData = Object.entries(point).filter(([k]) => k !== \"Point_ID\");\n        const bitVector = pointData.map(([_, coord]) => (coord >= 0 ? 1 : 0)).join(\"\");\n        const sectorIndex = parseInt(bitVector, 2);\n        return { ...point, sectorIndex };\n      });\n\n      return {\n        key,\n        points: pointsWithSectors,\n        dimensions,\n        subspaceId: key\n      };\n    });\n\n    const ringLabels = subspaces.map((_, i) => String.fromCharCode(65 + i));\n    const pointPositions = {};\n\n    const calculateProportionalAngles = () => {\n      // Count points in each sector for each ring (optimize calculation)\n      const sectorCounts = pointsData.map(ring => {\n        const sectors = 2 ** ring.dimensions;\n        const counts = new Array(sectors).fill(0);\n\n        // Use pre-calculated sector indices\n        ring.points.forEach(point => {\n          if (point.sectorIndex >= 0 && point.sectorIndex < sectors) {\n            counts[point.sectorIndex]++;\n          }\n        });\n\n        return counts;\n      });\n\n      // Calculate initial angles based on point counts\n      const angles = sectorCounts.map(counts => {\n        const totalPoints = Math.max(1, counts.reduce((sum, count) => sum + count, 0));\n        const totalAngle = 2 * Math.PI;\n        const minAngle = Math.PI / 180;\n        const sectors = counts.length;\n        const remainingAngle = totalAngle - sectors * minAngle;\n\n        return counts.map(count =>\n          count > 0 ? minAngle + (count / totalPoints) * remainingAngle : minAngle\n        );\n      });\n\n      // Adjust angles to maintain hierarchy (work with a copy to avoid modifying original)\n      const adjustedAngles = angles.map(ring => [...ring]);\n\n      // From inner to outer rings\n      for (let i = 0; i < adjustedAngles.length - 1; i++) {\n        const currentRing = adjustedAngles[i];\n        const nextRing = adjustedAngles[i + 1];\n\n        // Process each parent sector\n        for (let j = 0; j < currentRing.length; j++) {\n          const childIndex1 = j * 2;\n          const childIndex2 = j * 2 + 1;\n\n          if (childIndex1 < nextRing.length && childIndex2 < nextRing.length) {\n            const childSum = nextRing[childIndex1] + nextRing[childIndex2];\n\n            if (childSum > 0) {\n              // Calculate ratios while avoiding division by zero\n              const ratio1 = nextRing[childIndex1] / childSum;\n              const ratio2 = nextRing[childIndex2] / childSum;\n\n              // Distribute parent angle to children\n              nextRing[childIndex1] = currentRing[j] * ratio1;\n              nextRing[childIndex2] = currentRing[j] * ratio2;\n            }\n          }\n        }\n      }\n\n      return adjustedAngles;\n    };\n\n    // Create sector paths and cache them for reuse\n    const createSectorPath = (innerRadius, outerRadius, startAngle, endAngle) => {\n      return d3.arc()\n        .innerRadius(innerRadius)\n        .outerRadius(outerRadius)\n        .startAngle(startAngle)\n        .endAngle(endAngle)();\n    };\n\n    const renderNormalView = () => {\n      // Create container groups for each ring to reduce DOM nodes\n      const ringGroups = subspaces.map((key, index) => {\n        if (!ringVisibility[key]) return null;\n        return g.append(\"g\").attr(\"class\", `ring-${index}`);\n      });\n\n      subspaces.forEach((key, index) => {\n        if (!ringVisibility[key] || !ringGroups[index]) return;\n\n        const ringGroup = ringGroups[index];\n        const innerRadius = (index / subspaces.length) * maxRadius;\n        const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n        const sectors = 2 ** pointsData[index].dimensions;\n        const rotationOffset = Math.PI / 2;\n\n        // Create all sectors in a single pass\n        const sectorsData = Array.from({ length: sectors }, (_, i) => {\n          const startAngle = (2 * Math.PI * i) / sectors + rotationOffset;\n          const endAngle = (2 * Math.PI * (i + 1)) / sectors + rotationOffset;\n          return { index: i, startAngle, endAngle };\n        });\n\n        // Batch append sectors\n        sectorsData.forEach(({ index: i, startAngle, endAngle }) => {\n          ringGroup.append(\"path\")\n            .attr(\"d\", createSectorPath(innerRadius, outerRadius, startAngle, endAngle))\n            .attr(\"fill\", getSectorColor(index, i))\n            .attr(\"fill-opacity\", 0.3)\n            .attr(\"stroke\", \"black\")\n            .attr(\"stroke-width\", 0.5);\n        });\n\n        // Add ring label\n        ringGroup.append(\"text\")\n          .attr(\"x\", 0)\n          .attr(\"y\", -outerRadius - 5)\n          .attr(\"text-anchor\", \"middle\")\n          .attr(\"font-size\", \"16px\")\n          .attr(\"fill\", \"red\")\n          .attr(\"font-weight\", \"bold\")\n          .text(ringLabels[index]);\n\n        // Render points using the normal view settings\n        renderPoints(ringGroup, index, innerRadius, outerRadius, sectors);\n      });\n    };\n\n    const renderProportionalView = () => {\n      const ringAngles = calculateProportionalAngles();\n\n      if (!ringAngles || ringAngles.length !== pointsData.length) {\n        console.error(\"Invalid ring angles, falling back to normal view\");\n        renderNormalView();\n        return;\n      }\n\n      // Create container groups for each ring\n      const ringGroups = subspaces.map((key, index) => {\n        if (!ringVisibility[key]) return null;\n        return g.append(\"g\").attr(\"class\", `ring-${index}`);\n      });\n\n      subspaces.forEach((key, index) => {\n        if (!ringVisibility[key] || !ringGroups[index]) return;\n\n        const ringGroup = ringGroups[index];\n        const innerRadius = (index / subspaces.length) * maxRadius;\n        const outerRadius = ((index + 1) / subspaces.length) * maxRadius;\n        const rotationOffset = Math.PI / 2;\n\n        // Create sectors based on calculated angles\n        let currentAngle = rotationOffset;\n        ringAngles[index].forEach((angle, i) => {\n          const startAngle = currentAngle;\n          const endAngle = currentAngle + angle;\n\n          ringGroup.append(\"path\")\n            .attr(\"d\", createSectorPath(innerRadius, outerRadius, startAngle, endAngle))\n            .attr(\"fill\", getSectorColor(index, i))\n            .attr(\"fill-opacity\", 0.3)\n            .attr(\"stroke\", \"black\")\n            .attr(\"stroke-width\", 0.5);\n\n          currentAngle = endAngle;\n        });\n\n        // Add ring label\n        ringGroup.append(\"text\")\n          .attr(\"x\", 0)\n          .attr(\"y\", -outerRadius - 5)\n          .attr(\"text-anchor\", \"middle\")\n          .attr(\"font-size\", \"16px\")\n          .attr(\"fill\", \"red\")\n          .attr(\"font-weight\", \"bold\")\n          .text(ringLabels[index]);\n\n        // Render points using the proportional view settings\n        renderPoints(ringGroup, index, innerRadius, outerRadius, ringAngles[index], true);\n      });\n    };\n\n    // Optimized point rendering with batching\n    const renderPoints = (ringGroup, ringIndex, innerRadius, outerRadius, anglesOrSectors, isProportional = false) => {\n      const points = pointsData[ringIndex].points;\n      const sectors = isProportional ? anglesOrSectors.length : anglesOrSectors;\n      const rotationOffset = Math.PI / 2;\n\n      // Pre-calculate angles for all sectors to avoid repeated calculations\n      const sectorAngleMap = new Map();\n\n      if (isProportional) {\n        let currentAngle = rotationOffset;\n        anglesOrSectors.forEach((angle, i) => {\n          sectorAngleMap.set(i, { startAngle: currentAngle, width: angle });\n          currentAngle += angle;\n        });\n      } else {\n        const equalAngle = 2 * Math.PI / sectors;\n        for (let i = 0; i < sectors; i++) {\n          sectorAngleMap.set(i, {\n            startAngle: rotationOffset + equalAngle * i,\n            width: equalAngle\n          });\n        }\n      }\n\n      // Use object pooling for point data\n      const pointElements = [];\n      points.forEach((point, i) => {\n        const sectorIndex = point.sectorIndex;\n        if (!sectorAngleMap.has(sectorIndex)) return;\n\n        const { startAngle, width } = sectorAngleMap.get(sectorIndex);\n        const centerAngle = startAngle + width / 2;\n\n        // Distribute points within sector to avoid overlapping\n        const jitter = 0.7 * (Math.random() - 0.5) * width;\n        const jitteredAngle = centerAngle + jitter;\n\n        // Use deterministic radius calculation based on point index\n        const radiusSpan = outerRadius - innerRadius;\n        const radiusOffset = (i % 5) * (radiusSpan / 5);\n        const radius = innerRadius + radiusOffset + radiusSpan * 0.1;\n\n        const x = radius * Math.cos(jitteredAngle);\n        const y = radius * Math.sin(jitteredAngle);\n\n        // Store position for connection lines\n        if (point.Point_ID) {\n          point.Point_ID.forEach((id) => {\n            if (!pointPositions[id]) {\n              pointPositions[id] = [];\n            }\n            pointPositions[id].push({ x, y, point, subspaceId: pointsData[ringIndex].key });\n          });\n        }\n\n        // Create point element data\n        pointElements.push({ x, y, point });\n      });\n\n      // Batch append all points\n      const pointsGroup = ringGroup.append(\"g\").attr(\"class\", \"points\");\n\n      pointsGroup.selectAll(\"circle\")\n        .data(pointElements)\n        .enter()\n        .append(\"circle\")\n        .attr(\"cx\", d => d.x)\n        .attr(\"cy\", d => d.y)\n        .attr(\"r\", 3)\n        .attr(\"fill\", \"black\")\n        .attr(\"stroke\", \"white\")\n        .attr(\"stroke-width\", 0.5)\n        .style(\"pointer-events\", \"visible\")\n        .on(\"mouseover\", function (event, d) {\n          const pointIds = d.point.Point_ID ? d.point.Point_ID.join(\", \") : \"\";\n          let associatedLabels = [];\n\n          if (labelsData && labelsData.labels && d.point.Point_ID) {\n            Object.entries(labelsData.labels).forEach(([label, pointList]) => {\n              if (d.point.Point_ID.some((id) => pointList.includes(Number(id)))) {\n                associatedLabels.push(label);\n              }\n            });\n          }\n\n          const labelText = associatedLabels.length > 0 ? associatedLabels.join(\", \") : \"No Label\";\n\n          tooltip\n            .style(\"visibility\", \"visible\")\n            .html(\n              `Point_IDs: ${pointIds}<br>Coordinates: (${d.x.toFixed(2)}, ${d.y.toFixed(2)})<br>Subspace: ${pointsData[ringIndex].key}<br>Label: ${labelText}`\n            );\n\n          if (setHoveredCoordinates) {\n            setHoveredCoordinates({ ...d.point, label: labelText });\n          }\n        })\n        .on(\"mousemove\", (event) => {\n          tooltip\n            .style(\"top\", event.pageY + 10 + \"px\")\n            .style(\"left\", event.pageX + 10 + \"px\");\n        })\n        .on(\"mouseout\", () => {\n          tooltip.style(\"visibility\", \"hidden\");\n          if (setHoveredCoordinates) {\n            setHoveredCoordinates(null);\n          }\n        });\n    };\n\n    // Render the appropriate view\n    if (viewMode === \"normal\") {\n      renderNormalView();\n    } else {\n      renderProportionalView();\n    }\n\n    // Batch process connections (lines between related points)\n    const batchConnections = () => {\n      const connections = [];\n\n      // Build connection data first\n      Object.entries(pointPositions).forEach(([pointId, positions]) => {\n        if (positions.length > 1) {\n          for (let i = 0; i < positions.length - 1; i++) {\n            connections.push({\n              x1: positions[i].x,\n              y1: positions[i].y,\n              x2: positions[i + 1].x,\n              y2: positions[i + 1].y,\n              pointId,\n              color: getLabelColor(pointId)\n            });\n          }\n        }\n      });\n\n      // Batch append all connections\n      const linesGroup = g.append(\"g\").attr(\"class\", \"connections\");\n\n      linesGroup.selectAll(\"line\")\n        .data(connections)\n        .enter()\n        .append(\"line\")\n        .attr(\"x1\", d => d.x1)\n        .attr(\"y1\", d => d.y1)\n        .attr(\"x2\", d => d.x2)\n        .attr(\"y2\", d => d.y2)\n        .attr(\"stroke\", d => d.color)\n        .attr(\"stroke-width\", 1)\n        .attr(\"stroke-opacity\", 0.7)\n        .on(\"mouseover\", function (event, d) {\n          tooltip\n            .style(\"visibility\", \"visible\")\n            .html(`Connection: Point_ID ${d.pointId}`);\n        })\n        .on(\"mousemove\", (event) => {\n          tooltip\n            .style(\"top\", event.pageY + 10 + \"px\")\n            .style(\"left\", event.pageX + 10 + \"px\");\n        })\n        .on(\"mouseout\", () => {\n          tooltip.style(\"visibility\", \"hidden\");\n        });\n    };\n\n    // Draw connections\n    batchConnections();\n\n    // Add zoom behavior\n    const zoom = d3.zoom()\n      .scaleExtent([0.5, 5])\n      .on(\"zoom\", (event) => {\n        g.attr(\"transform\", event.transform);\n      });\n\n    svg.call(zoom);\n\n    // Only remove tooltip on component unmount\n    return () => {\n      // Don't remove tooltip, it will be reused\n    };\n  }, [jsonData, labelsData, ringVisibility, setHoveredCoordinates, viewMode]);\n\n  return (\n    <div style={{ width: \"100%\", height: \"100%\" }}>\n      <div style={{ marginBottom: \"10px\" }}>\n        <button\n          onClick={() => setViewMode(\"normal\")}\n          style={{\n            marginRight: \"10px\",\n            padding: \"5px 10px\",\n            backgroundColor: viewMode === \"normal\" ? \"#4CAF50\" : \"#f0f0f0\",\n            color: viewMode === \"normal\" ? \"white\" : \"black\",\n          }}\n        >\n          Normal View\n        </button>\n        <button\n          onClick={() => setViewMode(\"proportional\")}\n          style={{\n            padding: \"5px 10px\",\n            backgroundColor: viewMode === \"proportional\" ? \"#4CAF50\" : \"#f0f0f0\",\n            color: viewMode === \"proportional\" ? \"white\" : \"black\",\n          }}\n        >\n          Proportional View\n        </button>\n      </div>\n      <svg ref={graphRef} style={{ width: \"100%\", height: \"800px\" }}></svg>\n    </div>\n  );\n};\n\nexport default HierarchicalGraph;"],"mappings":";;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,OAAO,KAAKC,EAAE,MAAM,IAAI;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEzB,MAAMC,iBAAiB,GAAGA,CAAC;EAAEC,QAAQ;EAAEC,UAAU;EAAEC,qBAAqB;EAAEC;AAAe,CAAC,KAAK;EAAAC,EAAA;EAC7F,MAAMC,QAAQ,GAAGX,MAAM,CAAC,IAAI,CAAC;EAC7B,MAAM,CAACY,QAAQ,EAAEC,WAAW,CAAC,GAAGZ,QAAQ,CAAC,QAAQ,CAAC;EAElDF,SAAS,CAAC,MAAM;IACd,IAAI,CAACO,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIQ,MAAM,CAACC,IAAI,CAACT,QAAQ,CAAC,CAACU,MAAM,KAAK,CAAC,EAAE;MACnFC,OAAO,CAACC,KAAK,CAAC,4BAA4B,EAAEZ,QAAQ,CAAC;MACrD;IACF;IAEA,IAAI,CAACC,UAAU,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;MACjDU,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}